<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lecteur Chinois HSK - Version Complète</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;600;700;800&family=Inter:wght@400;500;600;700;800&family=Noto+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0b0b0c;
  --fg: #f7f7f7;
  --muted: #b5b5b8;
  --panel: #141417;
  --accent: #7aa2ff;
  --card: #101014;
  --border: #22232a;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
  --hsk1: #08d259;
  --hsk2: #229fff;
  --hsk3: #fccf46;
  --hsk4: #ffa52f;
  --hsk5: #ff47c2;
  --hsk6: #c30f54;
  --hsk79: #a0086d;
  --freq1: #4ade80;
  --freq2: #22d3ee;
  --freq3: #60a5fa;
  --freq4: #3b82f6;
  --freq5: #fbbf24;
  --freq6: #fb923c;
  --freq7: #ef4444;
  --freq8: #dc2626;
  --freq9: #7c3aed;
  --correct: #22c55e;
  --incorrect: #ef4444;
}

[data-theme="light"] {
  --bg: #f8fafc;
  --fg: #0f172a;
  --muted: #64748b;
  --panel: #ffffff;
  --accent: #2563eb;
  --card: #ffffff;
  --border: #e2e8f0;
  --shadow: 0 4px 20px rgba(0,0,0,.08);
}

[data-theme="paper"] {
  --bg: #faf8f3;
  --fg: #3e2723;
  --muted: #8d6e63;
  --panel: #fffef7;
  --accent: #d84315;
  --card: #fffef7;
  --border: #d7ccc8;
  --shadow: 0 2px 10px rgba(62,39,35,.1);
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Inter', system-ui, sans-serif;
  background: var(--bg);
  color: var(--fg);
  font-size: 16px;
  line-height: 1.6;
  min-height: 100vh;
  transition: background 0.3s, color 0.3s;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 24px;
  padding-bottom: 120px;
}

.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: var(--shadow);
  transition: all 0.3s;
}

.card:hover { transform: translateY(-2px); }

.section-title {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 16px;
  color: var(--fg);
  display: flex;
  align-items: center;
  gap: 8px;
}

.home-header {
  text-align: center;
  margin-bottom: 32px;
  padding: 20px 0;
}

.home-title {
  font-size: 42px;
  font-weight: 800;
  margin-bottom: 8px;
  color: var(--fg);
}

.home-subtitle {
  font-size: 16px;
  color: var(--muted);
}

.mode-toggle-container {
  display: flex;
  gap: 12px;
  margin-bottom: 32px;
  padding: 8px;
  background: var(--panel);
  border-radius: 16px;
  border: 1px solid var(--border);
}

.mode-toggle-btn {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 20px;
  background: transparent;
  border: 2px solid transparent;
  border-radius: 12px;
  color: var(--muted);
  font-weight: 700;
  cursor: pointer;
  font-size: 15px;
  transition: all 0.3s;
}

.mode-toggle-btn:hover { border-color: var(--accent); }
.mode-toggle-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.mode-icon { width: 32px; height: 32px; }

.tabs-container { margin-bottom: 80px; }

.tabs-nav {
  display: flex;
  gap: 8px;
  margin-bottom: 24px;
  padding: 6px;
  background: var(--panel);
  border-radius: 12px;
  border: 1px solid var(--border);
}

.tab-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 14px 20px;
  background: transparent;
  border: none;
  border-radius: 8px;
  color: var(--muted);
  font-weight: 600;
  font-size: 15px;
  cursor: pointer;
  transition: all 0.2s;
}

.tab-btn:hover { background: var(--border); }
.tab-btn.active { background: var(--accent); color: white; }

.tab-number {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  background: rgba(255,255,255,0.1);
  border-radius: 50%;
  font-size: 13px;
  font-weight: 700;
}

.tab-content { display: none; }
.tab-content.active { display: block; animation: fadeIn 0.3s; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.input-group { margin-bottom: 20px; }

.input-group label {
  display: block;
  font-size: 14px;
  font-weight: 600;
  color: var(--muted);
  margin-bottom: 8px;
}

textarea, input[type="file"], select {
  width: 100%;
  padding: 12px 14px;
  font-family: 'Noto Sans SC', 'Inter', sans-serif;
  font-size: 15px;
  background: var(--panel);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 12px;
  outline: none;
  transition: all 0.2s;
}

textarea { min-height: 140px; resize: vertical; }

textarea:focus, input:focus, select:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(122, 162, 255, 0.1);
}

.status-chip {
  display: inline-block;
  margin-top: 8px;
  padding: 6px 12px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 13px;
  color: var(--muted);
}
.status-chip.clickable {
    cursor: pointer;
    transition: background 0.2s, color 0.2s;
}
.status-chip.clickable:hover {
    background: var(--border);
    color: var(--fg);
}


.theme-switcher { display: flex; gap: 12px; }

.theme-btn {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 2px solid var(--border);
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.theme-btn:hover { transform: scale(1.1); border-color: var(--accent); }

.theme-btn.active::after {
  content: '✓';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 16px;
  font-weight: bold;
  text-shadow: 0 0 4px rgba(0,0,0,0.5);
}

.theme-dark { background: #0b0b0c; }
.theme-light { background: #f8fafc; }
.theme-paper { background: #faf8f3; }

.category-selector {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
}

.category-btn {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 16px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 12px;
  color: var(--muted);
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.category-btn:hover { transform: translateY(-2px); border-color: var(--accent); }
.category-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

.category-icon { width: 24px; height: 24px; }
.category-label { font-size: 13px; text-transform: uppercase; }

.hsk-selector-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 8px;
}

.hsk-selector-btn {
  padding: 12px 16px;
  border: 2px solid var(--border);
  border-radius: 10px;
  background: var(--panel);
  color: var(--fg);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  opacity: 0.5;
}

.hsk-selector-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.hsk-selector-btn.active { opacity: 1; border-color: transparent; }

.hsk-selector-btn[data-level="1"].active { background: var(--hsk1); color: #fff; }
.hsk-selector-btn[data-level="2"].active { background: var(--hsk2); color: #fff; }
.hsk-selector-btn[data-level="3"].active { background: var(--hsk3); color: #333; }
.hsk-selector-btn[data-level="4"].active { background: var(--hsk4); color: #fff; }
.hsk-selector-btn[data-level="5"].active { background: var(--hsk5); color: #fff; }
.hsk-selector-btn[data-level="6"].active { background: var(--hsk6); color: #fff; }
.hsk-selector-btn[data-level="7"].active { background: var(--hsk79); color: #fff; }

#freqSelector .hsk-selector-btn[data-level="1"].active,
#gameFreqSelector .hsk-selector-btn[data-level="1"].active { background: var(--freq1); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="2"].active,
#gameFreqSelector .hsk-selector-btn[data-level="2"].active { background: var(--freq2); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="3"].active,
#gameFreqSelector .hsk-selector-btn[data-level="3"].active { background: var(--freq3); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="4"].active,
#gameFreqSelector .hsk-selector-btn[data-level="4"].active { background: var(--freq4); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="5"].active,
#gameFreqSelector .hsk-selector-btn[data-level="5"].active { background: var(--freq5); color: #333; }
#freqSelector .hsk-selector-btn[data-level="6"].active,
#gameFreqSelector .hsk-selector-btn[data-level="6"].active { background: var(--freq6); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="7"].active,
#gameFreqSelector .hsk-selector-btn[data-level="7"].active { background: var(--freq7); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="8"].active,
#gameFreqSelector .hsk-selector-btn[data-level="8"].active { background: var(--freq8); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="9"].active,
#gameFreqSelector .hsk-selector-btn[data-level="9"].active { background: var(--freq9); color: #fff; }

.game-mode-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
  gap: 12px;
}

.game-mode-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 16px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 12px;
  color: var(--muted);
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
  font-size: 14px;
  min-height: 100px; /* Pour un alignement uniforme */
}

.game-mode-btn svg {
  width: 28px;
  height: 28px;
  stroke-width: 2;
}

.game-mode-btn:hover {
  border-color: var(--accent);
  color: var(--fg);
  transform: translateY(-2px);
}

.game-mode-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.game-mode-btn.active svg {
    color: white; /* Assure que l'icône est blanche si elle hérite de la couleur */
}

.display-mode-selector {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.display-mode-btn {
    padding: 14px 10px;
    background: var(--panel);
    border: 2px solid var(--border);
    border-radius: 10px;
    color: var(--muted);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    font-size: 13px;
}

.display-mode-btn:hover {
    border-color: var(--accent);
    color: var(--fg);
}

.display-mode-btn.active {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
}

.slider-container {
  display: flex;
  align-items: center;
  gap: 12px;
}

.slider {
  flex: 1;
  height: 6px;
  background: var(--border);
  border-radius: 3px;
  outline: none;
  -webkit-appearance: none;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

.slider-value {
  min-width: 90px;
  font-size: 13px;
  font-weight: 600;
  color: var(--muted);
  text-align: right;
}

.checkbox-container {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 14px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s;
  margin-bottom: 12px;
}

.checkbox-container:hover {
  border-color: var(--accent);
  background: var(--border);
}

.checkbox-container input[type="checkbox"] {
  width: 20px;
  height: 20px;
  cursor: pointer;
  accent-color: var(--accent);
}

.checkbox-container label {
  flex: 1;
  cursor: pointer;
  font-size: 15px;
  font-weight: 500;
  color: var(--fg);
  margin: 0;
}

.floating-cta {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
}

.btn-launch {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px 32px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 14px;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(122, 162, 255, 0.4);
  transition: all 0.3s;
}

.btn-launch:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 32px rgba(122, 162, 255, 0.5);
}

.launch-icon {
  width: 24px;
  height: 24px;
}

/* ================================================= */
/* ================ PAGE DE JEU ================== */
/* ================================================= */
.game-page {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  overflow: hidden;
  z-index: 9999;
}

.game-page.active { display: flex; flex-direction: column; }

/* --- Styles pour le Timer déplacé --- */
#gameTimer {
  position: fixed; 
  bottom: 10px;       
  left: 50%;       
  transform: translateX(-50%);
  font-size: 32px; 
  font-weight: 700;
  color: var(--accent); 
  z-index: 10000;  
  padding: 0;      
  line-height: 48px; 
  height: 48px;    
  margin: 0;       
}

/* MODIFICATION : Rétablir le style du bouton Quitter pour la barre de navigation */
.btn-quit {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  color: var(--muted);
  border: 2px solid var(--border);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s;
  margin-left: auto; /* Positionne le bouton tout à droite */
}

.btn-quit:hover {
  background: transparent;
  color: var(--accent);
  border-color: var(--accent);
}

.btn-quit svg { width: 20px; height: 20px; }

.game-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 20px 20px 20px 20px;
  overflow-y: hidden;
  gap: 20px;
  width: 100%;
  max-width: 900px;
  margin: 0 auto;
  height: 100vh;
  padding-bottom: 20px;
}

#gameFooterFixed {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10000;
    padding: 12px 20px;
    background: var(--panel); 
    border-top: 1px solid var(--border);
    box-shadow: var(--shadow);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
}

#gameFooterFixed > .game-result {
    width: auto; /* Annule le width: 100% de la règle précédente */
    /* Le centrage est déjà géré par 'align-items: center' du footer */
}

#gameFooterFixed > * {
    max-width: 900px; /* Limiter la largeur des éléments du pied de page */
    width: 100%;
}

.stats-grid, .game-nav, .game-actions {
    margin: 0 !important;
}

/* -- Bloc de Progression -- */
.progress-section {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 20px;
  width: 100%;
}

.progress-bar {
  height: 12px;
  background: var(--panel);
  border-radius: 6px;
  overflow: hidden;
  margin-bottom: 12px;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), #5684ff);
  transition: width 0.3s ease;
  border-radius: 6px;
  width: 0%;
}

.progress-info {
  display: flex;
  justify-content: space-between;
  font-size: 14px;
  color: var(--muted);
}

#gameTimer {
    font-size: 16px;
    font-weight: 600;
    color: var(--accent);
    padding: 0 8px;
}

/* -- Bloc de Phrase -- */
.translation-hint {
  font-size: 16px;
  color: var(--muted);
  text-align: center;
  padding: 20px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 14px;
  width: 100%;
  line-height: 1.6;
}

.game-main-content {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 24px;
  min-height: 150px;
  flex: 1;
  overflow-y: auto;
  padding-bottom: 150px;
}

.game-section {
  width: 100%;
}

.game-section-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--muted);
  margin-bottom: 12px;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* -- Mode: Réorganiser -- */
#reorder-drag-mode {
    display: flex;
    flex-direction: column;
    gap: 40px;
	flex: 1;
}
.words-zone {
  min-height: 100px;
  padding: 20px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 14px;
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  justify-content: center;
}

.drop-zone {
  border-style: dashed;
  border-color: var(--accent);
}

.word-token {
  padding: 12px 20px;
  background: var(--card);
  border: 2px solid var(--border);
  border-radius: 10px;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 24px;
  font-weight: 500;
  cursor: grab;
  transition: all 0.2s;
  user-select: none;
  touch-action: none;
}

#availableWords .word-token {
  font-size: 19px;
  padding: 5px 13px;
}

#userSentence .word-token {
  font-size: 21px;
  padding: 7px 15px;
}

.word-token:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  border-color: var(--accent);
}

.word-token.dragging {
  opacity: 0.5;
  cursor: grabbing;
  background: var(--accent);
  color: white;
}

.word-token.hint-revealed {
  animation: highlight 0.6s ease-out;
}

@keyframes highlight {
  0%, 100% { background: var(--card); }
  50% { background: var(--accent); color: white; }
}

.drop-placeholder {
  width: 80px;
  height: 48px;
  border: 2px dashed var(--accent);
  border-radius: 10px;
  background: rgba(122, 162, 255, 0.1);
  transition: all 0.2s;
  flex-shrink: 0;
}

.drop-placeholder.drag-over {
  background: rgba(122, 162, 255, 0.3);
  transform: scale(1.05);
}

/* -- Mode: Saisie Libre -- */
.free-textarea {
  width: 100%;
  min-height: 80px;
  padding: 16px;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 25px;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
  border-radius: 14px;
  outline: none;
  resize: vertical;
}

.free-textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(122, 162, 255, 0.1);
}

/* -- Mode: Frappe Live & Time Attack -- */
#live-typing-mode, #time-attack-mode {
  display: block;
  flex-direction: column;
  gap: 16px;
}
.typing-target-text {
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 28px;
  font-weight: 500;
  line-height: 1.8;
  padding: 20px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  min-height: 100px;
  text-align: center;
}
.typing-target-text span {
  color: var(--muted); /* Ajouté : Couleur par défaut grise */
  transition: color 0.2s, background 0.2s;
}
.typing-target-text .char-correct {
  color: var(--correct);
}
.typing-target-text .char-incorrect {
  color: var(--incorrect);
  background: rgba(239, 68, 68, 0.2);
  border-radius: 4px;
  text-decoration: underline wavy var(--incorrect);
}
.typing-target-text .char-current {
  background: var(--accent);
  color: white;
  border-radius: 4px;
}
.typing-input {
  width: 100%;
  padding: 16px;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 25px;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
  border-radius: 14px;
  outline: none;
  margin-top: 20px;
  transition: border-color 0.2s;
  min-height: 80px;
  resize: vertical;
}
.typing-input:focus {
  border-color: var(--accent);
}
.typing-instruction {
    text-align: center;
    color: var(--muted);
    font-style: italic;
    margin-top: -10px;
    margin-bottom: 10px;
}


/* -- Mode: Phrases à Trous -- */
#fill-blanks-char-mode, #fill-blanks-pinyin-mode {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.blanks-display-text {
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 28px;
  font-weight: 500;
  line-height: 1.8;
  padding: 20px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  min-height: 100px;
  text-align: center;
}
.blank-space {
  display: inline-block;
  min-width: 40px;
  padding: 0 8px;
  margin: 0 4px;
  border-bottom: 2px solid var(--muted);
  color: var(--muted);
  font-weight: 700;
  cursor: pointer;
}
.blank-space.current-blank {
  border-bottom-color: var(--accent);
  color: var(--accent);
  background: rgba(122, 162, 255, 0.1);
  border-radius: 4px;
}
.blank-space.filled-blank-correct {
  border-bottom: 2px solid transparent;
  color: var(--correct);
  font-weight: 500;
  cursor: default;
}
.blank-space.filled-blank-incorrect {
  border-bottom: 2px solid transparent;
  color: var(--incorrect);
  font-weight: 500;
}

.blank-space.blank-with-hint {
  color: var(--muted);
  opacity: 0.8;
  vertical-align: baseline;
  transition: color 0.2s, opacity 0.2s;
}

.blank-space.blank-with-hint.current-blank {
  color: var(--accent);
  opacity: 1;
}

.blank-space.filled-blank-correct.blank-with-hint {
  color: var(--correct);
  opacity: 1;
  border-bottom-color: transparent;
}

.blanks-input {
  width: 100%;
  padding: 16px;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 25px;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
  border-radius: 14px;
  outline: none;
  margin-top: 20px;
}
.blanks-input:focus {
  border-color: var(--accent);
}

/* -- Popup Pinyin (Mode 6) -- */
#pinyinTonePopup {
  position: absolute;
  background: var(--card);
  border: 1px solid var(--accent);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  padding: 8px;
  display: none;
  z-index: 10002;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 18px;
}

.tone-option {
  display: inline-block;
  padding: 4px 8px;
  cursor: pointer;
  border-radius: 4px;
}
.tone-option:hover {
  background: var(--panel);
}
.tone-option kbd {
  font-size: 12px;
  color: var(--muted);
  font-weight: 600;
  margin-left: 4px;
}

#blanks-input-pinyin,
#pinyinTonePopup,
#dictModalBody { /* Assurez-vous que le modal générique est aussi inclus */
    font-family: 'Noto Sans', 'Noto Sans SC', sans-serif;
}

/* -- Actions et Résultats -- */
.game-result {
  display: none;
  padding: 16px 24px;
  border-radius: 0;
  font-size: 16px;
  font-weight: 600;
  text-align: center;
  position: fixed;
  top: 0; 
  left: 0; 
  width: 100%; 
  z-index: 10001; 
  box-shadow: 0 4px 12px rgba(0,0,0,.2);
  margin: 0;
  transform: translateY(-100%); 
  transition: transform 0.3s ease-out;
}

.game-result.success {
  background: #22c55e; 
  color: #ffffff; /* Texte blanc pour le contraste */
  border: none;
  display: block;
  transform: translateY(0);
}

.game-result.error {
  background: #ef4444; 
  color: #ffffff; /* Texte blanc pour le contraste */
  border: none;
  display: block;
  transform: translateY(0);
}

.game-actions {
  display: flex;
  gap: 16px;
  justify-content: center;
  width: 100%;
  flex-wrap: wrap;
}

.btn-game {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 14px 28px;
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-game svg { width: 20px; height: 20px; }

.btn-hint {
  display: none;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
}

.btn-hint:hover {
  background: var(--border);
  transform: translateY(-1px);
}

.btn-validate {
  background: var(--accent);
  color: white;
}

.btn-validate:hover {
  filter: brightness(1.1);
  transform: translateY(-1px);
}

.btn-restart {
  display: none;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
}
.btn-restart:hover {
  background: var(--border);
  transform: translateY(-1px);
}

/* -- Stats -- */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
  gap: 8px; /* Réduit */
  width: 100%;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px; /* Réduit */
}

.stat-box {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 6px; /* Réduit de moitié */
  text-align: center;
}

.stat-label { font-size: 10px; color: var(--muted); margin-bottom: 2px; text-transform: uppercase;} /* Police réduite */
.stat-value { font-size: 16px; font-weight: 700; color: var(--accent); } /* Police réduite */

/* -- Navigation -- */
.game-nav {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 14px;
  box-shadow: var(--shadow);
  width: 100%;
}

#prevSentenceBtn {
  margin-left: auto;
}

.game-container > .progress-section,
.game-container > .translation-hint,
.game-container > .game-result,
.game-container > .game-actions,
.game-container > .stats-grid,
.game-container > .game-nav {
  flex-shrink: 0;
}

.btn-nav {
  display: flex;
  align-items: center;
  gap: 6px; /* Réduit */
  padding: 10px 14px; /* Réduit */
  background: var(--panel);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 10px;
  font-size: 14px; /* Réduit */
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-nav:hover {
  background: var(--border);
  transform: translateY(-1px);
}

.btn-nav:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-nav svg { width: 16px; height: 16px; } /* Réduit */

.sentence-counter {
  padding: 10px 12px; /* Réduit */
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  font-size: 14px; /* Réduit */
  font-weight: 600;
  color: var(--muted);
  white-space: nowrap; /* Ajouté pour empêcher le retour à la ligne */
}

/* Style pour le sélecteur Clavier/Choix Multiple */
.pinyin-input-type-selector {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  margin-top: 8px; /* Un peu d'espace après le label */
}

.pinyin-input-type-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 10px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 10px;
  color: var(--muted);
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
  font-size: 13px;
}

.pinyin-input-type-btn svg {
  width: 18px;
  height: 18px;
  flex-shrink: 0;
}

.pinyin-input-type-btn:hover {
  border-color: var(--accent);
  color: var(--fg);
}

.pinyin-input-type-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Conteneur des options Pinyin MCQ */
.pinyin-mcq-container {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 25px; /* Espace au-dessus des options */
}

/* Boutons d'option Pinyin MCQ */
.pinyin-option-btn {
  padding: 10px 18px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 10px;
  color: var(--fg);
  font-size: 18px; /* Taille de police pour le pinyin */
  font-weight: 500;
  font-family: 'Noto Sans', 'Noto Sans SC', sans-serif; /* Assurer la bonne police */
  cursor: pointer;
  transition: all 0.2s;
  min-width: 80px; /* Largeur minimale */
  text-align: center;
}

.pinyin-option-btn:hover {
  border-color: var(--accent);
  background: var(--border);
}

/* Style pour indiquer le caractère actif dans le trou (indice) */
.blank-space.blank-with-hint .active-char-hint {
  display: inline-block; /* Nécessaire pour appliquer le fond */
  background-color: rgba(122, 162, 255, 0.2); /* Fond bleu léger */
  border-radius: 3px;
}

/* Animation pour feedback incorrect */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

.pinyin-option-btn.mcq-incorrect {
  animation: shake 0.3s ease-in-out;
  border-color: var(--incorrect) !important;
  background: rgba(239, 68, 68, 0.2); /* Fond rouge léger */
}

/* ================================================= */
/* =========== STICKY DROP ZONE (AJOUT) ============ */
/* ================================================= */
#reorder-drop-section {
  position: sticky;
  top: 0; 
  z-index: 100; 
  background: var(--bg); 
  padding-top: 10px;
  padding-bottom: 16px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  border-bottom: 1px solid var(--border);
  border-radius: 0 0 14px 14px;
  padding-top: 2px;
  flex-shrink: 0; /* Ne se compresse pas */
}


/* Ajustement pour que le titre "Votre phrase" ne soit pas collé en haut */
#reorder-drop-section .game-section-title {
  padding-top: 0px; 
}

/* ================================================= */
/* =============== FIN PAGE DE JEU ================= */
/* ================================================= */

/* ================================================= */
/* ============== PAGE DE LECTURE ================ */
/* ================================================= */
.read-page {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  overflow: hidden;
  z-index: 9999;
}

.read-page.active { display: flex; flex-direction: column; }

/* Barre de Contrôle - Lecture */
.read-controls {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: var(--panel);
  border-bottom: 1px solid var(--border);
  padding: 12px 16px; /* Ajuster padding légèrement */
  display: flex;
  align-items: center;
  gap: 10px; /* Réduire l'espacement un peu */
  z-index: 10000;
  box-shadow: var(--shadow);
  flex-wrap: nowrap; /* EMPÊCHER le retour à la ligne par défaut (desktop) */
  min-height: 70px; /* Garder une hauteur minimale */
  overflow-x: auto; /* Permettre le défilement horizontal si ça dépasse sur très petit écran */
}

.read-close {
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #ef4444;
  color: white;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  flex-shrink: 0;
}

.read-close:hover { background: #dc2626; }

.read-play-pause {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  flex-shrink: 0;
}

.read-play-pause svg { width: 24px; height: 24px; }

.read-play-pause:hover { filter: brightness(1.1); }

.read-mode-toggle, .read-zen-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--fg);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}

.read-mode-toggle svg, .read-zen-toggle svg {
  width: 18px;
  height: 18px;
}

.read-mode-toggle:hover { background: var(--border); }


/* Style for the active mode toggle button */
.read-mode-toggle.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

/* Style for disabled buttons (Play/Pause) */
#readPlayPause:disabled,
#szBtnPlay:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  filter: grayscale(50%); /* Optional: make it look more disabled */
}

/* Style pour le bouton Focus désactivé */
#readFocusToggle:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  filter: grayscale(50%); /* Optionnel: le rend plus gris */
  /* Empêcher l'effet hover quand désactivé */
  pointer-events: none;
}

.read-zen-toggle {
  background: var(--accent);
  border: 1px solid var(--accent);
  color: white;
}

.read-zen-toggle:hover { filter: brightness(1.1); }

.read-font-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-shrink: 0;
}

.read-font-btn {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--fg);
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
}

.read-font-btn:hover { background: var(--border); }

.read-font-size {
  font-size: 12px;
  color: var(--muted);
  font-weight: 600;
  min-width: 45px;
  text-align: center;
}

.difficulty-gauge {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 8px 12px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 10px;
  flex-shrink: 0;
}

.difficulty-label {
  font-size: 10px;
  color: var(--muted);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.difficulty-bar {
  height: 6px;
  background: var(--border);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
  width: 80px;
}

.difficulty-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.5s ease, background 0.5s ease;
}

.difficulty-text {
  font-size: 12px;
  font-weight: 700;
  color: var(--fg);
}

.read-filter-legend {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  align-items: center;
  min-width: 0
}

.read-filter-legend span {
  font-size: 11px;
  color: var(--muted);
  font-weight: 600;
  white-space: nowrap;
  margin-right: 6px; /* Espace après "FILTRES:" */
}

.read-legend-chip {
  padding: 6px 12px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid;
  background: transparent;
  white-space: nowrap;
  flex-shrink: 0; /* Empêche les chips de rétrécir */
}

.read-legend-chip:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

.read-legend-chip.level-1 { border-color: var(--hsk1); color: var(--hsk1); }
.read-legend-chip.level-2 { border-color: var(--hsk2); color: var(--hsk2); }
.read-legend-chip.level-3 { border-color: var(--hsk3); color: var(--hsk3); }
.read-legend-chip.level-4 { border-color: var(--hsk4); color: var(--hsk4); }
.read-legend-chip.level-5 { border-color: var(--hsk5); color: var(--hsk5); }
.read-legend-chip.level-6 { border-color: var(--hsk6); color: var(--hsk6); }
.read-legend-chip.level-79 { border-color: var(--hsk79); color: var(--hsk79); }

.read-legend-chip.freq-1 { border-color: var(--freq1); color: var(--freq1); }
.read-legend-chip.freq-2 { border-color: var(--freq2); color: var(--freq2); }
.read-legend-chip.freq-3 { border-color: var(--freq3); color: var(--freq3); }
.read-legend-chip.freq-4 { border-color: var(--freq4); color: var(--freq4); }
.read-legend-chip.freq-5 { border-color: var(--freq5); color: var(--freq5); }
.read-legend-chip.freq-6 { border-color: var(--freq6); color: var(--freq6); }
.read-legend-chip.freq-7 { border-color: var(--freq7); color: var(--freq7); }
.read-legend-chip.freq-8 { border-color: var(--freq8); color: var(--freq8); }
.read-legend-chip.freq-9 { border-color: var(--freq9); color: var(--freq9); }

.read-legend-chip.active.level-1 { background: var(--hsk1); border-color: var(--hsk1); color: #fff; }
.read-legend-chip.active.level-2 { background: var(--hsk2); border-color: var(--hsk2); color: #fff; }
.read-legend-chip.active.level-3 { background: var(--hsk3); border-color: var(--hsk3); color: #333; }
.read-legend-chip.active.level-4 { background: var(--hsk4); border-color: var(--hsk4); color: #fff; }
.read-legend-chip.active.level-5 { background: var(--hsk5); border-color: var(--hsk5); color: #fff; }
.read-legend-chip.active.level-6 { background: var(--hsk6); border-color: var(--hsk6); color: #fff; }
.read-legend-chip.active.level-79 { background: var(--hsk79); border-color: var(--hsk79); color: #fff; }

.read-legend-chip.active.freq-1 { background: var(--freq1); border-color: var(--freq1); color: #fff; }
.read-legend-chip.active.freq-2 { background: var(--freq2); border-color: var(--freq2); color: #fff; }
.read-legend-chip.active.freq-3 { background: var(--freq3); border-color: var(--freq3); color: #fff; }
.read-legend-chip.active.freq-4 { background: var(--freq4); border-color: var(--freq4); color: #fff; }
.read-legend-chip.active.freq-5 { background: var(--freq5); border-color: var(--freq5); color: #333; }
.read-legend-chip.active.freq-6 { background: var(--freq6); border-color: var(--freq6); color: #fff; }
.read-legend-chip.active.freq-7 { background: var(--freq7); border-color: var(--freq7); color: #fff; }
.read-legend-chip.active.freq-8 { background: var(--freq8); border-color: var(--freq8); color: #fff; }
.read-legend-chip.active.freq-9 { background: var(--freq9); border-color: var(--freq9); color: #fff; }

.read-legend-focus {
  /* Inherited/Base Styles (from .read-legend-chip potentially) */
  display: flex; /* Overrides default inline-block if chip uses it */
  align-items: center; /* Vertical alignment */
  padding: 5px 10px; /* Same padding as chips */
  border-radius: 12px; /* Same border radius */
  font-size: 10px; /* Same font size */
  font-weight: 600; /* Same font weight */
  cursor: pointer; /* Pointer cursor */
  transition: all 0.2s; /* Same transition */
  white-space: nowrap; /* Prevent wrapping text */
  background: transparent; /* Ensure no background inherited */
  gap: 6px; /* Space between icon/text if any */
  border: 2px solid #ffffff !important; /* Specific white border */
  color: #ffffff !important; /* Specific white text color */
  margin-left: 10px; /* Space after filter chips */
  flex-shrink: 0; /* Prevent shrinking */
}

.read-legend-focus:hover {
  transform: scale(1.05); /* Same hover effect as chips */
  box-shadow: 0 2px 8px rgba(0,0,0,0.15); /* Same hover effect */
  border-color: #ffffff !important;
  color: #ffffff !important;
  background: transparent; /* Ensure no background on hover */
}

.read-legend-focus.active {
  background: #ffffff !important;
  border-color: #ffffff !important;
  color: var(--bg) !important;
}

/* Barre de Progression - Rétablir flex: 1 */
.read-progress {
  flex: 1 1 auto; /* Prend l'espace disponible, peut rétrécir mais préfère s'étendre */
  min-width: 150px; /* Largeur minimale raisonnable */
  height: 8px;
  background: var(--border);
  border-radius: 999px;
  overflow: hidden;
  cursor: pointer;
  margin: 0 10px; /* Marges H simples */
}

.read-progress-bar {
  height: 100%;
  background: var(--accent);
  width: 0%;
  transition: width 0.1s linear;
}

.read-content {
  position: absolute;
  top: 80px; /* Espace pour la barre de contrôle */
  left: 0;
  right: 0;
  bottom: 0;
  overflow-y: auto;
  padding: 40px;
  display: flex;
  flex-direction: row; /* Défaut pour desktop */
  align-items: flex-start;
  justify-content: center;
  gap: 40px;
}

/* Ajustement de la hauteur du contenu en fonction de la barre de contrôle */
.read-page.active .read-content {
    /* Calcul dynamiquement via JS si nécessaire, ou valeur fixe suffisante */
    top: 80px; /* Ou une valeur plus grande si la barre prend 2 lignes */
}


.read-text-container {
  max-width: 1400px;
  width: 100%;
  display: flex;
  flex-direction: row; /* Défaut pour desktop */
  gap: 40px;
  align-items: flex-start;
}

.read-text {
  font-family: 'Noto Sans SC', sans-serif;
  line-height: 2.2;
  flex: 1;
  min-width: 0;
  padding: 16px;
  background: var(--card);
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
  text-align: justify; 
  text-justify: inter-character; 
}

.read-translation {
  font-family: 'Inter', sans-serif;
  line-height: 1.8;
  flex: 1;
  min-width: 0;
  padding: 16px; 
  background: var(--panel);
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
  color: var(--muted);
  font-style: italic;
  font-size: 0.9em; 
  text-align: justify; 
  hyphens: auto; 
}


/* ===== EFFET FLIP 3D POUR MOBILE ===== */
.flip-container {
  perspective: 1000px;
  width: 100%;
  min-height: 400px; /* Hauteur minimale pour la visibilité */
  position: relative;
}

/* Recto (chinois) cliquable par défaut */
.flip-container .flip-front {
  z-index: 2;
  pointer-events: auto;
  backface-visibility: hidden;
}

/* Verso (traduction) présent mais non cliquable tant qu'on n'a pas retourné */
.flip-container .flip-back {
  position: absolute;
  inset: 0;
  width: 100%;
  pointer-events: none;          /* ← clé pour ne plus bloquer les clics */
  z-index: 1;
  backface-visibility: hidden;
  transform: rotateY(180deg);
}

/* Quand la carte est retournée (ajoute .flipped sur #flipContainer), on inverse */
.flip-container.flipped .flip-front {
position: absolute;
  pointer-events: none;
  z-index: 1;
}
.flip-container.flipped .flip-back {
  pointer-events: auto;
  z-index: 2;
}

.flip-container.flipped .flip-inner {
  transform: rotateY(180deg);
}

.flip-inner {
  position: relative; /* Changé de absolute à relative */
  width: 100%;
  height: auto;
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.flip-front,
.flip-back {
  position: absolute; /* Garder absolute pour la superposition */
  top: 0; /* Assurer l'alignement */
  left: 0; /* Assurer l'alignement */
  width: 100%;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  padding: 30px;
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
  height: auto;
}

.flip-front {
  background: var(--card);
  font-family: 'Noto Sans SC', sans-serif;
  line-height: 2.2;
  z-index: 2; /* S'assurer que le front est devant initialement */
}

.flip-back {
  background: var(--panel);
  color: var(--muted);
  font-style: italic;
  font-family: 'Inter', sans-serif;
  line-height: 1.8;
  transform: rotateY(180deg);
}

.read-flip-btn {
  display: none; /* Hidden by default, shown via JS/media query */
  position: fixed;
  bottom: 24px;
  right: 24px;
  width: 56px;
  height: 56px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 50%;
  box-shadow: 0 4px 20px rgba(122, 162, 255, 0.4);
  cursor: pointer;
  z-index: 100;
  transition: all 0.3s;
  /* --- CENTERING STYLES --- */
  display: flex; /* Ensure it's flex */
  align-items: center; /* Vertical center */
  justify-content: center; /* Horizontal center */
  padding: 0; /* Remove padding if it interferes */
}
.read-flip-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 25px rgba(122, 162, 255, 0.5);
}
.read-flip-btn svg {
  width: 28px; /* Adjust size as needed */
  height: 28px; /* Adjust size as needed */
  display: block; /* Helps prevent extra space below SVG */
}
/* Adjust position if overlapping with Super Zen controls */
.read-page.super-zen .read-flip-btn {
    bottom: 100px;
}

.read-progress {
    display: none !important; /* Garder caché sur mobile */
  }
/* Légende des Filtres - Pas d'extension, groupée */
.read-filter-legend {
  display: flex;
  gap: 6px;
  align-items: center;
  flex-shrink: 0; /* Ne pas rétrécir les filtres eux-mêmes */
  /* Pas de flex: 1, pas de flex-basis, pas d'order par défaut */
}
   .read-legend-focus {
       margin-left: 8px; /* Simple marge sur mobile */
       order: 11; /* Mettre le bouton focus après les filtres */
       margin-top: 8px; /* Ajouter un espace si ça passe à la ligne */
   }

.read-flip-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 25px rgba(122, 162, 255, 0.5);
}

.read-flip-btn svg {
  width: 28px;
  height: 28px;
}

.read-char {
  display: inline;
  transition: color 0.2s, background-color 0.2s; /* Transition plus simple */
  cursor: pointer;
  position: relative; /* Garder pour le hover potentiel */
}

/* Enlever l'effet de scale au survol, peut causer des décalages */
/* .read-char:hover {
  transform: scale(1.05);
  z-index: 10;
} */

.read-char.hsk1 { color: var(--hsk1); }
.read-char.hsk2 { color: var(--hsk2); }
.read-char.hsk3 { color: var(--hsk3); }
.read-char.hsk4 { color: var(--hsk4); }
.read-char.hsk5 { color: var(--hsk5); }
.read-char.hsk6 { color: var(--hsk6); }
.read-char.hsk79 { color: var(--hsk79); }

.read-char.freq1 { color: var(--freq1); }
.read-char.freq2 { color: var(--freq2); }
.read-char.freq3 { color: var(--freq3); }
.read-char.freq4 { color: var(--freq4); }
.read-char.freq5 { color: var(--freq5); }
.read-char.freq6 { color: var(--freq6); }
.read-char.freq7 { color: var(--freq7); }
.read-char.freq8 { color: var(--freq8); }
.read-char.freq9 { color: var(--freq9); }

/* ================================================= */
/* ============= MODAL GÉNÉRIQUE (JEU) ============= */
/* ================================================= */
.modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2000;
  align-items: center;
  justify-content: center;
  padding: 20px;
  animation: modalFadeIn 0.3s;
}

.modal.active { display: flex; }

@keyframes modalFadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal-content {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 32px;
  max-width: 600px;
  width: 95%;
  max-height: 85vh;
  overflow-y: auto;
  animation: modalSlideIn 0.3s;
  position: relative;
}

@keyframes modalSlideIn {
  from { transform: translateY(-50px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border);
}

.modal-title { font-size: 20px; font-weight: 800; color: var(--fg); }

.modal-close {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
  color: var(--muted);
}

.modal-close:hover { background: #ef4444; color: white; border-color: #ef4444; }

/* Styles spécifiques pour le modal d'aperçu des phrases */
#sentencesPreviewModal .modal-body {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
#sentencesPreviewModal .sentence-preview-item {
  display: flex;
  align-items: flex-start;
  gap: 16px;
  padding: 16px;
  background: var(--panel);
  border-radius: 10px;
  border: 1px solid var(--border);
}
#sentencesPreviewModal .sentence-preview-number {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--accent);
  color: white;
  border-radius: 50%;
  font-weight: 700;
  font-size: 14px;
  flex-shrink: 0;
  margin-top: 4px;
}
#sentencesPreviewModal .sentence-preview-texts {
  flex: 1;
}
#sentencesPreviewModal .sentence-preview-zh {
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 18px;
  margin-bottom: 8px;
  color: var(--fg);
  line-height: 1.7;
}
#sentencesPreviewModal .sentence-preview-tr {
  font-size: 14px;
  color: var(--muted);
  line-height: 1.6;
}

/* ================================================= */
/* =========== MODAL DICT (LECTURE) ================ */
/* ================================================= */
.dict-modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(4px);
  z-index: 99999;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.dict-modal.active {
  display: flex;
}

.dict-modal-content {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 48px 32px 32px 32px;
  max-width: 500px;
  width: 100%;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  animation: modalSlideIn 0.3s ease-out; /* Réutilise l'animation */
  position: relative;
}

.dict-modal-close {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  color: var(--muted);
  transition: all 0.2s;
  z-index: 1;
}

.dict-modal-close:hover {
  background: #ef4444;
  color: white;
  border-color: #ef4444;
}

.dict-char {
  font-size: 72px;
  font-family: 'Noto Sans SC', sans-serif;
  text-align: center;
  margin-bottom: 16px;
  font-weight: 500;
  color: var(--fg);
}

.dict-pinyin {
  font-size: 28px;
  color: var(--accent);
  text-align: center;
  margin-bottom: 24px;
  font-weight: 600;
}

/* ================================================= */
/* =========== STYLES ONGLETS DICT (AJOUT) ========= */
/* ================================================= */

/* Conteneur pour les boutons Pinyin */
.dict-tabs-container {
  display: flex;
  flex-wrap: wrap; 
  gap: 8px;
  margin-bottom: 16px;
  /* S'assure qu'il y a de l'espace après les tags HSK/Freq */
  margin-top: 20px; 
}

/* Style pour un bouton Pinyin (onglet) */
.dict-tab-btn {
  padding: 8px 16px;
  font-size: 15px;
  font-weight: 600;
  /* Utilise la police Inter standard pour les pinyins sans tons étranges */
  font-family: 'Inter', sans-serif; 
  background: var(--card);
  border: 2px solid var(--border);
  color: var(--muted); /* Couleur neutre par défaut */
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.dict-tab-btn:hover {
  border-color: var(--accent); /* Devient bleu au survol */
  color: var(--accent);
}

/* Style de l'onglet actif (Neutre) */
.dict-tab-btn.active {
  background: var(--border); /* Fond neutre (plus foncé) */
  border-color: var(--border);
  color: var(--fg); /* Texte principal (blanc/noir) */
}

/* Conteneur pour les panneaux de définition */
.dict-panes-container {
  position: relative;
}

/* Panneau de définition (caché par défaut) */
.dict-pane {
  display: none;
  animation: fadeIn 0.3s ease;
}

/* Panneau actif (visible) */
.dict-pane.active {
  display: block;
}


/* --- INSERT TAG STYLES HERE --- */
.dict-tags-container {
    text-align: center;
    margin-top: 8px; /* Espace après le pinyin */
    margin-bottom: 20px; /* Espace avant les définitions */
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
}
.dict-tag {
    display: inline-block;
    padding: 5px 12px;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 600;
    line-height: 1.2;
    color: #fff;
}
/* Couleurs HSK */
.dict-tag.level-1 { background: var(--hsk1); color: #fff; }
.dict-tag.level-2 { background: var(--hsk2); color: #fff; }
.dict-tag.level-3 { background: var(--hsk3); color: #333; }
.dict-tag.level-4 { background: var(--hsk4); color: #fff; }
.dict-tag.level-5 { background: var(--hsk5); color: #fff; }
.dict-tag.level-6 { background: var(--hsk6); color: #fff; }
.dict-tag.level-79 { background: var(--hsk79); color: #fff; }
/* Couleurs Fréquence */
.dict-tag.freq-1 { background: var(--freq1); color: #fff; }
.dict-tag.freq-2 { background: var(--freq2); color: #fff; }
.dict-tag.freq-3 { background: var(--freq3); color: #fff; }
.dict-tag.freq-4 { background: var(--freq4); color: #fff; }
.dict-tag.freq-5 { background: var(--freq5); color: #333; }
.dict-tag.freq-6 { background: var(--freq6); color: #fff; }
.dict-tag.freq-7 { background: var(--freq7); color: #fff; }
.dict-tag.freq-8 { background: var(--freq8); color: #fff; }
.dict-tag.freq-9 { background: var(--freq9); color: #fff; }

.dict-definitions {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.dict-def {
  padding: 14px 18px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 10px;
  font-size: 15px;
  line-height: 1.7;
  color: var(--fg);
}

.dict-def:before {
  content: "•";
  color: var(--accent);
  font-weight: bold;
  display: inline-block;
  width: 1em;
  margin-left: -1em;
}

/* ================================================= */
/* =============== MODE SUPER ZEN ================== */
/* ================================================= */
.read-page.super-zen .read-controls {
  display: none; /* Cache la barre de contrôle normale */
}

.read-page.super-zen .read-content {
  top: 0; /* Prend tout l'espace */
  bottom: 80px; /* Espace pour les contrôles super-zen en bas */
  padding: 40px;
  display: flex;
  flex-direction: column; /* Texte au-dessus de la traduction */
  justify-content: center;
  align-items: center;
  text-align: center;
}

/* Style pour le conteneur en mode super-zen */
.read-page.super-zen .read-text-container {
   flex-direction: column; /* Empile texte et trad */
   align-items: center; /* Centre horizontalement */
   justify-content: center; /* Centre verticalement */
   gap: 20px; /* Espace entre texte et trad */
   width: 100%;
   max-width: 90%; /* Limite la largeur max */
}

/* Style pour le texte chinois en mode super-zen */
.read-page.super-zen .read-text {
  font-size: 48px;
  line-height: 1.5;
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
  flex: none;
  width: auto;
  text-align: center;
}

/* Style pour la traduction en mode super-zen */
.read-page.super-zen .read-translation {
  font-size: 24px;
  line-height: 1.6;
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
  color: var(--muted);
  font-style: italic;
  flex: none;
  width: auto;
  text-align: center;
}


.super-zen-controls {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--panel);
  border-top: 1px solid var(--border);
  padding: 16px;
  display: none; /* Caché par défaut */
  align-items: center;
  justify-content: center;
  gap: 12px;
  z-index: 10001; /* Au-dessus du contenu */
  flex-wrap: wrap; /* Permet le passage à la ligne */
  height: 80px; /* Hauteur fixe pour la barre */
}

.read-page.super-zen .super-zen-controls {
  display: flex; /* Affiché seulement en mode super-zen */
}

.super-zen-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--fg);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.super-zen-btn svg {
  width: 18px;
  height: 18px;
}

.super-zen-btn:hover {
  background: var(--border);
}

.super-zen-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.super-zen-play {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  flex-shrink: 0;
}

.super-zen-play svg {
  width: 24px;
  height: 24px;
}

.super-zen-play:hover {
  filter: brightness(1.1);
}

.super-zen-progress {
  font-size: 14px;
  font-weight: 600;
  color: var(--muted);
  padding: 8px 16px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
}

/* Bouton Flip en mode Super Zen (si besoin) */
.read-page.super-zen .read-flip-btn {
    bottom: 100px; /* Remonter au-dessus des contrôles super-zen */
}


/* ================================================= */
/* ============= CONTROLES SWIPE MOBILE ============ */
/* ================================================= */

/* Conteneur principal du swiper (mobile) */
.read-controls-inner {
  display: none; /* Caché par défaut, activé sur mobile */
}

/* Indicateurs de points (mobile) */
.read-controls-dots {
  display: none; /* Caché par défaut, activé sur mobile */
}

/* Styles pour la jauge de difficulté sur mobile (dans le swiper) */
#rc-difficulty-gauge.difficulty-gauge {
    /* Sur mobile, on cache la barre/label et on pousse le texte à droite */
    background: none;
    border: none;
    padding: 0;
    margin-left: auto; /* Pousse vers la droite sur le panel 1 */
}
#rc-difficulty-gauge .difficulty-label,
#rc-difficulty-gauge .difficulty-bar {
    display: none; /* Cacher la barre et le label */
}
#rc-difficulty-gauge #readDifficultyText {
    /* Style du texte (chip) */
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 13px; /* font-weight: 700; /* height: auto;
    max-height: 28px; /* Légèrement augmenté pour la nouvelle taille */
    box-sizing: border-box;
    display: flex; /* Ajouter flex pour centrer verticalement si besoin */
    align-items: center; /* Centrer verticalement */
}

/* ================================================= */
/* ========= BOUTONS CACHER/AFFICHER MENU ========== */
/* ================================================= */

/* Ceci est la bonne définition (corrigée) */
.controls-toggle-btn {
  position: fixed;
  top: 15px;
  right: 15px;
  width: 40px;
  height: 40px;
  background: transparent; /* CORRIGÉ: Fond supprimé */
  border: none; /* CORRIGÉ: Bordure supprimée */
  color: var(--fg);
  border-radius: 10px;
  cursor: pointer;
  z-index: 10001; /* Au-dessus de tout le reste (corrigé) */
  transition: background 0.2s, color 0.2s, opacity 0.3s, transform 0.3s;
  opacity: 0.8;
  display: flex;
  align-items: center;
  justify-content: center;
}

.controls-toggle-btn:hover {
  background: transparent; /* CORRIGÉ: Fond au survol supprimé */
  color: var(--accent); /* CORRIGÉ: Changement de couleur au survol */
  opacity: 1;
}

/* Style quand les contrôles sont cachés */
.read-page.controls-hidden .read-controls {
  transform: translateY(-100%);
  box-shadow: none; /* Cacher l'ombre quand c'est hors écran */
  transition: transform 0.3s ease-out;
}

.read-page.controls-hidden #hideControlsBtn {
   opacity: 0; /* Cacher le bouton "hide" quand caché */
   pointer-events: none;
}

.read-page.controls-hidden #showControlsBtn {
  display: flex !important; /* Afficher le bouton "show" */
  opacity: 0.8;
  transform: translateY(0);
}
.read-page:not(.controls-hidden) #showControlsBtn {
   opacity: 0; /* Cacher le bouton "show" quand visible */
   transform: translateY(-20px);
   pointer-events: none;
}

/* Ajuster la position du contenu quand les contrôles sont cachés */
.read-page.controls-hidden .read-content {
  top: 15px !important; /* Ajuster si besoin pour laisser de l'espace au bouton show */
  transition: top 0.3s ease-out;
}
.read-page .read-content {
    transition: top 0.3s ease-out; /* Ajouter transition pour le retour */
}


/* ================================================= */
/* ========== MEDIA QUERY (RESPONSIVE) ============= */
/* ================================================= */

/* Tablette (Point où le wrap commence mais SANS swiper) */
/* Styles appliqués entre 901px et 1100px */
@media (min-width: 901px) and (max-width: 1100px) {
    .read-controls {
        flex-wrap: wrap; /* Permet le retour à la ligne */
        padding: 10px 12px;
        min-height: auto;
        justify-content: flex-start;
        gap: 8px; /* Espacement réduit */
    }

/* 1. Inverser l'ordre visuel (Mots en haut, Phrase en bas) */
#reorder-drag-mode {
  flex-direction: column-reverse;
}

/* 2. Annuler les styles 'sticky' de la zone de phrase */
#reorder-drop-section {
  position: relative; /* Annule sticky */
  z-index: auto;
  background: transparent;
  padding: 0;
  box-shadow: none;
  border-bottom: none;
  border-radius: 0;
  margin-top: 0;
  flex-shrink: 1; /* Rétablit la normale */
}

#reorder-drop-section .game-section-title {
  padding-top: 0;
}

/* 3. Annuler l'expansion de la zone des mots disponibles */
#reorder-available-section {
  flex: none; /* Annule flex: 1 */
  overflow: visible; /* Annule hidden */
  margin-bottom: 20px; /* Rétablit la marge V21 */
}

/* 4. Annuler le scroll interne de la zone de mots */
#availableWords {
  flex: none; /* Annule flex: 1 */
  overflow-y: visible; /* Annule auto */
  align-items: center; /* Centre les mots (Style V21) */
  align-content: center; /* Centre les mots (Style V21) */
}


/* Cacher les barres de scroll (si elles étaient définies) */
#availableWords::-webkit-scrollbar {
  display: none;
}


    /* === PRÉSERVATION LAYOUT TABLETTE === */
    .read-controls-inner,
    .read-panel {
      display: contents; /* Aplatir la structure */
    }
    .read-controls-dots {
      display: none; /* Cacher les dots */
    }
    .controls-toggle-btn {
      display: none !important; /* Cacher boutons hide/show */
    }
    /* === FIN === */

    /* Positionnement Barre Progression */
    .read-progress {
        order: 99;
        flex-basis: 100%;
        min-width: 0;
        margin: 8px 0 4px 0;
        display: block !important;
    }

    /* Positionnement Filtres/Jauge/Focus */
    .read-filter-legend {
        order: 10;
        flex-basis: auto;
        justify-content: flex-start;
        margin-top: 8px;
        margin-right: 10px;
        align-items: center;
    }
     /* Jauge sur tablette */
     #rc-difficulty-gauge.difficulty-gauge {
         order: 11;
         margin-top: 8px;
         margin-left: auto;
         flex-shrink: 0;
         /* Styles visuels de la jauge (identiques au desktop) */
         display: flex !important;
         flex-direction: column;
         gap: 4px;
         padding: 8px 12px;
         background: var(--card);
         border: 1px solid var(--border);
         border-radius: 10px;
     }
     /* Afficher label et barre */
     #rc-difficulty-gauge .difficulty-label,
     #rc-difficulty-gauge .difficulty-bar {
         display: block;
     }
     /* Style du texte DANS la jauge */
     #rc-difficulty-gauge #readDifficultyText {
         font-size: 12px; font-weight: 700; color: var(--fg) !important;
         padding: 0; border-radius: 0; height: auto; max-height: none;
         background-color: transparent; border: none; line-height: initial;
         margin: 0; order: initial;
     }

     .read-legend-focus {
         order: 12; margin-left: 8px; margin-top: 8px; align-items: center;
     }
     .read-filter-legend span { display: inline; } /* Afficher "FILTRES:" */

}

/* Mobile (Activation du Swiper) - Styles pour max-width: 900px */
@media (max-width: 900px) {

  /* === BASE POUR MOBILE === */
  .read-controls {
    position: relative; /* Pour positionner #hideControlsBtn */
    padding: 0 0 8px 0;
    gap: 0;
    justify-content: center;
    flex-wrap: wrap;
    min-height: auto;
    transition: transform 0.3s ease-out; /* Pour animation hide/show */
  }

  .game-container .stats-grid {
    display: none !important; /* Force le masquage */
  }

 
  .typing-target-text
   {
    font-size: 28px;
  }
  
  .blanks-display-text {
    font-size: 32px;
  }
  
  .translation-hint { 
    font-size: 16px !important;
  }

  #hideControlsBtn {
    position: absolute;
    right: 12px;
    bottom: 8px;

    width: 36px;
    height: 36px;

    background: transparent;
    border: none;
    color: var(--fg);
    opacity: 0.8;

    display: flex;
    align-items: center;
    justify-content: center;

    /* on annule ce qu'on avait ajouté avant */
    margin-left: 0;
    order: initial;
    top: auto;
    z-index: 10; /* passe au-dessus des dots si besoin */
  }
  
  /* === CORRECTION BANDEAU RÉSULTAT MOBILE === */
  
  .game-result {
    /* 1. Annule la position fixe */
    position: relative; 
    
    /* 2. Annule les styles de positionnement */
    top: auto;
    left: auto;
    /* La transformation est gérée ci-dessous */

    /* 3. Largeur automatique */
    width: auto; 
    
    /* 4. Marge supérieure */
    margin-top: 10px;
    
    /* 5. Bords arrondis */
    border-radius: 14px;
    
    /* 6. CORRECTION ERREUR SYNTAXE (10x -> 12px) */
    margin-bottom: 12px;
    
    /* 7. Assure l'affichage */
    display: block; 
  }
  
  /* Règle plus spécifique pour 'SUCCESS' */
  #gamePage .game-result.success {
    /* Couleur verte avec 90% d'opacité */
    background: #22c55ee6;
    
    /* (Optionnel) Effet verre dépoli pour un look moderne */
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
  }

  /* Règle plus spécifique pour 'ERROR' */
  #gamePage .game-result.error {
    /* Couleur rouge avec 90% d'opacité */
    background: #ef4444e6; 
    
    /* (Optionnel) Effet verre dépoli pour un look moderne */
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
  }
  
  /* RÈGLE FUSIONNÉE POUR 'SUCCESS' */
  .game-result.success {
    /* Annule la transformation (venait de la règle supprimée) */
    transform: none !important;
    
    /* Couleur verte avec 90% d'opacité */
    background: #22c55ee6;
    
    /* (Optionnel) Effet verre dépoli */
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
  }

  /* RÈGLE FUSIONNÉE POUR 'ERROR' */
  .game-result.error {
    /* Annule la transformation (venait de la règle supprimée) */
    transform: none !important;
    
    /* Couleur rouge avec 90% d'opacité */
    background: #ef4444e6; 
    
    /* (Optionnel) Effet verre dépoli */
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
  }
  
  /* ======================================================== */
  /* == MODIFICATION : Hauteur adaptative Réorganiser (Mobile) == */
  /* ======================================================== */
  
  /* Le conteneur principal du mode réorganiser */
  #reorder-drag-mode {
    flex: 0 1 auto; /* S'adapte au contenu au lieu de forcer l'expansion */
    display: flex;
    flex-direction: column;
    gap: 20px; /* Réduit l'espace entre les sections sur mobile */
    overflow: visible;
  }
  
  /* Cible la section "Mots disponibles" UNIQUEMENT sur mobile */
  #reorder-available-section {
    flex: 0 1 auto; /* Permet l'adaptation au contenu au lieu de forcer l'expansion */
    overflow: visible; /* Permet à la section de montrer son contenu naturellement */
    margin-bottom: 0;
    display: flex;
    flex-direction: column;
  }

  #availableWords {
    /* on laisse le JS fixer max-height dynamiquement -> pas de max-height ici */
    overflow-y: auto;
    overflow-x: hidden;
    overscroll-behavior: contain; /* évite le scroll d'arrière-plan */
    touch-action: pan-y;          /* balayage vertical autorisé depuis l'espace vide */
    -webkit-overflow-scrolling: touch; /* inertie iOS/Android */
  }
  
    #availableWords::before {
    content: "";
    display: block;
    height: 6px;   /* petit espace fixe tout en haut */
    flex: 0 0 auto;
	}
  
  #reorder-drag-mode { 
    overflow: visible; 
	align-items: center;
    align-content: center; 
    justify-content: center; 
	padding-left: 12px
    padding-right: 12px
  }
  

  /* Contenu quand caché */
   .read-page.active .read-content { top: 100px; /* Espace initial */ }
   .read-page.controls-hidden .read-content { top: 15px !important; }

  /* === ACTIVATION SWIPER === */
  .read-controls-inner {
    display: flex !important; /* Override 'contents' */
    flex-basis: 100%; order: 1;
    overflow-x: auto; scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch; scrollbar-width: none;
  }
  .read-controls-inner::-webkit-scrollbar { display: none; }

  /* Les 3 panneaux */
  .read-panel {
    display: flex !important; /* Override 'contents' */
    flex-wrap: wrap; gap: 6px; align-items: center;
    flex: 0 0 100%; scroll-snap-align: start; scroll-snap-stop: always;
    padding: 8px 12px; box-sizing: border-box; min-height: 40px;
  }

  /* Panneau 1: Boutons + Chip Difficulté */
  #rc-panel-1 {
      justify-content: space-evenly; /* Espacement équitable */
      padding-left: 12px;
      padding-right: 12px; /* Rendu symétrique */
      position: relative; /* Contexte pour bouton hide */
  }
  /* Panneau 2: Filtres */
  #rc-panel-2 { justify-content: center; }
  /* Panneau 3: Police */
  #rc-panel-3 { justify-content: center; }

  /* Les Dots */
  .read-controls-dots {
    display: flex !important; /* Override 'none' */
    justify-content: center; gap: 8px; flex-basis: 100%;
    order: 2; margin-top: 6px;
  }
  .read-controls-dots .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border); transition: background 0.2s; }
  .read-controls-dots .dot.active { background: var(--accent); }
  /* === FIN SWIPER === */


  /* Styles des contrôles réduits */
  .read-close { width: 36px; height: 36px; }
  .read-play-pause { width: 40px; height: 40px; }
  .read-mode-toggle, .read-zen-toggle { padding: 8px 12px; font-size: 12px; }
  .read-font-btn {
    width: 36px; /* Augmenté de 32px */
    height: 36px; /* Augmenté de 32px */
    font-size: 14px; /* Augmenté de 12px */
  }
  .read-font-size {
    font-size: 12px; /* Augmenté de 11px */
    min-width: 45px; /* Augmenté de 40px */
    /* Ajout pour centrer verticalement */
    height: 36px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  /* Style de la JAUGE (#rc-difficulty-gauge) sur MOBILE (devient un chip) */
  #rc-difficulty-gauge.difficulty-gauge {
    padding: 4px 10px; border-radius: 12px; border: 2px solid var(--border);
    background-color: transparent; display: inline-flex !important;
    align-items: center; height: 28px; box-sizing: border-box;
    flex-shrink: 0; margin: 0; order: initial; flex-direction: row; gap: 0;
  }
  /* Cacher label et barre */
   #rc-difficulty-gauge .difficulty-label,
   #rc-difficulty-gauge .difficulty-bar { display: none !important; }
  /* Style du texte DANS le chip */
   #rc-difficulty-gauge .difficulty-text,
   #readDifficultyText {
    font-size: 13px; font-weight: 700; color: var(--fg); line-height: 1;
    margin: 0; order: initial; padding: 0; border-radius: 0;
    height: auto; max-height: none; background-color: transparent; border: none;
   }

  /* Filtres DANS le panel 2 */
  .read-filter-legend { flex-basis: 100%; justify-content: center; margin: 0; order: initial; }
  .read-filter-legend > span { display: none !important; } /* Cacher "FILTRES:" */
  .read-legend-chip { padding: 4px 8px; font-size: 10px; }

  /* Bouton Focus */
  .read-legend-focus {
       padding: 4px 10px; border-radius: 12px; font-size: 10px; font-weight: 600;
       line-height: 1.4; border: 2px solid #ffffff !important; color: #ffffff !important;
       background: transparent; height: auto; max-height: 26px; box-sizing: border-box;
       display: inline-flex; align-items: center; justify-content: center;
       margin: 0; order: initial;
  }
   .read-legend-focus span { display: inline !important; }
   .read-legend-focus.active { background: #ffffff !important; color: var(--bg) !important; }
   .read-legend-focus:disabled {
      opacity: 0.4; filter: grayscale(80%); pointer-events: none;
      border-color: var(--muted) !important; color: var(--muted) !important;
      background: transparent !important;
   }

  /* Cacher la barre de progression */
  .read-progress { display: none !important; }

  /* Autres styles mobile (contenu, flip, super zen) (INCHANGÉS) */
  .read-content { padding: 20px; }
  .read-text-container.has-flip { flex-direction: column; gap: 0; }
  .flip-front, .flip-back { padding: 12px}
  .flip-container {
  min-height: 1px; /* Au moins 1px pour le contexte */
}
  .read-text-container:not(.has-flip) { flex-direction: column; }
  .read-text-container:not(.has-flip) .read-text,
  .read-text-container:not(.has-flip) .read-translation { flex: none; width: 100%; padding: 12px; min-height: 300px; }
  .read-page.super-zen .read-content { padding: 30px 20px 50px 20px; bottom: 80px}
  .read-page.super-zen .read-text { font-size: 36px; }
  .read-page.super-zen .read-translation { font-size: 18px; }
  .super-zen-controls { padding: 12px 8px; gap: 8px; height: 80px;}
  .super-zen-btn { padding: 8px 12px; font-size: 12px; }
  .super-zen-play { width: 44px; height: 44px; }
  .read-text-container.has-flip .flip-front,
  .read-text-container.has-flip .flip-back {
      display: block !important;
  }
  
  }

/* Très petits écrans */
@media (max-width: 600px) {
    /* Styles Accueil et Jeu (INCHANGÉS) */
    .container { padding: 16px; padding-bottom: 100px; }

.typing-target-text.shrink-text {
      font-size: 28px !important;
    }


.blanks-display-text.shrink-text {
      font-size: 32px !important;
    }
	
	.translation-hint.shrink-text { 
    font-size: 16px !important;
  }

    .shrink-text { font-size: 18px !important; line-height: 1.6 !important; }

    .shrink-text { font-size: 18px !important; line-height: 1.6 !important; }

    /* Styles Mode Lecture Mobile */
     .read-controls { min-height: auto; }
     .read-page.active .read-content { top: 110px; }

    .read-page.super-zen .read-text { font-size: 28px; }
    .read-page.super-zen .read-translation { font-size: 16px; }
	.game-container .stats-grid {
    display: none;
  }
}

/* Écrans minuscules */
@media (max-width: 420px) {
     .read-page.active .read-content { top: 120px; }
     #rc-panel-2 .read-filter-legend { justify-content: flex-start; } /* Aligner filtres à gauche */
}

/* --- Couleur Texte Jauge/Chip sur Thèmes Clairs --- */
[data-theme="light"] #readDifficultyText,
[data-theme="paper"] #readDifficultyText {
    /* La couleur est gérée par JS pour le chip mobile */
    /* La couleur desktop est forcée à var(--fg) ci-dessous */
}
/* Forcer la couleur du texte de la jauge desktop */
@media (min-width: 901px) {
    [data-theme="light"] #rc-difficulty-gauge #readDifficultyText,
    [data-theme="paper"] #rc-difficulty-gauge #readDifficultyText {
        color: var(--fg) !important;
    }
}

/* --- Autres styles --- */
/* Focus désactivé en mode Frappe */
#readFocusToggle:disabled {
  opacity: 0.5; cursor: not-allowed; filter: grayscale(50%); pointer-events: none;
}
/* (La règle @media pour :disabled est redondante mais inoffensive) */


/* ================================================= */
/* ==== RESTAURATION AFFICHAGE DESKTOP (>900px) ==== */
/* ================================================= */
@media (min-width: 901px) {

  /* 1. Rétablir le comportement de base de .read-controls */
  .read-controls {
    /* Styles pour la barre de contrôle PC */
    position: fixed; top: 0; left: 0; right: 0;
    flex-wrap: nowrap; /* EMPÊCHE le retour à la ligne */
    padding: 12px 16px; /* Padding desktop */
    min-height: 70px; /* Hauteur min desktop */
    justify-content: flex-start; /* Aligne au début */
    gap: 10px; /* Espacement desktop */
    transform: translateY(0); /* Assure position initiale */
    /* Styles visuels et positionnement */
    background: var(--panel); border-bottom: 1px solid var(--border);
    box-shadow: var(--shadow); z-index: 10000;
    overflow-x: hidden; /* Cache le débordement horizontal */
    display: flex; /* Assure flex */
    align-items: center; /* Alignement vertical */
  }

  /* --- Rétablir le layout côte à côte du contenu --- */
  .read-content {
    display: flex;
    flex-direction: row; /* Force Côte à côte */
    align-items: flex-start; /* Aligne en haut */
    justify-content: center; /* Centre le conteneur global */
    padding: 40px; /* Padding desktop */
    position: absolute; /* Positionnement sous la barre fixe */
    top: 70px; /* Hauteur de .read-controls */
    left: 0; right: 0; bottom: 0;
    overflow-y: auto; /* Scroll vertical global si besoin */
  }

  /* Cible TOUTES les variations de .read-text-container sur desktop */
  .read-text-container,
  .read-text-container.has-flip,
  .read-text-container:not(.has-flip) {
     display: flex; /* Assure flex */
     flex-direction: row;
     width: 100%;
     max-width: 1400px;
     gap: 40px; /* Espace entre les colonnes */
     align-items: flex-start; /* Aligne en haut */
     /* Annuler min-height mobile si besoin */
     min-height: auto;
  }


   .read-text-container > .read-text,
   .read-text-container > .read-translation,
   .read-text-container.has-flip .read-text, /* Spécificité pour flip */
   .read-text-container.has-flip .read-translation,
   .read-text-container:not(.has-flip) .read-text, /* Spécificité pour not-flip */
   .read-text-container:not(.has-flip) .read-translation {
      flex: 1;
      width: auto;
      min-width: 0; /* Permet de rétrécir */
      padding: 30px; /* Padding interne */
      margin-bottom: 0;
      /* Styles visuels */
      background: var(--card); border: 1px solid var(--border);
      box-shadow: var(--shadow); border-radius: 16px;
      /* Annuler min-height mobile et gérer scroll */
      min-height: auto;
      overflow-y: visible; /* Laisse .read-content gérer le scroll */
      height: auto; /* Hauteur naturelle */
   }

   .read-text-container > .read-translation,
   .read-text-container.has-flip .read-translation,
   .read-text-container:not(.has-flip) .read-translation {
       background: var(--panel); display: block;
       font-size: 0.9em; line-height: 1.8; color: var(--muted); font-style: italic;
   }

   /* Neutraliser Flip structure UNIQUEMENT si elle existe */
   .read-text-container.has-flip .flip-container,
   .read-text-container.has-flip .flip-inner,
   .read-text-container.has-flip .flip-front,
   .read-text-container.has-flip .flip-back {
       display: contents; /* Dissout la structure */
       position: relative; transform: none; backface-visibility: visible;
       width: auto; min-height: auto; /* Annuler min-height flip */
       height: auto; padding: 0; /* Annuler padding flip */
       border: none; box-shadow: none; /* Annuler styles flip */
   }


  /* 2. Faire disparaître la structure du swiper visuellement */
  .read-controls-inner,
  .read-panel {
    display: contents; /* Aplatir */
    padding: 0; min-height: auto;
    overflow: visible; flex-basis: auto; order: initial; /* Annuler styles swiper */
  }

  /* 3. Cacher les dots */
  .read-controls-dots { display: none !important; }

  /* 4. Rétablir la barre de progression */
  .read-progress {
    display: block !important;
    flex: 1 1 auto;
    order: initial; flex-basis: auto; margin: 0 10px;
    min-width: 150px; height: 8px; cursor: pointer; /* Styles visuels */
  }

  /* 5. Rétablir l'apparence COMPLÈTE de la jauge de difficulté */
  #rc-difficulty-gauge.difficulty-gauge {
      display: flex !important; flex-direction: column; gap: 4px; padding: 8px 12px;
      background: var(--card); border: 1px solid var(--border); border-radius: 10px;
      flex-shrink: 0; height: auto; max-height: none; margin-left: auto;
      order: initial; margin-top: 0; border-color: var(--border);
      align-items: initial; /* Annuler alignement chip mobile */
      box-sizing: content-box; /* Annuler box-sizing chip mobile */
  }
  #rc-difficulty-gauge .difficulty-label,
  #rc-difficulty-gauge .difficulty-bar { display: block !important; }
  #rc-difficulty-gauge #readDifficultyText {
      padding: 0; font-size: 12px; font-weight: 700; color: var(--fg) !important;
      height: auto; max-height: none; border-radius: 0; background-color: transparent;
      order: initial; margin-left: 0; margin-top: 0; line-height: initial; border: none;
  }

  /* 6. Rétablir le layout des filtres et du bouton focus */
  .read-filter-legend {
      display: flex; /* Assurer flex */
      order: initial; flex-basis: auto; justify-content: flex-start;
      margin-top: 0; margin-right: 10px; flex-wrap: nowrap;
      gap: 6px; align-items: center; min-width: 0;
  }
   .read-filter-legend > span { display: inline !important; }
   .read-legend-focus {
      display: flex; order: initial; margin-left: 10px; margin-top: 0;
      padding: 5px 10px; border-radius: 12px; font-size: 10px;
      border: 2px solid #ffffff !important; color: #ffffff !important; background: transparent;
      height: auto; line-height: initial; box-sizing: content-box; align-items: center;
      justify-content: center; gap: 6px; flex-shrink: 0; white-space: nowrap;
      max-height: none; /* Annuler max-height mobile */
   }
   .read-legend-focus span { display: inline !important; }
   .read-legend-focus.active { background: #ffffff !important; color: var(--bg) !important; }
   .read-legend-focus:disabled {
     opacity: 0.5; filter: grayscale(50%); pointer-events: none;
     border-color: #ffffff !important; color: #ffffff !important; background: transparent !important;
     /* Annuler styles disabled mobile si différents */
   }

  /* 7. Rétablir la taille des contrôles */
  .read-close { width: 44px; height: 44px; }
  .read-play-pause { width: 48px; height: 48px; }
  .read-mode-toggle, .read-zen-toggle { padding: 10px 16px; font-size: 14px; }
  .read-font-btn { width: 36px; height: 36px; font-size: 14px; }
  .read-font-size { font-size: 12px; min-width: 45px; height: 36px; display: inline-flex; align-items: center; justify-content: center; }
  .read-legend-chip { padding: 6px 12px; font-size: 11px; }

  /* 8. Cacher les boutons hide/show sur Desktop */
  .controls-toggle-btn { display: none !important; }

  /* 9. Cacher le bouton Flip */
  .read-flip-btn { display: none !important; }
  
  /* ================================================= */
  /* ===== CENTRAGE BANDEAU VALIDATION (PC) ======== */
  /* ================================================= */

  .game-result {
      /* Annuler le positionnement en haut */
      top: 75%;
      left: 50%;
      width: auto; /* Passer de 100% à auto */

      /* Styliser en "modal" */
      border-radius: 14px;

      /* Nouvelle animation (centrée + fondu) */
      transform: translate(-50%, -50%) translateY(-30px);
      opacity: 0;
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
      pointer-events: none;
  }

  .game-result.success,
  .game-result.error {
      /* Nouvel état "affiché" pour l'animation */
      transform: translate(-50%, -50%) translateY(0);
      opacity: 1;
  }

}

/* 🔁 FORCE STYLE TEXTE NU EN SUPER ZEN */
.read-page.super-zen .read-text,
.read-page.super-zen .read-translation,
.read-page.super-zen .flip-front.read-text,
.read-page.super-zen .flip-back.read-translation {
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
  border-radius: 0 !important;
  width: auto !important;
  min-width: 0 !important;
  flex: none !important;
  text-align: center !important;
  height: auto !important;
  min-height: auto !important;
}

/* Taille et line-height spécifiques Super Zen */
.read-page.super-zen .read-text,
.read-page.super-zen .flip-front.read-text {
  font-size: 36px;
  line-height: 1.5 !important;
  font-family: 'Noto Sans SC', sans-serif !important;
}

.read-page.super-zen .read-translation,
.read-page.super-zen .flip-back.read-translation {
  font-size: 18px;
  line-height: 1.6 !important;
  font-style: italic !important;
  color: var(--muted) !important;
  font-family: 'Inter', sans-serif !important;
}

/* Empile bien chinois puis trad */
.read-page.super-zen #readTextContainer,
.read-page.super-zen .read-text-container,
.read-page.super-zen .flip-container,
.read-page.super-zen .flip-inner {
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 8px !important;
  max-width: 90% !important;
  margin: 0 auto !important;
}

/* Le conteneur global prend l'écran sans carte derrière */
.read-page.super-zen .read-content {
  background: transparent !important;
  box-shadow: none !important;
  border: none !important;
  
}


/* ================================================= */
/* == CORRECTION ESPACEMENT SUPER ZEN (V2 - Bon Sélecteur) == */
/* ================================================= */

/*
  * EXPLICATION :
  * Le JS applique 'visibility: hidden'. Ce CSS le transforme en 'display: none'
  * UNIQUEMENT en mode Super Zen, en ciblant la classe '.read-char'.
*/

/* 1. Par défaut, en Super Zen, les spans sont 'inline' */
.read-page.super-zen .read-char {
    display: inline;
}

/* 2. SI le JS cache un span (style="visibility: hidden;")... */
.read-page.super-zen .read-char[style*="visibility: hidden"] {
    /* ... ALORS on le force à 'display: none' pour qu'il ne prenne pas de place */
    display: none !important;
}

/* 3. SI le JS affiche un span (style="visibility: visible;")... */
.read-page.super-zen .read-char[style*="visibility: visible"] {
     /* ... ALORS on s'assure qu'il est 'inline' */
    display: inline !important;
}

/* ================================================= */
/* ============ CORRECTION TAP MOBILE ============== */
/* ================================================= */

/* 1. Désactive le "voyant bleu" natif sur les caractères */
.read-char {
  -webkit-tap-highlight-color: transparent; /* Désactive le surlignage natif iOS/Android */
}

/* 2. Définit notre propre classe de surlignage temporaire */
.char-tapped {
    background-color: rgba(122, 162, 255, 0.3); /* Utilise la couleur --accent (bleu) en semi-transparent */
    border-radius: 3px;
    transition: background-color 0.4s ease; /* Permet un fondu de sortie */
}

/* ================================================= */
/* ==== AJUSTEMENT HAUTEUR MODE RÉORGANISER ===== */
/* ================================================= */


/* Cible la section "Mots disponibles" que nous avons identifiée */
#reorder-available-section {
display: flex;
flex-direction: column;
  margin-bottom: 0; /* Supprime la marge du bas */
  margin-bottom: 12px; 
}

/* S'assure que le titre ne rétrécit pas */
#reorder-available-section > .game-section-title {
  padding-bottom: 8px;
}

/* Fait en sorte que la zone des mots elle-même
   remplisse tout l'espace de sa section */
#availableWords {
min-height: 100px;
  padding: 20px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 14px;
  box-sizing: border-box;   /* le padding compte dans la hauteur max */
  padding-top: 12px;        /* espace en haut pour la 1ère ligne */
  scroll-padding-top: 10px; /* si tu fais scrollIntoView/focus, ça garde 10px au-dessus */
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center; /* Aligne en haut */
  align-content: center; /* Contenu aligné en haut */
  justify-content: center;
  align-items: flex-start; 
  align-content: flex-start;
  /* Styles de scrollbar pour webkit (Chrome, Safari) */
    scrollbar-width: thin;
  scrollbar-color: var(--accent) var(--border);
}

#availableWords::-webkit-scrollbar {
  width: 8px;
}

#availableWords::-webkit-scrollbar-track {
  background: var(--border);
  border-radius: 4px;
}

#availableWords::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 4px;
}

#availableWords::-webkit-scrollbar-thumb:hover {
  background: var(--accent);
  filter: brightness(1.2);
}

.game-result .result-icon {
  width: 20px;
  height: 20px;
  stroke-width: 2.5;
  margin-right: 10px;
  vertical-align: middle;
  position: relative;
  top: -2px; /* Ajustement fin pour l'alignement vertical */
}


</style>
</head>
<body data-theme="dark">

<div id="homePage" class="container">
  <div class="home-header">
  </div>

  <div class="mode-toggle-container">
    <button id="modeReadBtn" class="mode-toggle-btn active">
      <svg class="mode-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
      </svg>
      <span>Mode Lecture</span>
    </button>
    <button id="modeGameBtn" class="mode-toggle-btn">
      <svg class="mode-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
      </svg>
      <span>Mode Jeu</span>
    </button>
  </div>

  <div class="tabs-container">
    <div class="tabs-nav">
      <button id="tab1Btn" class="tab-btn active">
        <span class="tab-number">1</span>
        <span>Texte & Dictionnaires</span>
      </button>
      <button id="tab2Btn" class="tab-btn">
        <span class="tab-number">2</span>
        <span>Options</span>
      </button>
    </div>

    <div id="tab1" class="tab-content active">
      <div class="card">
        <h2 class="section-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px; vertical-align: middle; margin-top: -2px;">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10 9 9 9 8 9"></polyline>
          </svg>
          Votre texte
		  <div style="margin-left: auto; font-size: 12px; display: flex; gap: 10px;">
        <span id="dictStatus" class="status-chip" style="padding: 2px 8px; font-weight: 500;">Dico...</span>
        <span id="hskStatus" class="status-chip" style="padding: 2px 8px; font-weight: 500;">HSK...</span>
    </div>
        </h2>
        <div class="input-group">
          <label>Texte chinois</label>
          <textarea id="inputZh" placeholder="Collez votre texte chinois ici...">城市的夜晚，总有一种说不出的寂静。街灯亮着，却照不进每个人的心。刘哲坐在办公室里，盯着电脑屏幕上那份还没完成的报告。窗外的霓虹在闪烁，像是无声地提醒他：又是一个加班的夜晚。他已经记不清上一次和家人吃晚饭是什么时候了。妻子发来的信息停留在手机屏幕上：“别太晚回来。”简单的五个字，却让他心里一阵酸涩。同事们一个个离开，只剩下空调的嗡嗡声和键盘的敲击声。刘哲忽然意识到，自己忙碌了这么多年，好像一直在追赶什么，却从未真正停下来想一想。他关掉电脑，走到窗边，看着远处的高楼。那些灯光看似明亮，其实和他一样，都在深夜里努力坚持着。 “也许生活不该只是工作”他轻声对自己说。那一刻，他决定明天早点回家，陪妻子一起吃一顿热乎的晚饭</textarea>
        </div>
        <div class="input-group">
          <label>Traduction française (optionnelle)</label>
          <textarea id="inputTr" placeholder="Collez la traduction ici...">La nuit de la ville a always une forme de silence difficile à décrire.
Les lampadaires brillent, mais n’éclairent pas le cœur de chacun.
Liu Zhe est assis dans son bureau, fixant le rapport inachevé sur l’écran de son ordinateur.
Les néons dehors clignotent, comme s’ils lui rappelaient en silence : encore une soirée de travail tardive.

Il ne se souvient plus de la dernière fois qu’il a dîné avec sa famille.
Le message envoyé par sa femme reste affiché sur son téléphone : « Ne rentre pas trop tard. »
Ces cinq mots simples lui serrent pourtant le cœur.

Ses collègues sont partis les uns après les autres, ne laissant que le bourdonnement de la climatisation et le claquement du clavier.
Liu Zhe réalise soudain qu’il a été occupé pendant tant d’années, courant après quelque chose, sans jamais vraiment s’arrêter pour réfléchir.

Il éteint l’ordinateur, s’avance vers la fenêtre et regarde les gratte-ciel au loin.
Ces lumières paraissent brillantes, mais en réalité, comme lui, elles continuent à lutter dans la nuit.

« Peut-être que la vie ne devrait pas se limiter au travail », murmure-t-il pour lui-même.
À cet instant, il décide que demain, il rentrera plus tôt pour dîner chaud avec sa femme.</textarea>
        </div>
        <div id="sentencesPreview" class="status-chip clickable"></div> </div>

      <div class="card">
        <h2 class="section-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px; vertical-align: middle; margin-top: -2px;">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <circle cx="8.5" cy="8.5" r="1.5"></circle>
            <polyline points="21 15 16 10 5 21"></polyline>
          </svg>
          Thème
        </h2>
        <div class="input-group">
          <label>Thème de couleur</label>
          <div class="theme-switcher">
            <button class="theme-btn theme-dark active" data-theme="dark"></button>
            <button class="theme-btn theme-light" data-theme="light"></button>
            <button class="theme-btn theme-paper" data-theme="paper"></button>
          </div>
        </div>
      </div>

      <div class="card" style="display: none;"> <h2 class="section-title">
        <h2 class="section-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px; vertical-align: middle; margin-top: -2px;">
            <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
            <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
          </svg>
          Dictionnaires
        </h2>
        <div class="input-group">
          <label>Dictionnaire CC-CEDICT (.txt ou .u8)</label>
          <input type="file" id="dictFile" accept=".txt,.u8" />
          <span id="dictStatus" class="status-chip">Aucun dictionnaire chargé</span>
        </div>
        <div class="input-group">
          <label>Liste HSK/Fréquence (CSV: mot,level)</label>
          <input type="file" id="hskFile" accept=".csv" />
          <span id="hskStatus" class="status-chip">Aucune liste importée</span>
        </div>
      </div>
    </div>

    <div id="tab2" class="tab-content">
      <div id="gameOptions" style="display:none;">
        <div class="card">
          <h2 class="section-title">🎮 Options du mode jeu</h2>
          <div class="input-group">
  <label>Mode de jeu</label>
  <div class="game-mode-grid" id="gameModeSelector">
    <button class="game-mode-btn active" data-mode="reorder-drag" title="Réorganiser les mots (Drag & Drop)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 18l-4-4-4 4M8 6l4 4 4-4"/></svg>
      <span>Réorganiser</span>
    </button>
    <button class="game-mode-btn" data-mode="free-input" title="Saisie libre (Vérification)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
      <span>Saisie libre</span>
    </button>
    <button class="game-mode-btn" data-mode="live-typing" title="Frappe en direct (Validation live)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="12" width="18" height="8" rx="2" ry="2" /><path d="M7 12V7a5 5 0 0 1 10 0v5" /></svg>
      <span>Frappe Live</span>
    </button>
    <button class="game-mode-btn" data-mode="time-attack" title="Frappe en direct (Time Attack)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
      <span>Time Attack</span>
    </button>
    <button class="game-mode-btn" data-mode="fill-blanks-char" title="Phrases à trous (Caractères)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
      <span>Trous (Mots)</span>
    </button>
    <button class="game-mode-btn" data-mode="fill-blanks-pinyin" title="Phrases à trous (Pinyin)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 10h3M3 14h3M3 6h3m14 4h-3m3 4h-3m3-8h-3m-4 8v-2.5a1.5 1.5 0 0 1 3 0V18M10 18v-2.5a1.5 1.5 0 0 1 3 0V18"/></svg>
      <span>Trous (Pinyin)</span>
    </button>
  </div>
  <input type="hidden" id="gameMode" value="reorder-drag">
</div>
          <div class="checkbox-container" id="showTranslationCheckContainer">
            <input type="checkbox" id="showTranslationCheck" checked />
            <label for="showTranslationCheck">Afficher la traduction pendant le jeu</label>
          </div>

        </div> <div id="gameModeOptionsContainer">

          <div id="pinyinInputTypeOptions" class="card game-mode-option" style="display:none;">
            <h2 class="section-title">⌨️ Type de Saisie (Pinyin)</h2>
            <div class="input-group">
              <div class="pinyin-input-type-selector">
                <button class="pinyin-input-type-btn active" data-type="keyboard">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="12" width="18" height="8" rx="2" ry="2"></rect><path d="M7 12V7a5 5 0 0 1 10 0v5"></path></svg>
                  <span>Clavier</span>
                </button>
                <button class="pinyin-input-type-btn" data-type="mcq">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8c1.1 0 2 .9 2 2v8c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V8c0-1.1.9-2 2-2z"></path><path d="M10 12h4"></path><path d="M12 10v4"></path></svg>
                  <span>Choix Multiple</span>
                </button>
              </div>
              <input type="hidden" id="pinyinInputType" value="keyboard">
            </div>
          </div>
          <div id="freeInputOptions" class="card game-mode-option" style="display:none;">
            <h2 class="section-title">Options d'affichage (Saisie Libre)</h2>
            <div class="input-group">
                <div class="display-mode-selector" id="freeInputDisplaySelector">
                    <button class="display-mode-btn active" data-mode="all">Tout afficher</button>
                    <button class="display-mode-btn" data-mode="translation_only">Traduction uniquement</button>
                    <button class="display-mode-btn" data-mode="chinese_only">Chinois uniquement</button>
                </div>
                <input type="hidden" id="freeInputDisplayMode" value="all">
            </div>
          </div>
          
          <div id="timeAttackOptions" class="card game-mode-option" style="display:none;">
            <h2 class="section-title">⏱️ Options Time Attack</h2>
            <div class="input-group">
              <label>Objectif (caractères par minute)</label>
              <div class="slider-container">
                <input type="range" id="cpmAttackTarget" min="5" max="100" value="30" step="5" class="slider"/>
                <span id="cpmAttackTargetValue" class="slider-value">30 car/min</span>
              </div>
            </div>
          </div>
          
          <div id="fillBlanksOptions" class="card game-mode-option" style="display:none;">
            <h2 class="section-title">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px; vertical-align: middle; margin-top: -2px;">
                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
              </svg>
              Options Phrases à trous
            </h2>
            <div class="input-group">
              <label>Niveaux à masquer</label>
              <div class="category-selector" id="gameCategorySelector">
                <button class="category-btn active" data-category="hsk">
                  <svg class="category-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                    <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                  </svg>
                  <span class="category-label">Niveaux HSK</span>
                </button>
                <button class="category-btn" data-category="freq">
                  <svg class="category-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="20" x2="18" y2="10"></line>
                    <line x1="12" y1="20" x2="12" y2="4"></line>
                    <line x1="6" y1="20" x2="6" y2="14"></line>
                  </svg>
                  <span class="category-label">Fréquence</span>
                </button>
              </div>
            </div>

            <div class="input-group">
              <div class="hsk-selector-grid" id="gameHskSelector">
                <button class="hsk-selector-btn active" data-level="1">HSK 1</button>
                <button class="hsk-selector-btn active" data-level="2">HSK 2</button>
                <button class="hsk-selector-btn" data-level="3">HSK 3</button>
                <button class="hsk-selector-btn" data-level="4">HSK 4</button>
                <button class="hsk-selector-btn" data-level="5">HSK 5</button>
                <button class="hsk-selector-btn" data-level="6">HSK 6</button>
                <button class="hsk-selector-btn" data-level="7">HSK 7-9</button>
              </div>

              <div class="hsk-selector-grid" id="gameFreqSelector" style="display: none;">
                <button class="hsk-selector-btn active" data-level="1">0-1k</button>
                <button class="hsk-selector-btn active" data-level="2">1-2k</button>
                <button class="hsk-selector-btn" data-level="3">2-3k</button>
                <button class="hsk-selector-btn" data-level="4">3-4k</button>
                <button class="hsk-selector-btn" data-level="5">4-5k</button>
                <button class="hsk-selector-btn" data-level="6">5-7k</button>
                <button class="hsk-selector-btn" data-level="7">7-10k</button>
                <button class="hsk-selector-btn" data-level="8">10-15k</button>
                <button class="hsk-selector-btn" data-level="9">15-40k</button>
              </div>
			  
			  </div> <div class="checkbox-container" id="showPinyinHintCheckContainer">
        <input type="checkbox" id="showPinyinHintCheck" checked />
        <label for="showPinyinHintCheck">Afficher le sinogramme (indice pinyin)</label>
			              </div>
						            </div>
          
        </div> </div> 
		
		<div id="readOptions">
		
		<div class="card">
          <h2 class="section-title">Mode d'affichage</h2>
          <div class="input-group">
            <div class="display-mode-selector" id="readDisplayModeSelector">
              <button class="display-mode-btn active" data-mode="instant">Instantané</button>
              <button class="display-mode-btn" data-mode="type">Frappe</button>
              <button class="display-mode-btn" data-mode="superzen">Superzen</button>
            </div>
            <input type="hidden" id="readDisplayModeSetting" value="instant">
          </div>
        </div>
		
<div class="card">
          <h2 class="section-title">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px; vertical-align: middle; margin-top: -2px;">
              <polygon points="12 2 2 7 12 12 22 7 12 2"></polygon>
              <polyline points="2 17 12 22 22 17"></polyline>
              <polyline points="2 12 12 17 22 12"></polyline>
            </svg>
            Sélection des niveaux
          </h2>
          
          <div class="input-group">
            <label>Type de catégorie</label>
            <div class="category-selector" id="readCategorySelector">
              <button class="category-btn active" data-category="hsk">
                <svg class="category-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                  <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                </svg>
                <span class="category-label">Niveaux HSK</span>
              </button>
              <button class="category-btn" data-category="freq">
                <svg class="category-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="18" y1="20" x2="18" y2="10"></line>
                  <line x1="12" y1="20" x2="12" y2="4"></line>
                  <line x1="6" y1="20" x2="6" y2="14"></line>
                </svg>
                <span class="category-label">Fréquence</span>
              </button>
            </div>
          </div>

          <div class="input-group">
            <label id="levelSelectorLabel">Niveaux HSK à surligner</label>
            <div class="hsk-selector-grid" id="hskSelector">
              <button class="hsk-selector-btn active" data-level="1">HSK 1</button>
              <button class="hsk-selector-btn active" data-level="2">HSK 2</button>
              <button class="hsk-selector-btn active" data-level="3">HSK 3</button>
              <button class="hsk-selector-btn" data-level="4">HSK 4</button>
              <button class="hsk-selector-btn" data-level="5">HSK 5</button>
              <button class="hsk-selector-btn" data-level="6">HSK 6</button>
              <button class="hsk-selector-btn" data-level="7">HSK 7-9</button>
            </div>

            <div class="hsk-selector-grid" id="freqSelector" style="display: none;">
              <button class="hsk-selector-btn active" data-level="1">0-1k</button>
              <button class="hsk-selector-btn active" data-level="2">1-2k</button>
              <button class="hsk-selector-btn active" data-level="3">2-3k</button>
              <button class="hsk-selector-btn" data-level="4">3-4k</button>
              <button class="hsk-selector-btn" data-level="5">4-5k</button>
              <button class="hsk-selector-btn" data-level="6">5-7k</button>
              <button class="hsk-selector-btn" data-level="7">7-10k</button>
              <button class="hsk-selector-btn" data-level="8">10-15k</button>
              <button class="hsk-selector-btn" data-level="9">15-40k</button>
            </div>
          </div>

          <div class="input-group" style="display: none;">
            <label>Mode d'affichage</label>
            <select id="displayMode">
              <option value="instant">Tout afficher immédiatement</option>
              <option value="type">Révéler caractère par caractère</option>
            </select>
          </div>
        </div>

       <div class="card">
          <h2 class="section-title">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 20px; height: 20px; vertical-align: middle; margin-top: -2px;">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
            </svg>
            Options de lecture
          </h2>
          
          <div class="input-group">
            <label>Taille du texte chinois</label>
            <select id="fontSize">
              <option value="20">Très petit</option>
              <option value="26">Petit</option>
              <option value="34" selected>Moyen</option>
              <option value="42">Grand</option>
              <option value="52">Très grand</option>
            </select>
          </div>

          <div class="input-group">
            <label>Hauteur d'interligne</label>
            <div class="slider-container">
              <input type="range" id="readInterligne_slider" min="60" max="150" value="100" step="5" class="slider"/>
              <span id="readInterligneValue" class="slider-value">100%</span>
            </div>
          </div>
          
          <div class="input-group">
            <label>Espacement caractères/mots</label>
            <div class="slider-container">
              <input type="range" id="readSpacing_slider" min="0" max="10" value="0" step="1" class="slider"/>
              <span id="readSpacingValue" class="slider-value">0 px</span>
            </div>
          </div>

          <div class="input-group">
            <label>Vitesse de révélation</label>
            <div class="slider-container">
              <input type="range" id="cpm" min="30" max="600" value="150" step="10" class="slider"/>
              <span id="cpmValue" class="slider-value">150 car/min</span>
            </div>
          </div>
        </div>
      </div> </div> </div> 

  <div class="floating-cta">
    <button id="launchBtn" class="btn-launch">
      <svg class="launch-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
      </svg>
      <span id="launchText">Lancer le jeu</span>
    </button>
  </div>
</div>

<div id="gamePage" class="game-page">
  
  <div class="game-container">
    
    <div id="translationHint" class="translation-hint"></div>

    <div class="game-main-content">
      
      <div id="reorder-drag-mode" class="game-mode-ui" style="display:none;">
        
        <div class="game-section" id="reorder-drop-section">
          <h3 class="game-section-title">Votre phrase</h3>
          <div id="userSentence" class="words-zone drop-zone"></div>
        </div>

        <div class="game-section" id="reorder-available-section">
          <h3 class="game-section-title">Mots disponibles</h3>
          <div id="availableWords" class="words-zone"></div>
        </div>
      </div>

      <div id="free-input-mode" class="game-mode-ui" style="display:none">
        <div class="game-section">
          <div id="free-input-target-text" class="typing-target-text" style="font-size: 24px; margin-bottom: 16px;"></div>
          <h3 class="game-section-title">Tapez la phrase</h3>
          <textarea id="freeInput" class="free-textarea" placeholder="Tapez la phrase ici... (Entrée pour valider)"></textarea>
        </div>
      </div>
      
      <div id="live-typing-mode" class="game-mode-ui" style="display:none">
        <div class="game-section">
          <div id="typing-target-text" class="typing-target-text"></div> <input type="text" id="typing-input" class="typing-input" aria-hidden="true" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        </div>
      </div>

      <div id="time-attack-mode" class="game-mode-ui" style="display:none">
        <div class="game-section">
          <div id="time-attack-translation" class="translation-hint" style="margin-top: 20px;"></div> 
          <div id="time-attack-target-text" class="typing-target-text"></div> 
          <input type="text" id="time-attack-input" class="typing-input" ... />
        </div>
      </div>
      
      <div id="fill-blanks-char-mode" class="game-mode-ui" style="display:none">
         <div class="game-section">
           <h3 class="game-section-title">Complétez la phrase (Caractères)</h3>
           <div id="blanks-display-text-char" class="blanks-display-text"></div>
           <input type="text" id="blanks-input-char" class="blanks-input" placeholder="Tapez le mot manquant... (Entrée pour valider)" />
         </div>
      </div>
      <div id="fill-blanks-pinyin-mode" class="game-mode-ui" style="display:none">
         <div class="game-section">
           <h3 class="game-section-title">Complétez la phrase (Pinyin)</h3>
           <div id="blanks-display-text-pinyin" class="blanks-display-text"></div>
           <input type="text" id="blanks-input-pinyin" class="blanks-input" placeholder="Tapez le pinyin manquant... (Entrée pour valider)" />
		       <div id="pinyin-mcq-options" class="pinyin-mcq-container" style="display: none;">
           </div>
         </div>
      </div>
      </div> <div id="gameResult" class="game-result"></div>

  </div> <div id="gameFooterFixed">
      <div class="game-actions">
        <button id="hintBtn" class="btn-game btn-hint">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
          <span>Indice</span>
        </button>
        <button id="validateBtn" class="btn-game btn-validate">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>
          <span>Valider</span>
        </button>
        <button id="restartBtn" class="btn-game btn-restart">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
          <span>Recommencer</span>
        </button>
      </div>

      <div class="stats-grid">
        <div class="stat-box"><div class="stat-label">Fautes</div><div class="stat-value" id="statErrors">0</div></div>
        <div class="stat-box"><div class="stat-label">Précision</div><div class="stat-value" id="statAccuracy">0%</div></div>
        <div class="stat-box"><div class="stat-label">Caractères</div><div class="stat-value" id="statChars">0/0</div></div>
        <div class="stat-box"><div class="stat-label">Temps / Cible</div><div class="stat-value" id="statTime">0s</div></div>
      </div>

      <div class="game-nav">
        <button id="prevSentenceBtn" class="btn-nav">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"></polyline></svg>
          <span>Précédent</span>
        </button>
        <span id="sentenceCounter" class="sentence-counter">0 / 0</span>
        <button id="nextSentenceBtn" class="btn-nav">
          <span>Suivant</span>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </button>
        <button id="quitGameBtn" class="btn-quit">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
      </div>
  </div> </div>

<div id="pinyinTonePopup">
</div>

<div id="readPage" class="read-page">
  <div class="read-controls">

    <div class="read-controls-inner" id="readControlsInner">

      <div class="read-panel" id="rc-panel-1">
        <button id="readCloseBtn" class="read-close">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>

        <button id="readPlayPause" class="read-play-pause">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
        </button>

        <button id="readModeToggle" class="read-mode-toggle">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9 11 12 14 22 4"></polyline>
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
          </svg>
          <span>Frappe</span>
        </button>

        <button id="readZenToggle" class="read-zen-toggle">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M12 6v6l4 2"></path>
          </svg>
          <span>Super Zen</span>
        </button>

        <div class="difficulty-gauge" id="rc-difficulty-gauge">
          <div class="difficulty-label">Difficulté</div>
          <div class="difficulty-bar">
            <div class="difficulty-fill" id="readDifficultyFill"></div>
          </div>
          <div class="difficulty-text" id="readDifficultyText">—</div>
        </div>

      </div> <div class="read-panel" id="rc-panel-2">
        <div class="read-filter-legend" id="readFilterLegend">
          <span>FILTRES:</span>
          <button class="read-legend-chip read-legend-focus" id="readFocusToggle">
            <span>Focus</span>
          </button>
        </div>
      </div> <div class="read-panel" id="rc-panel-3">
        
        <div class="read-font-controls">
          <button id="readFontDown" class="read-font-btn">A-</button>
          <span id="readFontSize" class="read-font-size">34px</span>
          <button id="readFontUp" class="read-font-btn">A+</button>
        </div>
        
        <div class="read-font-controls" id="readLineHeightControls">
          <button id="readInterligneDown" class="read-font-btn" title="Réduire interligne">I-</button>
          <span id="readLineHeight" class="read-font-size">100%</span>
          <button id="readInterligneUp" class="read-font-btn" title="Augmenter interligne">I+</button>
        </div>
        
        <div class="read-font-controls" id="readSpacingControls">
          <button id="readSpacingDown" class="read-font-btn" title="Réduire espacement">E-</button>
          <span id="readSpacing" class="read-font-size">0px</span>
          <button id="readSpacingUp" class="read-font-btn" title="Augmenter espacement">E+</button>
        </div>

      </div> </div> <div class="read-controls-dots" id="readControlsDots">
      <span class="dot active" data-index="0"></span>
      <span class="dot" data-index="1"></span>
      <span class="dot" data-index="2"></span>
    </div>
    <div class="read-progress" id="readProgress">
      <div class="read-progress-bar" id="readProgressBar"></div>
    </div>

    <button class="controls-toggle-btn" id="hideControlsBtn">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>
    </button>

  </div> <button class="controls-toggle-btn" id="showControlsBtn" style="display: none;">
     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
  </button>

  <div class="read-content">
    <div class="read-text-container" id="readTextContainer">
      <div class="read-text" id="readText"></div>
      <div class="read-translation" id="readTranslation"></div>
    </div>
  </div>

  <button id="readFlipBtn" class="read-flip-btn">
     <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="23 4 23 10 17 10"></polyline>
      <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
    </svg>
  </button>

  <div class="super-zen-controls">
      <button id="szBtnQuit" class="super-zen-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
        <polyline points="16 17 21 12 16 7"></polyline>
        <line x1="21" y1="12" x2="9" y2="12"></line>
      </svg>
      <span>Quitter</span>
    </button>
	
	    <button id="szBtnType" class="super-zen-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9 11 12 14 22 4"></polyline>
        <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
      </svg>
      <span>Frappe</span>
    </button>

    <button id="szBtnPrev" class="super-zen-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
      <span>Préc.</span>
    </button>

    <button id="szBtnPlay" class="super-zen-play">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
    </button>

    <button id="szBtnNext" class="super-zen-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
      <span>Suiv.</span>
    </button>

    <span class="super-zen-progress" id="szProgress">1/10</span>
  </div>
  
  
</div>

<div id="dictModal" class="dict-modal">
  <div class="dict-modal-content">
    <button id="closeDictModal" class="dict-modal-close">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>
    <div class="dict-char" id="dictChar"></div>
    
    <div class="dict-tabs-container" id="dictTabsContainer">
      </div>
    <div class="dict-panes-container" id="dictPanesContainer">
      </div>
    
  </div>
</div>

<div id="sentencesPreviewModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3 class="modal-title">Aperçu des phrases détectées</h3>
      <button class="modal-close" id="closeSentencesPreviewModal">✕</button>
    </div>
    <div class="modal-body" id="sentencesPreviewModalBody">
      </div>
  </div>
</div>


<script>
'use strict';

// =====================================================
// CARTE DE FRÉQUENCE DES POLYPHONES (AJOUT)
// =====================================================
const POLYPHONE_FREQ_MAP = new Map([
  ['的', ['de', 'dí', 'dì']],
  ['地', ['dì', 'de']],
  ['说', ['shuō', 'shuì']],
  ['那', ['nà', 'nǎ','Nuó', 'Nā']],
  ['哪', ['nǎ', 'na','něi', 'né']],
  ['上', ['shàng', 'shǎng']],
  ['得', ['de', 'děi', 'dé']],
  ['行', ['xíng', 'háng']],
  ['重', ['zhòng', 'chóng']],
  ['长', ['cháng', 'zhǎng']],
  ['乐', ['lè', 'yuè']],
  ['数', ['shù', 'shǔ']],
  ['发', ['fā', 'fà']],
  ['为', ['wéi', 'wèi']],
  ['难', ['nán', 'nàn']],
  ['空', ['kōng', 'kòng', 'kǒng']],
  ['么', ['me', 'ma', 'má']],
  ['处', ['chù', 'chǔ']],
  ['干', ['gàn', 'gān']],
  ['觉', ['jué', 'jiào']],
  ['还', ['hái', 'huán']],
  ['了', ['le', 'liǎo']],
  ['着', ['zhe', 'zháo', 'zhuó']],
  ['都', ['dōu', 'dū']],
  ['好', ['hǎo', 'hào']],
  ['少', ['shǎo', 'shào']],
  ['当', ['dāng', 'dàng']],
  ['调', ['tiáo', 'diào']],
  ['应', ['yīng', 'yìng']],
  ['便', ['biàn', 'pián']],
  ['倒', ['dào', 'dǎo']],
  ['省', ['shěng', 'xǐng']],
  ['看', ['kàn', 'kān']],
  ['给', ['gěi', 'jǐ']],
  ['读', ['dú', 'dòu']],
  ['转', ['zhuǎn', 'zhuàn']],
  ['强', ['qiáng', 'qiǎng', 'jiàng']],
  ['奇', ['qí', 'jī']],
  ['结', ['jié', 'jiē']],
  ['系', ['xì', 'jì']],
  ['差', ['chà', 'chā', 'chāi']],
  ['假', ['jiǎ', 'jià']],
  ['传', ['chuán', 'zhuàn']],
  ['弹', ['tán', 'dàn']],
  ['称', ['chēng', 'chèn']],
  ['乘', ['chéng', 'shèng']],
  ['塞', ['sāi', 'sài', 'sè']],
  ['舍', ['shè', 'shě']],
  ['折', ['zhé', 'zhē', 'shé']],
  ['尽', ['jìn', 'jǐn']],
  ['种', ['zhǒng', 'zhòng']],
  ['露', ['lù', 'lòu']],
  ['薄', ['báo', 'bó', 'bò']],
  ['铺', ['pū', 'pù']],
  ['供', ['gōng', 'gòng']],
  ['朝', ['cháo', 'zhāo']],
  ['查', ['chá', 'zhā']],
  ['柏', ['bǎi', 'bó', 'bò']],
  ['模', ['mó', 'mú']],
  ['恶', ['è', 'wù', 'ě']],
  ['和', ['hé', 'hè', 'huó', 'huò']],
  ['中', ['zhōng', 'zhòng']],
  ['蒙', ['méng', 'měng', 'mēng']],
  ['磨', ['mó', 'mò']],
  ['泊', ['bó', 'pō']],
  ['漂', ['piāo', 'piào']],
  ['暴', ['bào', 'pù']],
  ['降', ['jiàng', 'xiáng']],
  ['圈', ['quān', 'juàn', 'juān']],
  ['剥', ['bō', 'bāo']],
  ['藏', ['cáng', 'zàng']],
  ['晕', ['yūn', 'yùn']],
  ['划', ['huà', 'huá']],
  ['背', ['bèi', 'bēi']],
  ['冲', ['chōng', 'chòng']],
  ['冠', ['guàn', 'guān']],
  ['间', ['jiān', 'jiàn']],
  ['卷', ['juàn', 'juǎn']],
  ['角', ['jiǎo', 'jué']],
  ['教', ['jiào', 'jiāo']],
  ['佛', ['fó', 'fú']],
  ['核', ['hé', 'hú']],
  ['盛', ['shèng', 'chéng']],
  ['曾', ['céng', 'zēng']],
  ['厦', ['shà', 'xià']],
  ['只', ['zhǐ', 'zhī']],
  ['斗', ['dòu', 'dǒu']],
  ['缝', ['féng', 'fèng']],
  ['拗', ['ào', 'niù', 'ǒu']],
  ['更', ['gèng', 'gēng']],
  ['杆', ['gān', 'gǎn']],
  ['累', ['lèi', 'lěi', 'léi']],
  ['哄', ['hōng', 'hǒng', 'hòng']],
  ['壳', ['ké', 'qiào']],
  ['咽', ['yàn', 'yān', 'yè']],
  ['吐', ['tǔ', 'tù']],
  ['削', ['xuē', 'xiāo']],
  ['挨', ['ái', 'āi']],
  ['堡', ['bǎo', 'pù', 'bǔ']],
  ['翘', ['qiào', 'qiáo']],
  ['铅', ['qiān', 'yán']],
  ['嚷', ['rǎng', 'rāng']],
  ['答', ['dá', 'dā']],
  ['迫', ['pò', 'pǎi']],
  ['参', ['cān', 'shēn', 'cēn']],
  ['臼', ['jiù', 'jū']],
  ['咯', ['gē', 'luò', 'lo']],
  ['刹', ['shā', 'chà']],
  ['掠', ['lüè', 'luě']],
  ['梁', ['liáng', 'liàng']],
  ['屏', ['píng', 'bǐng']],
  ['炮', ['pào', 'páo']],
  ['刨', ['páo', 'bào']],
  ['坊', ['fāng', 'fáng']],
  ['匙', ['chí', 'shi']],
  ['否', ['fǒu', 'pǐ']],
  ['朴', ['pǔ', 'piáo', 'pò']],
  ['咳', ['ké', 'hāi']],
  ['提', ['tí', 'dī']],
  ['散', ['sǎn', 'sàn']],
  ['脏', ['zāng', 'zàng']],
  ['曲', ['qǔ', 'qū']],
  ['占', ['zhàn', 'zhān']],
  ['拆', ['chāi', 'cā']],
  ['挣', ['zhèng', 'zhēng']],
  ['挎', ['kuà', 'kuā']],
  ['跑', ['pǎo', 'páo']],
  ['量', ['liàng', 'liáng']],
  ['晃', ['huǎng', 'huàng']],
  ['拌', ['bàn', 'pàn']],
  ['钻', ['zuān', 'zuàn']],
  ['泡', ['pào', 'pāō']],
  ['闷', ['mèn', 'mēn']]
]);

// =====================================================
// VARIABLES GLOBALES
// =====================================================
let appMode = 'read';
let dict = { entries: new Map(), wordSet: new Set(), maxLen: 1 };
let levelMap = new Map();

// Game state
let sentences = [];
let translations = [];
let currentSentenceIndex = 0;
let currentGameMode = 'reorder-drag';
let showTranslation = true;
let originalSentence = '';
let currentSentenceTokens = [];
let hintsRevealed = 0;
let gameDisplayMode = 'all';
let gameTimerInterval = null;
let gameStartTime = 0;
let timeAttackEndTime = 0;
let currentBlankIndex = 0;
let fillBlanksData = [];
let pinyinInputBuffer = '';
let pinyinInputType = 'keyboard';

// Read state
let readCategory = 'hsk';
let readSelectedLevels = new Set([1, 2, 3]);
let readDisplayMode = 'instant';
let readFontSize = 34;
let readInterligne = 1.0; // (100%)
let readSpacing = 0; // (0px)
let readCPM = 150;
let readIsPlaying = false;
let readCurrentIndex = 0; // Index du caractère chinois courant
let readTranslationCurrentIndex = 0; // Index CIBLE du caractère de traduction courant
let readTimer = null;
let readChars = []; // Array des <span> chinois
let readTranslationChars = []; // Array des <span> de traduction
let readSuperZen = false;
let readSuperZenType = false; // Mode frappe DANS super zen
let isFlipped = false; // Pour le mode mobile flip
let readSentences = []; // Phrases chinoises pour lecture
let readTranslations = []; // Traductions pour lecture
let readFocusMode = false;
let readPauseTimeout = null;
let readSentenceBoundaries = [];
// NOUVEAU: Plus besoin de readSentenceBoundaries, readCurrentSentenceIndex, readSentenceStartTime

let readCurrentSentence = 0; // Gardé pour Super Zen (index de la phrase affichée)

// --- 1. Variables d'état (uniques) ---
let dnd_draggedElement = null;
let dnd_placeholder = null;
let dnd_leaveTimer = null;
let dnd_touchMovePlaceholder = null;
let dnd_startX = 0;
let dnd_startY = 0;

// --- 2. Fonctions de gestion (définies une seule fois) ---

function dnd_handleTokenClick(e) {
    if (!e.target.classList.contains('word-token')) return;
    const token = e.target;
    const currentZone = token.parentNode;
    const targetZoneId = currentZone.id === 'availableWords' ? 'userSentence' : 'availableWords';
    const targetZone = document.getElementById(targetZoneId);
    if (targetZone) {
        targetZone.appendChild(token);
    }
}

function dnd_handleDragStart(e) {
    dnd_draggedElement = this;
    e.dataTransfer.effectAllowed = 'move';
    
    // Initialise le placeholder global
    if (!dnd_placeholder) {
        dnd_placeholder = document.createElement('div');
        dnd_placeholder.className = 'drop-placeholder';
    }
    // Copie les dimensions
    dnd_placeholder.style.width = `${this.offsetWidth}px`;
    dnd_placeholder.style.height = `${this.offsetHeight}px`;

    setTimeout(() => this.classList.add('dragging'), 0);
}

function dnd_handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';

    if (dnd_leaveTimer) {
        clearTimeout(dnd_leaveTimer);
        dnd_leaveTimer = null;
    }

    const container = this;
    const afterElement = dnd_getDragAfterElement(container, e.clientX, e.clientY);

    if (afterElement == null) {
        if (container.lastChild !== dnd_placeholder) {
            container.appendChild(dnd_placeholder);
        }
    } else {
        if (afterElement.previousSibling !== dnd_placeholder) {
            container.insertBefore(dnd_placeholder, afterElement);
        }
    }
    dnd_placeholder.classList.add('drag-over');
}

function dnd_handleDragLeave(e) {
    dnd_placeholder.classList.remove('drag-over');
    
    if (e.relatedTarget && this.contains(e.relatedTarget)) {
        return;
    }

    dnd_leaveTimer = setTimeout(() => {
        if (dnd_placeholder.parentNode) {
            dnd_placeholder.parentNode.removeChild(dnd_placeholder);
        }
        dnd_leaveTimer = null;
    }, 50);
}

function dnd_handleDrop(e) {
    e.preventDefault();
    e.stopPropagation();

    if (dnd_leaveTimer) {
        clearTimeout(dnd_leaveTimer);
        dnd_leaveTimer = null;
    }

    if (dnd_draggedElement) {
        if (dnd_placeholder.parentNode) {
            dnd_placeholder.parentNode.insertBefore(dnd_draggedElement, dnd_placeholder);
            dnd_placeholder.parentNode.removeChild(dnd_placeholder);
        } else {
            this.appendChild(dnd_draggedElement);
        }
        dnd_draggedElement.classList.remove('dragging');
    }
}

function dnd_handleDragEnd(e) {
    this.classList.remove('dragging');

    if (dnd_leaveTimer) {
        clearTimeout(dnd_leaveTimer);
        dnd_leaveTimer = null;
    }

    if (dnd_placeholder && dnd_placeholder.parentNode) {
        dnd_placeholder.parentNode.removeChild(dnd_placeholder);
    }
    dnd_draggedElement = null;
}

function resizeAvailableWords() {
  // Seulement utile sur mobile
  if (window.innerWidth > 900) return;

  const avail = document.getElementById('availableWords');
  const footer = document.getElementById('gameFooterFixed');
  if (!avail) return;

  // Haut du footer (ou bas de l'écran si pas de footer)
  const footerTop = footer ? footer.getBoundingClientRect().top : window.innerHeight;
  // Haut de la boîte des mots
  const availTop = avail.getBoundingClientRect().top;

  // Petite marge de respiration avec le footer
  const margin = 8; 
  const max = Math.max(100, footerTop - availTop - margin);

  // Applique la hauteur max au pixel près
  avail.style.maxHeight = max + 'px';

  // Active le scroll seulement si besoin
  if (avail.scrollHeight > max) {
    avail.style.overflowY = 'auto';
  } else {
    avail.style.overflowY = 'visible';
  }

  // Inertie mobile
  avail.style.webkitOverflowScrolling = 'touch';
}

/* Observe les ajouts/suppressions de mots pour réajuster la hauteur */
function observeAvailableWords() {
  const avail = document.getElementById('availableWords');
  if (!avail) return;
  const mo = new MutationObserver(() => resizeAvailableWords());
  mo.observe(avail, { childList: true }); // enfants directs suffisent
}

/* Relance le calcul à chaque changement de taille/orientation */
function bindResizeForAvailableWords() {
  window.addEventListener('resize', () => {
    if (window.innerWidth <= 900) resizeAvailableWords();
  });
  window.addEventListener('orientationchange', () => {
    // Laisse le temps à la mise en page de se recalculer
    setTimeout(resizeAvailableWords, 200);
  });
}

// --- Fonctions tactiles ---

function dnd_handleTouchStart(e) {
    if (e.touches.length > 1) return;

    dnd_draggedElement = this;
    dnd_draggedElement.classList.add('dragging');

    const touch = e.touches[0];
    dnd_startX = touch.clientX;
    dnd_startY = touch.clientY;

    // S'assure que le placeholder existe
    if (!dnd_placeholder) {
        dnd_placeholder = document.createElement('div');
        dnd_placeholder.className = 'drop-placeholder';
    }
    
    // Crée le placeholder tactile
    dnd_touchMovePlaceholder = dnd_placeholder.cloneNode(true);
    dnd_touchMovePlaceholder.style.width = `${dnd_draggedElement.offsetWidth}px`;
    dnd_touchMovePlaceholder.style.height = `${dnd_draggedElement.offsetHeight}px`;

    dnd_draggedElement.style.position = 'fixed';
    dnd_draggedElement.style.zIndex = '10005';
    dnd_draggedElement.style.left = `${touch.clientX - dnd_draggedElement.offsetWidth / 2}px`;
    dnd_draggedElement.style.top = `${touch.clientY - dnd_draggedElement.offsetHeight / 2}px`;
}

function dnd_handleTouchMove(e) {
    if (!dnd_draggedElement || e.touches.length > 1) return;
    e.preventDefault();

    const touch = e.touches[0];
    dnd_draggedElement.style.left = `${touch.clientX - dnd_draggedElement.offsetWidth / 2}px`;
    dnd_draggedElement.style.top = `${touch.clientY - dnd_draggedElement.offsetHeight / 2}px`;

    dnd_draggedElement.style.display = 'none';
    let elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    dnd_draggedElement.style.display = '';

    let dropZone = null;
    if (elementBelow) {
        dropZone = elementBelow.closest('.words-zone');
    }

    if (dropZone) {
        const afterElement = dnd_getDragAfterElement(dropZone, touch.clientX, touch.clientY);
        
        if (afterElement == null) {
            if (dropZone.lastChild !== dnd_touchMovePlaceholder) {
                dropZone.appendChild(dnd_touchMovePlaceholder);
            }
        } else {
            if (afterElement.previousSibling !== dnd_touchMovePlaceholder) {
                dropZone.insertBefore(dnd_touchMovePlaceholder, afterElement);
            }
        }
    } else if (dnd_touchMovePlaceholder.parentNode) {
        dnd_touchMovePlaceholder.parentNode.removeChild(dnd_touchMovePlaceholder);
    }
}

function dnd_handleTouchEnd(e) {
    if (!dnd_draggedElement) return;

    if (dnd_touchMovePlaceholder && dnd_touchMovePlaceholder.parentNode) {
        dnd_touchMovePlaceholder.parentNode.insertBefore(dnd_draggedElement, dnd_touchMovePlaceholder);
        dnd_touchMovePlaceholder.parentNode.removeChild(dnd_touchMovePlaceholder);
    }

    dnd_draggedElement.classList.remove('dragging');
    dnd_draggedElement.style.position = '';
    dnd_draggedElement.style.zIndex = '';
    dnd_draggedElement.style.left = '';
    dnd_draggedElement.style.top = '';

    dnd_draggedElement = null;
    dnd_touchMovePlaceholder = null;
}

// --- Fonction utilitaire ---

function dnd_getDragAfterElement(container, x, y) {
    // 1. On récupère tous les mots, sauf celui qu'on déplace
    const draggableElements = [...container.querySelectorAll('.word-token:not(.dragging)')];

    // 2. On parcourt tous les mots dans l'ordre du DOM
    for (const child of draggableElements) {
        const box = child.getBoundingClientRect();

        // CAS 1: Le curseur (y) est AU-DESSUS de l'élément (box.top)
        // L'élément 'child' est sur une ligne inférieure.
        // On doit donc insérer AVANT 'child'.
        if (y < box.top) {
            return child;
        }

        // CAS 2: Le curseur (y) est SUR LA MÊME LIGNE que l'élément
        if (y >= box.top && y <= box.bottom) {
            
            // On vérifie la position X.
            // Si le curseur (x) est à GAUCHE du MILIEU de l'élément...
            // on doit insérer AVANT 'child'.
            if (x < (box.left + box.width / 2)) {
                return child;
            }
            
            // Si on est à droite du milieu, cet élément 'child' est AVANT nous.
            // On continue donc la boucle pour voir le suivant.
        }

        // CAS 3: Le curseur (y) est EN DESSOUS de l'élément (box.bottom)
        // L'élément 'child' est sur une ligne supérieure. Il est donc AVANT nous.
        // On continue la boucle.
    }

    // 3. Si on a parcouru tous les éléments sans rien trouver,
    // c'est que le curseur est après tous les mots.
    // On doit donc insérer à la fin.
    return null; 
}


// =====================================================
// UTILITY FUNCTIONS
// =====================================================
function normalizeChineseText(text) {
    if (!text) return '';
    text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');
    text = text.replace(/\r\n?/g, '\n');
    text = text.replace(/\n+/g, ' ');
    const punct = "，。！？；：,.!?;:\"《》『』「」\"\"''（）﹙﹚︹︺【】()";
    text = text.replace(new RegExp(`\\s+([${punct}])`, 'gu'), '$1');
    text = text.replace(new RegExp(`([${punct}])\\s+`, 'gu'), '$1');
    return text.trim();
}

function splitSentences(text) {
    if (!text) return [];
    const parts = text.split(/\s*\/\/\s*/g);
    const result = [];
    for (const part of parts) {
        const s = part.split(/(?<=[。！？])\s*/g).filter(Boolean);
        result.push(...s);
    }
    return result.filter(s => s.trim().length > 0);
}

function parseCedict(raw) {
    const entries = new Map(); // La clé est 'simp', la valeur est un Array d'objets
    const wordSet = new Set();
    let maxLen = 1;

    for (const line of raw.split(/\r?\n/)) {
        const L = line.trim();
        if (!L || L.startsWith('#')) continue;

        const m = L.match(/^(\S+)\s+(\S+)\s+\[([^\]]+)\]\s+\/(.+)\/$/);
        if (!m) continue;

        const trad = m[1]; 
        const simp = m[2];
        const pinyin = m[3];
        const defs = m[4].split('/').filter(Boolean);
        
        const newEntry = { trad, simp, pinyin, defs }; // Créer l'objet entrée

        // Si la clé n'existe pas, initialiser avec un tableau
        if (!entries.has(simp)) {
            entries.set(simp, [newEntry]);
        } else {
            // Si la clé existe, pousser la nouvelle entrée dans le tableau
            entries.get(simp).push(newEntry);
        }

        wordSet.add(simp);
        if (simp.length > maxLen) maxLen = simp.length;
    }

    return { entries, wordSet, maxLen };
}

function csvToLevelMap(raw) {
    const m = new Map();
    const lines = raw.split(/\r?\n/);
    if (!lines.length) return m;

    let delim = ',';
    if (lines[0].includes(';') && !lines[0].includes(',')) delim = ';';

    for (let i = 1; i < lines.length; i++) {
        const l = (lines[i] || '').trim();
        if (!l) continue;

        const parts = l.split(delim);
        if (parts.length < 2) continue;

        const w = (parts[0] || '').trim().replace(/\s+/g, '');
        const val = (parts[1] || '').trim();
        if (!w || !val) continue;

        const rec = m.get(w) || {};

        if (/^\d+$/.test(val)) {
            const lvl = Math.min(7, Math.max(1, Number(val)));
            rec.hsk = Math.max(rec.hsk || 0, lvl);
        } else if (/^7\s*-\s*9$/.test(val) || val.includes('sept')) {
            rec.hsk = Math.max(rec.hsk || 0, 7);
        } else if (/^\d+\s*-\s*\d+$/.test(val)) {
            const [a, b] = val.split('-').map(x => Number(x.trim()));
            let freq;
            if (a < 1000 && b <= 1000) freq = 1;
            else if (a < 2000 && b <= 2000) freq = 2;
            else if (a < 3000 && b <= 3000) freq = 3;
            else if (a < 4000 && b <= 4000) freq = 4;
            else if (a < 5000 && b <= 5000) freq = 5;
            else if (a < 7000 && b <= 7000) freq = 6;
            else if (a < 10000 && b <= 10000) freq = 7;
            else if (a < 15000 && b <= 15000) freq = 8;
            else freq = 9;
            rec.freq = Math.max(rec.freq || 0, freq);
        } else {
            continue;
        }

        m.set(w, rec);
    }
    console.log('📊 CSV chargé:', m.size, 'mots');
    return m;
}

function segmentText(text, wordSet, maxLen) {
    const tokens = [];
    let i = 0;
    const punct = new Set("，。！？；：,.!?;:\"《》『』「」\"\"''（）﹙﹚︹︺【】()");

    while (i < text.length) {
        const char = text[i];

        if (punct.has(char) || /\s/.test(char)) {
            tokens.push({ text: char, type: 'punc' });
            i++;
            continue;
        }

        let found = false;
        for (let len = Math.min(maxLen, text.length - i); len >= 1; len--) {
            const candidate = text.substring(i, i + len);
            if (wordSet.has(candidate)) {
                tokens.push({ text: candidate, type: 'word' });
                i += len;
                found = true;
                break;
            }
        }

        if (!found) {
            tokens.push({ text: char, type: 'word' });
            i++;
        }
    }

    return tokens;
}

function getLevel(word, category) {
    const d = levelMap.get(word);
    if (!d) return 0;
    return category === 'hsk' ? (d.hsk || 0) : (d.freq || 0);
}

function levelClassFor(word, category) {
    const lvl = getLevel(word, category);
    if (lvl === 0) return '';

    if (category === 'hsk') {
        if (lvl <= 6) return `hsk${lvl}`;
        return 'hsk79';
    } else {
        return `freq${lvl}`;
    }
}

function getDifficultyGradientColor(value, maxLevel) {
  // Assurer que maxLevel est au moins 1 pour éviter division par zéro
  const effectiveMaxLevel = Math.max(1, maxLevel);
  // Normaliser la valeur entre 0 et 1 (en partant de 1 comme base)
  const t = Math.max(0, Math.min(1, (value - 1) / (effectiveMaxLevel - 1)));

  // Vert → bleu → orange → rose → violet
  const stops = [
    [0.00, [8,210,89]],   // vert clair
    [0.25, [34,159,255]], // bleu
    [0.50, [255,180,60]], // jaune-orangé
    [0.75, [255,71,194]], // rose
    [1.00, [160,8,109]]   // violet foncé
  ];

  let i = 0;
  // Trouver le segment de couleur correct
  while (i < stops.length - 2 && t > stops[i + 1][0]) { // stops.length - 2 car on compare avec i+1
      i++;
  }

  const [t1, c1] = stops[i];
  const [t2, c2] = stops[i + 1];

  // Calculer le facteur d'interpolation (éviter division par zéro)
  const factor = (t2 - t1 === 0) ? 0 : Math.max(0, Math.min(1, (t - t1) / (t2 - t1)));

  // Interpoler les composantes RGB
  const r = Math.round(c1[0] + (c2[0] - c1[0]) * factor);
  const g = Math.round(c1[1] + (c2[1] - c1[1]) * factor);
  const b = Math.round(c1[2] + (c2[2] - c1[2]) * factor);

  return `rgb(${r},${g},${b})`;
}

// =====================================================
// UTILITY FUNCTIONS (REPLACE THIS ONE - V3 Difficulty)
// =====================================================

// =====================================================
// UTILITY FUNCTIONS (REPLACE THIS ONE - V5 Difficulty Tuning - Repeated Unknowns)
// =====================================================

// =====================================================
// UTILITY FUNCTIONS (REPLACE THIS ONE - V4 Difficulty Tuning)
// =====================================================

function calculateDifficulty(tokenSents, category) {
  const effectiveCategory = category || readCategory || 'hsk';
  const maxLevel = (effectiveCategory === 'hsk') ? 7.0 : 9.0;
  const hskMaxLevelForBonus = 7.0;

  // --- Constantes de Tuning (Ajustées) ---
  const WEIGHT_LEX_AVG = 0.45; // Plus de poids à la moyenne
  const WEIGHT_HARD_TAIL = 0.55; // Moins de poids au hard tail
  const UNKNOWN_IMPACT_FACTOR = 2.0; // Impact des inconnus légèrement réduit
  const LENGTH_MODERATION_FACTOR = 15.0;
  const BONUS_HSK4_ONLY = 0.15; // NOUVEAU: Petit bonus si HSK 4 est le max détecté
  const BONUS_HSK5 = 0.3;  // Bonus HSK 5 réduit
  const BONUS_HSK6 = 0.5;  // Bonus HSK 6 réduit
  const BONUS_HSK7PLUS = 0.7; // Bonus HSK 7+ réduit
  const GRAMMAR_WEIGHT = 0.05;
  const AVG_SENTENCE_LEN_TARGET = 15; // Gardé pour référence, utilisé plus bas
  const SENTENCE_LEN_ADJUST_FACTOR = 0.02;
  const MAX_SENTENCE_LEN_ADJUST = 0.3;

  // --- 1. Extraction & Analyse Initiale ---
  if (!tokenSents || tokenSents.length === 0) return { scorePct: 0, label: '—', color: 'var(--muted)', level: 1 };
  const allTokens = tokenSents.flat();
  const wordTokens = allTokens.filter(t => t.type === 'word' && !/\s/.test(t.text));
  const wordCount = wordTokens.length;
  if (wordCount === 0) return { scorePct: 0, label: '—', color: 'var(--muted)', level: 1 };

  const freqMap = new Map();
  wordTokens.forEach(t => { freqMap.set(t.text, (freqMap.get(t.text) || 0) + 1); });

  const knownWordLevels = [];
  let unknownCount = 0;
  let hasHSK4 = false, hasHSK5 = false, hasHSK6 = false, hasHSK7plus = false; // Détecter HSK 4 aussi

  for (const [word, f] of freqMap.entries()) {
    const levelData = levelMap.get(word);
    const lvlCurrentCat = levelData?.[effectiveCategory] || 0;
    const lvlHsk = levelData?.hsk || 0;

    if (lvlCurrentCat > 0) {
      knownWordLevels.push({ level: lvlCurrentCat, freq: f });
    } else {
      unknownCount++;
    }

    // Détecter présence de mots HSK 4+
    if (lvlHsk >= 4 && lvlHsk < 5) hasHSK4 = true;
    if (lvlHsk >= 5 && lvlHsk < 6) hasHSK5 = true;
    if (lvlHsk >= 6 && lvlHsk < 7) hasHSK6 = true;
    if (lvlHsk >= 7) hasHSK7plus = true;
  }

  const knownTypesCount = knownWordLevels.length;
  const uniqueWordTypesCount = freqMap.size;
  const unknownRatio = uniqueWordTypesCount > 0 ? unknownCount / uniqueWordTypesCount : 0;

  // --- 2. Score de Base (Mots Connus) ---
  let scoreBaseKnown = 1.0;
  let lexAvgKnown = 1.0;
  let hardTailKnownAvg = 1.0;

  if (knownTypesCount > 0) {
    let weightedSumKnown = 0;
    let totalWeightKnown = 0;
    knownWordLevels.forEach(item => {
      const weight = Math.log(1 + item.freq);
      weightedSumKnown += item.level * weight;
      totalWeightKnown += weight;
    });
    lexAvgKnown = totalWeightKnown > 0 ? weightedSumKnown / totalWeightKnown : 1.0;

    const knownLevelsOnly = knownWordLevels.map(item => item.level).sort((a, b) => b - a);
    const tailCountKnown = Math.min(knownTypesCount, Math.max(1, Math.floor(knownTypesCount * 0.15)));
    hardTailKnownAvg = tailCountKnown > 0
        ? knownLevelsOnly.slice(0, tailCountKnown).reduce((a, b) => a + b, 0) / tailCountKnown
        : lexAvgKnown;

    // Nouvelle combinaison pour scoreBaseKnown
    scoreBaseKnown = (WEIGHT_LEX_AVG * lexAvgKnown) + (WEIGHT_HARD_TAIL * hardTailKnownAvg);
  } else {
      scoreBaseKnown = 1.5; // Si aucun mot connu
  }

  // --- 3. Impact des Mots Inconnus ---
  const lengthFactor = Math.tanh(wordCount / LENGTH_MODERATION_FACTOR);
  // Utiliser une échelle un peu plus douce pour l'impact des inconnus
  const unknownScaling = (0.8 + (maxLevel - scoreBaseKnown)) / (0.8 + maxLevel); // Varie moins vite
  const unknownImpact = unknownRatio * lengthFactor * UNKNOWN_IMPACT_FACTOR * unknownScaling;
  let currentScore = scoreBaseKnown + unknownImpact;

  // --- 4. Bonus Mots Difficiles (HSK 4+) - Hiérarchique ---
  // Appliquer SEULEMENT le bonus du niveau le plus élevé trouvé
  if (hasHSK7plus) {
      currentScore += BONUS_HSK7PLUS;
  } else if (hasHSK6) {
      currentScore += BONUS_HSK6;
  } else if (hasHSK5) {
      currentScore += BONUS_HSK5;
  } else if (hasHSK4) { // Appliqué seulement si 4 est le max
      currentScore += BONUS_HSK4_ONLY;
  }
  // Note: Si le texte ne contient que HSK 1-3, aucun bonus n'est ajouté ici.

  // --- 5. Ajustements Mineurs (Grammaire & Longueur Phrase) ---
  const gram = analyzeGrammarComplexity(tokenSents); // Appeler la sous-fonction
  const connScore = Math.min(gram.connectorsPerSent / 1.5, 1);
  const lenScore = Math.min(Math.max(0, (gram.avgSentLen - 10)) / 20, 1);
  const baBeiScore = Math.min((gram.baRate + gram.beiRate) / 0.5, 1);
  const grammarAdjustment = (0.4*connScore + 0.3*lenScore + 0.2*baBeiScore) * GRAMMAR_WEIGHT * maxLevel;
  currentScore += grammarAdjustment;

  // Ajustement longueur phrase
  const avgSentLenConst = AVG_SENTENCE_LEN_TARGET; // Assigner à une var locale pour utilisation
  let sentenceLengthAdjustment = (gram.avgSentLen - avgSentLenConst) * SENTENCE_LEN_ADJUST_FACTOR;
  sentenceLengthAdjustment = Math.max(-MAX_SENTENCE_LEN_ADJUST, Math.min(MAX_SENTENCE_LEN_ADJUST, sentenceLengthAdjustment));
  currentScore += sentenceLengthAdjustment;


  // --- 6. Plafonnement et Formatage ---
  const finalScore = Math.max(1.0, Math.min(maxLevel + 0.5, currentScore)); // Borner (permet un léger dépassement interne)

  const scorePct = Math.round(((finalScore - 1) / (maxLevel - 1)) * 100);
  let displayLabel = '';
  let displayScoreForColor = finalScore; // Score utilisé pour la couleur

  if (effectiveCategory === 'hsk') {
    // Brider l'affichage à maxLevel (7.0), mais utiliser le score potentiellement > 7 pour la couleur
    displayLabel = `HSK ${Math.min(maxLevel, finalScore).toFixed(1)}`;
    displayScoreForColor = Math.min(maxLevel, finalScore); // Utiliser le score bridé pour la couleur HSK
  } else { // 'freq'
     const freqMapScale = [500, 1000, 2000, 3000, 4000, 5000, 7000, 10000, 15000, 20000];
     const freqIndex = Math.min(freqMapScale.length - 1, Math.max(0, Math.round(finalScore) - 1));
     let freqValue = freqMapScale[freqIndex];
     freqValue = Math.round(freqValue / 100) * 100;
     displayLabel = `~${freqValue}`;
     // Pour la couleur freq, on peut utiliser l'échelle 1-9
     displayScoreForColor = Math.min(maxLevel, finalScore);
  }

  const color = getDifficultyGradientColor(displayScoreForColor, maxLevel); // Utiliser le score (potentiellement bridé) pour la couleur

  // Log détaillé
  console.log(`Difficulty V4 Breakdown: BaseKnown=${scoreBaseKnown.toFixed(2)} (LexAvg:${lexAvgKnown.toFixed(2)}, Tail:${hardTailKnownAvg.toFixed(2)}), UnknownImpact=${unknownImpact.toFixed(2)} (Ratio:${unknownRatio.toFixed(2)}, LenFactor:${lengthFactor.toFixed(2)}), HSKBonus=${(hasHSK7plus?BONUS_HSK7PLUS:(hasHSK6?BONUS_HSK6:(hasHSK5?BONUS_HSK5:(hasHSK4?BONUS_HSK4_ONLY:0)))).toFixed(2)}, GramAdj=${grammarAdjustment.toFixed(2)}, SentLenAdj=${sentenceLengthAdjustment.toFixed(2)} -> Final=${finalScore.toFixed(2)} -> Display=${displayLabel}`);

  return {
    scorePct: Math.max(0, Math.min(100, scorePct)),
    label: displayLabel,
    color: color,
    level: finalScore,
  };


  // === Sous-fonction grammaire simplifiée (inchangée) ===
  function analyzeGrammarComplexity(tokenSents){
    // ... (code identique à la version précédente) ...
     const connectors = new Set(['因为','所以','虽然','但是','而且','于是','然而','不过','即使','尽管','同时','不仅','还','无论','只要','否则','才','就','却','因此','此外','另外','反而']);
    const patterns = [['虽然','但是'], ['尽管','还'], ['因为','所以'], ['不仅','而且'], ['即使','也'], ['无论','都'], ['只要','就'],['只有','才'], ['不是','就是']];
    let totalConns=0, totalBa=0, totalBei=0, totalWordTokens=0, comp3=0, patt=0;
    const sCount = tokenSents.length || 1;

    for(const sent of tokenSents){
      const sentenceWordTokens = sent.filter(t => t.type === 'word' && !/\s/.test(t.text));
      totalWordTokens += sentenceWordTokens.length;
      const words = sentenceWordTokens.map(t=>t.text);

      for(const w of words){
        if(connectors.has(w)) totalConns++;
        if(w==='把') totalBa++;
        if(w==='被') totalBei++;
        if(w.length>=3) comp3++;
      }
      for(const [a,b] of patterns){
        if(words.includes(a) && words.includes(b)) patt++;
      }
    }

    return {
      connectorsPerSent: totalConns / sCount,
      baRate: totalBa / sCount,
      beiRate: totalBei / sCount,
      avgSentLen: totalWordTokens / sCount,
      compound3Rate: comp3 / Math.max(1, totalWordTokens),
      patternScore: patt / sCount
    };
  }
} // Fin de calculateDifficulty

function numericToDiacriticPinyin(pinyin) {
    const toneMarks = { a:['ā','á','ǎ','à','a'], e:['ē','é','ě','è','e'], i:['ī','í','ǐ','ì','i'], o:['ō','ó','ǒ','ò','o'], u:['ū','ú','ǔ','ù','u'], ü:['ǖ','ǘ','ǚ','ǜ','ü'], v:['ǖ','ǘ','ǚ','ǜ','ü'] };
    const priority = ['a', 'o', 'e', 'i', 'u', 'ü', 'v'];

    return pinyin.replace(/([a-züv:]+)([1-5])/gi, (match, syllable, toneNum) => {
        const toneIndex = parseInt(toneNum) - 1;
        let vowelFound = false;

        for (const vowel of priority) {
            if (syllable.includes(vowel)) {
                const marks = toneMarks[vowel];
                if (marks) {
                    syllable = syllable.replace(vowel, marks[toneIndex]);
                    vowelFound = true;
                    break;
                }
            }
        }

        if (!vowelFound) {
             for (let i = syllable.length - 1; i >= 0; i--) {
                 const char = syllable[i].toLowerCase();
                 const marks = toneMarks[char];
                 if (marks) {
                    syllable = syllable.substring(0, i) + marks[toneIndex] + syllable.substring(i + 1);
                    break;
                 }
             }
        }

        syllable = syllable.replace('v', 'ü');

        return syllable;
    });
}

function normalizeForComparison(text) {
    const punctRegex = /[，。！？；：,.!?;:"《》『』「」""''（）﹙﹚︹︺【】()]/g;
    return text.replace(/\s+/g, '').replace(punctRegex, '');
}

function updateSentencesPreview() {
  const zhText = document.getElementById('inputZh').value.trim();
  const trText = document.getElementById('inputTr').value.trim();
  const preview = document.getElementById('sentencesPreview');

  if (!zhText) {
    preview.textContent = '';
    preview.classList.remove('clickable');
    preview.removeEventListener('click', handlePreviewClick);
    return;
  }

  const normalizedZh = normalizeChineseText(zhText);
  const zhSentences = splitSentences(normalizedZh);

  let trSentences = [];
  if (trText) {
    trSentences = trText.split(/\s*\/\/\s*/).flatMap(part => {
      return part.split(/(?<=[.!?])\s+/g);
    }).filter(Boolean).map(s => s.trim());
  }

  preview.textContent = `${zhSentences.length} phrase(s) détectée(s)` +
    (trSentences.length > 0 ? ` • ${trSentences.length} traduction(s)` : '');

  preview.classList.add('clickable');
  preview.removeEventListener('click', handlePreviewClick);
  preview.addEventListener('click', handlePreviewClick);
}

function handlePreviewClick() {
    const zhText = document.getElementById('inputZh').value.trim();
    const trText = document.getElementById('inputTr').value.trim();
    const normalizedZh = normalizeChineseText(zhText);
    const zhSentences = splitSentences(normalizedZh);
    let trSentences = [];
    if (trText) {
        trSentences = trText.split(/\s*\/\/\s*/).flatMap(part => {
        return part.split(/(?<=[.!?])\s+/g);
        }).filter(Boolean).map(s => s.trim());
    }
    showSentencesPreviewModal(zhSentences, trSentences);
}


function switchMode(mode) {
    appMode = mode;

    document.querySelectorAll('.mode-toggle-btn').forEach(btn => btn.classList.remove('active'));

    if (mode === 'game') {
        document.getElementById('modeGameBtn').classList.add('active');
        document.getElementById('gameOptions').style.display = 'block';
        document.getElementById('readOptions').style.display = 'none';
        document.getElementById('launchText').textContent = 'Lancer le jeu';
    } else {
        document.getElementById('modeReadBtn').classList.add('active');
        document.getElementById('gameOptions').style.display = 'none';
        document.getElementById('readOptions').style.display = 'block';
        document.getElementById('launchText').textContent = 'Lancer la lecture'; // <-- C'est cette ligne qui était incorrecte
    }
}

function switchTab(tabNumber) {
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    document.getElementById(`tab${tabNumber}Btn`).classList.add('active');
    document.getElementById(`tab${tabNumber}`).classList.add('active');
}

// =====================================================
// GAME MODE FUNCTIONS
// =====================================================
function startGame() {
  const zhText = document.getElementById('inputZh').value.trim();
  if (!zhText) {
    alert('⚠️ Veuillez entrer un texte chinois.');
    return;
  }
  if (!dict || dict.wordSet.size === 0) {
      alert('⚠️ Veuillez charger un dictionnaire CC-CEDICT.');
      return;
  }
  if (!levelMap || levelMap.size === 0) {
      alert('⚠️ Veuillez charger une liste HSK/Fréquence.');
  }

  const normalizedText = normalizeChineseText(zhText);
  sentences = splitSentences(normalizedText);

  const trText = document.getElementById('inputTr').value.trim();
  if (trText) {
    translations = trText.split(/\s*\/\/\s*/).flatMap(part => {
      return part.split(/(?<=[.!?])\s+/g);
    }).filter(Boolean).map(s => s.trim());
  } else {
    translations = [];
  }

  currentGameMode = document.getElementById('gameMode').value;

// Définit les options d'affichage en fonction du mode
if (currentGameMode === 'free-input') {
    gameDisplayMode = document.getElementById('freeInputDisplayMode').value;
    showTranslation = false; // Désactive l'ancienne variable pour ce mode
} else {
    showTranslation = document.getElementById('showTranslationCheck').checked;
    gameDisplayMode = 'all'; // Réinitialise pour les autres modes
}

currentSentenceIndex = 0;

  document.getElementById('homePage').style.display = 'none';
  document.getElementById('gamePage').classList.add('active');

  loadSentence();
}

/**
 * Ajuste la taille de la police des éléments de jeu en fonction de la longueur de la phrase.
 */
function adjustFontSizeForSentenceLength() {
    const sentence = originalSentence || '';
    const length = sentence.length;

    // Éléments à redimensionner
    const translationHint = document.getElementById('translationHint');
    const typingTarget = document.getElementById('typing-target-text');
    const timeAttackTarget = document.getElementById('time-attack-target-text');
    const freeInputTarget = document.getElementById('free-input-target-text');
    
    // Tailles de police de base (prises du CSS)
    const baseTokenSize = 24; // .word-token
    const baseTokenPadding = 12; // .word-token padding vertical
    const baseHintSize = 16; /* <-- Taille mise à jour */
    const baseTypingSize = 28;
	
    // Paramètres de réduction
    const minLength = 35;  // Longueur (nb de caractères) à partir de laquelle la réduction commence
    const maxLength = 90;  // Longueur pour laquelle la réduction est maximale
    const minFactor = 0.65; // Facteur de réduction max (65% de la taille originale)

    let reductionFactor = 1.0; // 1.0 = 100% (pas de réduction)

    if (length > minLength) {
        // Calcule le ratio de réduction
        const ratio = Math.min(1, (length - minLength) / (maxLength - minLength));
        reductionFactor = 1.0 - (ratio * (1.0 - minFactor));
    }
}

function adjustInterligne(delta) {
    const min = 60; 
    const max = 150;
    const currentPercent = Math.round(readInterligne * 100);
    let newPercent = Math.max(min, Math.min(max, currentPercent + delta));
    readInterligne = newPercent / 100;

    // Mettre à jour les 3 éléments
    const toolbarSpan = document.getElementById('readLineHeight');
    const sliderSpan = document.getElementById('readInterligneValue');
    const sliderInput = document.getElementById('readInterligne_slider'); // <-- ID CORRIGÉ

    if (toolbarSpan) toolbarSpan.textContent = newPercent + '%';
    if (sliderSpan) sliderSpan.textContent = newPercent + '%';
    if (sliderInput) sliderInput.value = newPercent;
    
    applyReadStyles();
}

function adjustSpacing(delta) {
    const min = 0;
    const max = 10;
    let newPx = Math.max(min, Math.min(max, readSpacing + delta));
    readSpacing = newPx;

    // Mettre à jour les 3 éléments
    const toolbarSpan = document.getElementById('readSpacing');
    const sliderSpan = document.getElementById('readSpacingValue');
    const sliderInput = document.getElementById('readSpacing_slider'); // <-- ID CORRIGÉ

    if (toolbarSpan) toolbarSpan.textContent = newPx + 'px';
    if (sliderSpan) sliderSpan.textContent = newPx + 'px';
    if (sliderInput) sliderInput.value = newPx;
    
    applyReadStyles();
}


function applyReadStyles() {
    // Sélectionne les bons éléments même en mode flip ou super zen
    const readText = document.querySelector('#readText');
    const readTranslation = document.querySelector('#readTranslation');
    
    // Valeurs de base (depuis votre CSS)
    const baseLineHeightZh = 2.2;
    const baseLineHeightTr = 1.8;

    if (readText) {
        // Applique la taille de police principale (lue depuis les options)
        readText.style.fontSize = readFontSize + 'px';
        
        // Applique l'interligne et l'espacement
        readText.style.lineHeight = (baseLineHeightZh * readInterligne);
        readText.style.letterSpacing = readSpacing + 'px';
    }
    
    if (readTranslation) {
        // --- NOUVELLE LOGIQUE DE RATIO ---
        if (readSuperZen) {
            // En Super Zen : 70% de la taille (30% plus petit)
            readTranslation.style.fontSize = (readFontSize * 0.7) + 'px';
        } else {
            // En mode normal : 80% de la taille (l'ancien comportement)
            readTranslation.style.fontSize = (readFontSize * 0.8) + 'px';
        }
        // --- FIN DE LA NOUVELLE LOGIQUE ---

        // Applique l'interligne et l'espacement
        readTranslation.style.lineHeight = (baseLineHeightTr * readInterligne);
        readTranslation.style.wordSpacing = readSpacing + 'px';
    }
}

function loadSentence() {
hidePinyinTonePopup();
hidePinyinTonePopup();
  // === AJOUT : Réinitialiser les tailles de police des conteneurs ===
  const elementsToReset = [
      document.getElementById('translationHint'),
      document.getElementById('typing-target-text'),
      document.getElementById('time-attack-target-text'),
      document.getElementById('free-input-target-text')
  ];
  elementsToReset.forEach(el => {
      if (el) {
          el.style.fontSize = ''; // Réinitialise à la valeur CSS par défaut
      }
  });
  // La réinitialisation des tokens se fera dans createWordToken
  // === FIN AJOUT ===

  originalSentence = sentences[currentSentenceIndex];
  hintsRevealed = 0;
  currentSentenceTokens = segmentText(originalSentence, dict.wordSet, dict.maxLen);

  const resultDiv = document.getElementById('gameResult');
  const gameActions = document.querySelector('.game-actions');
  if (resultDiv && gameActions && window.innerWidth <= 900) {
    gameActions.parentNode.insertBefore(resultDiv, gameActions);
  }

  document.getElementById('sentenceCounter').textContent =
    `${currentSentenceIndex + 1} / ${sentences.length}`;

const translationHint = document.getElementById('translationHint');
const freeInputTarget = document.getElementById('free-input-target-text');

// Réinitialiser les affichages
if(translationHint) translationHint.style.display = 'none';
if(freeInputTarget) freeInputTarget.style.display = 'none';

  document.getElementById('gameResult').style.display = 'none';

  document.querySelectorAll('.game-mode-ui').forEach(el => el.style.display = 'none');

  const gameActionsEl = document.querySelector('.game-actions');
  const hintBtn = document.getElementById('hintBtn');
  const validateBtn = document.getElementById('validateBtn');
  const restartBtn = document.getElementById('restartBtn');

  if(hintBtn) hintBtn.style.display = 'none';
  if(validateBtn) validateBtn.style.display = 'none';
  if(restartBtn) restartBtn.style.display = 'none';

  if (currentGameMode === 'time-attack') {
      if(restartBtn) restartBtn.style.display = 'inline-flex';
      if(gameActionsEl) gameActionsEl.style.display = 'flex';

  } else if (currentGameMode === 'live-typing') {
      if(gameActionsEl) gameActionsEl.style.display = 'none';

  } else {
      if(hintBtn) hintBtn.style.display = 'inline-flex';
      if(validateBtn) validateBtn.style.display = 'inline-flex';
      if(gameActionsEl) gameActionsEl.style.display = 'flex';
  }

  const modeUI = document.getElementById(`${currentGameMode}-mode`);
  if (modeUI) {
      if (currentGameMode === 'reorder-drag' || currentGameMode === 'live-typing' || currentGameMode === 'time-attack' || currentGameMode.startsWith('fill-blanks')) {
          modeUI.style.display = 'flex';
      } else {
          modeUI.style.display = 'block';
      }
  } else {
    console.error(`UI pour mode ${currentGameMode} non trouvée!`);
    const fallbackUI = document.getElementById('free-input-mode') || document.getElementById('reorder-drag-mode');
     if(fallbackUI) fallbackUI.style.display = 'block';
  }

  if (currentGameMode === 'free-input' && modeUI) {
  modeUI.style.display = 'block';
}

  switch (currentGameMode) {
    case 'reorder-drag':
      initReorderMode();
	  if (window.innerWidth <= 900 && typeof resizeAvailableWords === 'function') {
    requestAnimationFrame(() => {
    resizeAvailableWords();
       setTimeout(resizeAvailableWords, 150);
  });
}
      break;
case 'free-input':
  initFreeMode();
  // Logique d'affichage spécifique pour Saisie Libre
  switch (gameDisplayMode) {
    case 'all':
      if (translations[currentSentenceIndex]) {
        translationHint.textContent = translations[currentSentenceIndex];
        translationHint.style.display = 'block';
      }
      freeInputTarget.textContent = originalSentence;
      freeInputTarget.style.display = 'block';
      break;
    case 'translation_only':
      if (translations[currentSentenceIndex]) {
        translationHint.textContent = translations[currentSentenceIndex];
        translationHint.style.display = 'block';
      }
      // freeInputTarget reste 'none'
      break;
    case 'chinese_only':
      // translationHint reste 'none'
      freeInputTarget.textContent = originalSentence;
      freeInputTarget.style.display = 'block';
      break;
  }
  break;
    case 'live-typing':
      initLiveTypingMode();
      break;
    case 'time-attack':
       initLiveTypingMode(true);
      break;
    case 'fill-blanks-char':
      initFillBlanksMode(false);
      break;
    case 'fill-blanks-pinyin':
      initFillBlanksMode(true);
      break;
  }

  document.getElementById('prevSentenceBtn').disabled = currentSentenceIndex === 0;
  document.getElementById('nextSentenceBtn').disabled = currentSentenceIndex === sentences.length - 1;

resetLiveStats(); // Réinitialise les valeurs affichées

  const statsGrid = document.querySelector('.stats-grid');
  if (statsGrid) { // Vérifier si l'élément existe
    if (currentGameMode === 'live-typing' || currentGameMode === 'time-attack') {
      statsGrid.style.display = 'grid'; // Afficher pour les modes frappe
    } else {
      statsGrid.style.display = 'none'; // Cacher pour tous les autres modes
    }
  } else {
      console.error("Stats grid element not found!"); // Message d'erreur si l'élément n'est pas trouvé
  }

  checkAndResizeFonts();

  const inputElement = document.querySelector(`#${currentGameMode}-mode input, #${currentGameMode}-mode textarea`);
  if (inputElement) {
      setTimeout(() => inputElement.focus(), 50);
  }


  adjustFontSizeForSentenceLength();
if (currentGameMode !== 'free-input' && currentGameMode !== 'time-attack' && showTranslation && translations[currentSentenceIndex]) {
    translationHint.textContent = translations[currentSentenceIndex];
    translationHint.style.display = 'block';
  }

  startGameTimer();
}

function initReorderMode() {
  const words = currentSentenceTokens.filter(t => (t.type === 'word' || t.type === 'punc') && !/\s/.test(t.text)).map(t => t.text);
  const shuffled = [...words].sort(() => Math.random() - 0.5);

  const availableWords = document.getElementById('availableWords');
  const userSentence = document.getElementById('userSentence');

  availableWords.innerHTML = '';
  userSentence.innerHTML = '';

  shuffled.forEach(word => {
    const token = createWordToken(word);
    availableWords.appendChild(token);
  });

  setupDragAndDrop();
  
  // === AJOUT : Appeler l'ajustement ICI ===
  // Cela garantit que la police est redimensionnée dès que les tokens sont créés.
  adjustFontSizeForSentenceLength();
  observeAvailableWords();
requestAnimationFrame(resizeAvailableWords);

}

function createWordToken(word) {
    const token = document.createElement('div');
    token.className = 'word-token';
    token.textContent = word;
    token.draggable = true;
    // === AJOUT : Réinitialiser le style ici ===
    token.style.fontSize = ''; // Utilise la taille CSS par défaut
    token.style.padding = ''; // Utilise le padding CSS par défaut
    // === FIN AJOUT ===
    return token;
 }

function setupDragAndDrop() {
    const containers = [document.getElementById('availableWords'), document.getElementById('userSentence')];
    
    // 1. Nettoie et attache les écouteurs sur les mots (tokens)
    document.querySelectorAll('.word-token').forEach(token => {
        // Nettoyage avec les BONNES références de fonction
        token.removeEventListener('dragstart', dnd_handleDragStart);
        token.removeEventListener('dragend', dnd_handleDragEnd);
        token.removeEventListener('touchstart', dnd_handleTouchStart);
        token.removeEventListener('touchmove', dnd_handleTouchMove);
        token.removeEventListener('touchend', dnd_handleTouchEnd);
        token.removeEventListener('click', dnd_handleTokenClick);

        // Attachement
        token.addEventListener('dragstart', dnd_handleDragStart);
        token.addEventListener('dragend', dnd_handleDragEnd);
        token.addEventListener('touchstart', dnd_handleTouchStart, { passive: false });
        token.addEventListener('touchmove', dnd_handleTouchMove, { passive: false });
        token.addEventListener('touchend', dnd_handleTouchEnd);
        token.addEventListener('click', dnd_handleTokenClick);
    });

    // 2. Nettoie et attache les écouteurs sur les conteneurs
    containers.forEach(container => {
        // Nettoyage avec les BONNES références de fonction
        container.removeEventListener('dragover', dnd_handleDragOver);
        container.removeEventListener('dragleave', dnd_handleDragLeave);
        container.removeEventListener('drop', dnd_handleDrop);

        // Attachement
        container.addEventListener('dragover', dnd_handleDragOver);
        container.addEventListener('dragleave', dnd_handleDragLeave);
        container.addEventListener('drop', dnd_handleDrop);
    });
}


function initFreeMode() {
  const freeInput = document.getElementById('freeInput');
  freeInput.value = '';

  freeInput.onkeydown = null;
  freeInput.onkeydown = (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          validateAnswer();
      }
  };
}

function initLiveTypingMode(isTimeAttack = false) {
    const targetText = originalSentence.replace(/[,\s]/g, '');
    const targetElId = isTimeAttack ? 'time-attack-target-text' : 'typing-target-text';
    const inputElId = isTimeAttack ? 'time-attack-input' : 'typing-input';
    const translationElId = isTimeAttack ? 'time-attack-translation' : null;

    const targetEl = document.getElementById(targetElId);
    const inputEl = document.getElementById(inputElId);

    if (!targetEl || !inputEl) {
        console.error("Missing elements for live typing mode:", targetElId, inputElId);
        return;
    }

    inputEl.disabled = false;

    targetEl.innerHTML = '';
    inputEl.value = '';
    inputEl.maxLength = targetText.length;
    inputEl.style.borderColor = '';

    targetText.split('').forEach((char, index) => {
        const span = document.createElement('span');
        span.textContent = char;
        if (index === 0) span.className = 'char-current';
        targetEl.appendChild(span);
    });

    if (isTimeAttack && translationElId) {
         const translationEl = document.getElementById(translationElId);
         if (translationEl) {
             if (translations[currentSentenceIndex]) {
                translationEl.textContent = translations[currentSentenceIndex];
                translationEl.style.display = 'block';
             } else {
                 translationEl.style.display = 'none';
             }
         }
    } else if (translationElId) {
        const translationEl = document.getElementById(translationElId);
        if(translationEl) translationEl.style.display = 'none';
    }

    document.getElementById('statChars').textContent = `0/${targetText.length}`;

    if (isTimeAttack) {
        // Cette logique est seulement pour l'affichage initial de l'objectif, pas le timer
        const targetCPM = parseInt(document.getElementById('cpmAttackTarget').value, 10);
        const targetTime = Math.ceil((targetText.length / targetCPM) * 60);
        document.getElementById('statTime').textContent = `0s / ${targetTime}s`;
    }

     targetEl.onclick = () => inputEl.focus();
     if(translationElId) {
         const translationEl = document.getElementById(translationElId);
         if (translationEl) translationEl.onclick = () => inputEl.focus();
     }

    let isComposing = false;

    inputEl.oninput = () => {
        if (!isComposing) {
            handleLiveTyping(targetText, targetElId, inputElId, isTimeAttack);
        }
    };

    inputEl.removeEventListener('compositionstart', handleCompositionStart);
    inputEl.removeEventListener('compositionend', handleCompositionEnd);

    function handleCompositionStart() {
        isComposing = true;
    }

    function handleCompositionEnd() {
        isComposing = false;
        handleLiveTyping(targetText, targetElId, inputElId, isTimeAttack);
    }

    inputEl.addEventListener('compositionstart', handleCompositionStart);
    inputEl.addEventListener('compositionend', handleCompositionEnd);

    inputEl.onkeydown = null;
    inputEl.onkeydown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();

            if (isComposing) return;
			
			if (inputEl) inputEl.blur();

            const typedText = inputEl.value;
            const targetSpans = targetEl.querySelectorAll('span');
            let errors = 0;

            targetSpans.forEach((span, index) => {
                if (index < typedText.length && typedText[index] !== targetSpans[index].textContent) {
                    errors++;
                }
            });

            if (typedText.length !== targetText.length) {
                 showResult(false, '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Phrase non terminée.');
                 setTimeout(() => { document.getElementById('gameResult').style.display = 'none'; }, 2000);
                 return;
            }

            if (errors === 0) {
                // --- CORRECTION (Ligne 1549) ---
                // On arrête le timer dans les DEUX modes (Time Attack ET Frappe Directe)
                stopGameTimer();
                // --- FIN CORRECTION ---

                showResult(true, '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg> Correct !');
                inputEl.blur();
                setTimeout(() => {
                    if (currentSentenceIndex < sentences.length - 1) {
                        goToSentence(1);
                    } else {
                        showGameResults();
                    }
                }, 1500);
            } else {
                 showResult(false, `<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Incorrect (${errors} erreur(s)).`);
                 setTimeout(() => { document.getElementById('gameResult').style.display = 'none'; }, 2000);
            }
        }
    };
}

function handleLiveTyping(targetText, targetElId, inputElId, isTimeAttack = false) {
    const inputEl = document.getElementById(inputElId);
    const targetEl = document.getElementById(targetElId);
     if (!inputEl || !targetEl) return;
    const targetSpans = targetEl.querySelectorAll('span');
    const typedText = inputEl.value;
    let errors = 0;
    let correctChars = 0;

    targetSpans.forEach((span, index) => {
        const typedChar = typedText[index];
        const targetChar = span.textContent;

        if (typedChar == null) {
            span.className = (index === typedText.length) ? 'char-current' : '';
        } else if (typedChar === targetChar) {
            span.className = 'char-correct';
            correctChars++;
        } else {
            span.className = 'char-incorrect';
            errors++;
        }
    });

    const accuracy = typedText.length > 0 ? Math.max(0, ((correctChars) / typedText.length) * 100) : 0;
    document.getElementById('statErrors').textContent = errors;
    document.getElementById('statAccuracy').textContent = `${accuracy.toFixed(0)}%`;
    document.getElementById('statChars').textContent = `${typedText.length}/${targetText.length}`;

    if (typedText.length === targetText.length) {
         if (errors === 0) {
            inputEl.style.borderColor = 'var(--correct)';
        } else {
            inputEl.style.borderColor = 'var(--incorrect)';
        }
    } else {
         inputEl.style.borderColor = 'var(--border)';
         if (document.activeElement === inputEl) {
             inputEl.style.borderColor = 'var(--accent)';
         }
    }
}

function initFillBlanksMode(isPinyin = false) {
  const displayElId = isPinyin ? 'blanks-display-text-pinyin' : 'blanks-display-text-char';
  const inputElId = isPinyin ? 'blanks-input-pinyin' : 'blanks-input-char';
  const displayEl = document.getElementById(displayElId);
  const inputEl = document.getElementById(inputElId);
  const mcqContainer = document.getElementById('pinyin-mcq-options'); // Nouveau

  const showPinyinHint = document.getElementById('showPinyinHintCheck').checked;
  // --- NOUVEAU: Lire le type de saisie ---
  pinyinInputType = isPinyin ? document.getElementById('pinyinInputType').value : 'keyboard';

   if (!displayEl || (!inputEl && pinyinInputType === 'keyboard') || (!mcqContainer && pinyinInputType === 'mcq')) {
        console.error("Missing elements for fill blanks mode:", displayElId, inputElId, mcqContainer);
        return;
    }

  displayEl.innerHTML = '';
  if (inputEl) inputEl.value = '';
  if (mcqContainer) mcqContainer.innerHTML = ''; // Vider les options MCQ
  currentBlankIndex = 0;
  fillBlanksData = [];

  // --- Afficher/Cacher les contrôles ---
  if (isPinyin) {
    if (pinyinInputType === 'keyboard') {
      if(inputEl) inputEl.style.display = 'block';
      if(mcqContainer) mcqContainer.style.display = 'none';
    } else { // mcq
      if(inputEl) inputEl.style.display = 'none';
      if(mcqContainer) mcqContainer.style.display = 'flex'; // Utiliser flex pour l'affichage
    }
  } else {
      // Pour le mode caractère, toujours afficher l'input
      if(inputEl) inputEl.style.display = 'block';
      if(mcqContainer) mcqContainer.style.display = 'none';
  }

  const gameCategory = document.querySelector('#gameCategorySelector .category-btn.active')?.dataset.category || 'hsk';
  const selectorId = gameCategory === 'hsk' ? '#gameHskSelector' : '#gameFreqSelector';
  const levelsToHide = new Set();
  document.querySelectorAll(`${selectorId} .hsk-selector-btn.active`).forEach(btn => {
      levelsToHide.add(parseInt(btn.dataset.level));
  });

  let blankCounter = 0;
  if (!currentSentenceTokens || currentSentenceTokens.length === 0) {
       displayEl.textContent = "(Aucun texte à afficher)";
       return;
  }

  currentSentenceTokens.forEach(token => {
      if (token.type === 'word') {
          const level = getLevel(token.text, gameCategory);
          if (level > 0 && levelsToHide.has(level)) {
              const blank = document.createElement('span');
              blank.className = 'blank-space';

              // --- Logique d'affichage de l'indice (inchangée) ---
              if (isPinyin && showPinyinHint) {
                  // --- MODIFIÉ: Envelopper chaque caractère dans un span pour le ciblage MCQ ---
                  blank.innerHTML = ''; // Vider d'abord
                  token.text.split('').forEach((char, charIdx) => {
                      const charSpan = document.createElement('span');
                      charSpan.textContent = char;
                      charSpan.dataset.charIndex = charIdx; // Stocker l'index du caractère
                      blank.appendChild(charSpan);
                  });
                  blank.classList.add('blank-with-hint');
              } else {
                  blank.textContent = '_'.repeat(token.text.length);
              }
              // --- Fin de la modif interne pour l'indice ---

              blank.dataset.index = blankCounter; // Index du mot blanc
              blank.dataset.word = token.text;    // Mot chinois correct
              
              // ==========================================================
              // DÉBUT DE LA LOGIQUE PINYIN CORRIGÉE (RÉSOUT LE CRASH)
              // ==========================================================
              let pinyins = [];
              let entries = dict.entries.get(token.text); // Récupère le tableau d'entrées

              // 1. Tri des entrées si c'est un polyphone connu (ex: "着")
              if (entries && entries.length > 1 && token.text.length === 1 && POLYPHONE_FREQ_MAP.has(token.text)) {
                const freqList = POLYPHONE_FREQ_MAP.get(token.text);
                const freqMap = new Map();
                freqList.forEach((p, index) => { if (!freqMap.has(p)) freqMap.set(p, index); });

                // Tri sur une COPIE pour ne pas affecter le dictionnaire global
                entries = [...entries].sort((a, b) => {
                  const pinyinA = numericToDiacriticPinyin(a.pinyin);
                  const pinyinB = numericToDiacriticPinyin(b.pinyin);
                  const scoreA = freqMap.has(pinyinA) ? freqMap.get(pinyinA) : 99;
                  const scoreB = freqMap.has(pinyinB) ? freqMap.get(pinyinB) : 99;
                  return scoreA - scoreB;
                });
                // 'entries' est maintenant un NOUVEAU tableau trié localement
                // (ex: pour "着", entries[0] sera l'entrée 'zhe')
              }
              
              // 2. Récupérer la première entrée (la plus fréquente ou celle par défaut)
              //    C'EST LE CORRECTIF PRINCIPAL DU CRASH
              const firstEntry = (entries && entries.length > 0) ? entries[0] : null;

              // 3. Gérer les mots (ex: "屏幕") vs les caractères (ex: "着")
              if (firstEntry && token.text.length > 1) {
                // CAS A: C'est un mot de plusieurs caractères (ex: "屏幕")
                // On utilise la prononciation du mot complet
                const pinyinParts = firstEntry.pinyin.split(' ');
                pinyins = pinyinParts.map(p => p ? numericToDiacriticPinyin(p).toLowerCase() : '');
              } else {
                // CAS B: C'est un mot d'un seul caractère (ex: "着")
                // OU un mot qui n'est pas dans le dictionnaire (ex: "刘哲")
                // On fait un fallback caractère par caractère
                pinyins = token.text.split('').map(char => {
                  let charEntries = dict.entries.get(char); // Récupère les entrées pour ce caractère
                  
                  // Tri par fréquence pour ce caractère individuel
                  if (charEntries && charEntries.length > 1 && POLYPHONE_FREQ_MAP.has(char)) {
                    const freqList = POLYPHONE_FREQ_MAP.get(char);
                    const freqMap = new Map();
                    freqList.forEach((p, index) => { if (!freqMap.has(p)) freqMap.set(p, index); });
                    
                    charEntries = [...charEntries].sort((a, b) => {
                      const pinyinA = numericToDiacriticPinyin(a.pinyin);
                      const pinyinB = numericToDiacriticPinyin(b.pinyin);
                      const scoreA = freqMap.has(pinyinA) ? freqMap.get(pinyinA) : 99;
                      const scoreB = freqMap.has(pinyinB) ? freqMap.get(pinyinB) : 99;
                      return scoreA - scoreB;
                    });
                  }
                  
                  // On prend la première prononciation (la plus fréquente ou celle par défaut)
                  const firstCharEntry = (charEntries && charEntries.length > 0) ? charEntries[0] : null;
                  const pinyinRaw = firstCharEntry ? firstCharEntry.pinyin.split(' ')[0] : '';
                  return pinyinRaw ? numericToDiacriticPinyin(pinyinRaw).toLowerCase() : '';
                });
              }
              
              // Vérifier que le nombre de pinyins correspond au nombre de caractères
              if (pinyins.length !== token.text.length) {
                   console.warn(`Incohérence Pinyin/Caractère pour "${token.text}". Pinyins: ${pinyins.join(',')}. Attendu: ${token.text.length}. Fallback.`);
                   // Fallback (ancien comportement) si la paires pinyin/char ne correspond pas
                   pinyins = token.text.split('').map(char => {
                      const entry = dict.entries.get(char);
                      // Prend la PREMIÈRE prononciation (non triée)
                      const pinyinRaw = (entry && entry.length > 0) ? entry[0].pinyin.split(' ')[0] : '';
                      return pinyinRaw ? numericToDiacriticPinyin(pinyinRaw).toLowerCase() : '';
                   });
              }
              
              const pinyinsStr = pinyins.join(',');
              // --- FIN DE LA NOUVELLE LOGIQUE ---
              // ==========================================================

              blank.dataset.index = blankCounter; // Index du mot blanc
              blank.dataset.word = token.text;    // Mot chinois correct
              blank.dataset.pinyins = pinyinsStr; // <--- Utiliser pinyinsStr


              blank.onclick = () => focusBlank(blankCounter);
              displayEl.appendChild(blank);

              fillBlanksData.push({
                  element: blank,
                  originalWord: token.text,
                  isPinyin: isPinyin,
                  pinyinAnswers: pinyins, // <--- Utiliser le tableau pinyins
                  status: 'pending',
                  currentCharIndex: 0, // Pour le mode MCQ
                  selectedPinyins: [] // Pour stocker les sélections MCQ
              });
              blankCounter++;
          } else {
              displayEl.appendChild(document.createTextNode(token.text));
          }
      } else {
          displayEl.appendChild(document.createTextNode(token.text));
      }
      displayEl.appendChild(document.createTextNode(' ')); // Espace après chaque token
  });

  // Ajuster l'espacement final (supprimer le dernier espace ajouté)
  if (displayEl.lastChild && displayEl.lastChild.nodeType === Node.TEXT_NODE && displayEl.lastChild.textContent.endsWith(' ')) {
      displayEl.lastChild.textContent = displayEl.lastChild.textContent.slice(0, -1);
  }


  focusBlank(0); // Met le focus sur le premier trou

  // --- Enlever/Ajouter le listener clavier ---
  if (inputEl) {
      inputEl.onkeydown = null; // Enlever l'ancien listener
	  inputEl.onblur = hidePinyinTonePopup;
      if (isPinyin && pinyinInputType === 'keyboard') {
          // Remettre le listener SEULEMENT si mode clavier Pinyin
          inputEl.onkeydown = (e) => {
              if (e.key === 'Enter') {
                  e.preventDefault();
                  validateBlank(true); // Valider pour le mode clavier
              } else if (window.innerWidth > 600) { // Condition écran large inchangée
                  handlePinyinInput(e);
              }
          };
      } else if (!isPinyin) {
          // Remettre le listener pour le mode caractère
           inputEl.onkeydown = (e) => {
               if (e.key === 'Enter') {
                  e.preventDefault();
                  validateBlank(false); // Valider pour le mode caractère
              }
           }
      }
  } 
}

function focusBlank(index) {
hidePinyinTonePopup();
    if (index < 0 || index >= fillBlanksData.length) return;

    // --- Enlever le focus visuel de l'ancien blank ---
    if (fillBlanksData[currentBlankIndex] && fillBlanksData[currentBlankIndex].element) {
        fillBlanksData[currentBlankIndex].element.classList.remove('current-blank');
        // Enlever la surbrillance du caractère actif précédent
        const prevActiveChar = fillBlanksData[currentBlankIndex].element.querySelector('.active-char-hint');
        if (prevActiveChar) prevActiveChar.classList.remove('active-char-hint');
    }

    currentBlankIndex = index;
    const currentData = fillBlanksData[currentBlankIndex];

    if (!currentData || !currentData.element) return;

    // --- Gérer la réinitialisation si on clique sur un mot déjà rempli ---
    if (currentData.status !== 'pending') {
        currentData.status = 'pending';
        currentData.currentCharIndex = 0; // Réinitialiser l'index caractère
        currentData.selectedPinyins = []; // Vider les sélections

        // Réafficher l'indice ou les underscores
        const showPinyinHint = document.getElementById('showPinyinHintCheck').checked;
        if (currentData.isPinyin && showPinyinHint) {
            // Recréer les spans caractères pour l'indice
            currentData.element.innerHTML = ''; // Vider
            currentData.originalWord.split('').forEach((char, charIdx) => {
                const charSpan = document.createElement('span');
                charSpan.textContent = char;
                charSpan.dataset.charIndex = charIdx;
                currentData.element.appendChild(charSpan);
            });
            currentData.element.classList.add('blank-with-hint');
        } else {
            currentData.element.textContent = '_'.repeat(currentData.originalWord.length);
        }
        currentData.element.classList.remove('filled-blank-correct', 'filled-blank-incorrect');
        currentData.element.classList.remove('blank-with-hint'); // Assurer que ce style est enlevé si showHint est off
         if (currentData.isPinyin && showPinyinHint) { // Le remettre si showHint est on
             currentData.element.classList.add('blank-with-hint');
         }
    }

    // --- Appliquer le focus visuel sur le mot ---
    currentData.element.classList.add('current-blank');

    // --- Gérer la saisie (Clavier vs MCQ) ---
    if (currentData.isPinyin && pinyinInputType === 'keyboard') {
        const inputEl = document.getElementById('blanks-input-pinyin');
        if (inputEl) {
             setTimeout(() => { // Timeout pour assurer le focus
                 inputEl.focus();
                 inputEl.value = '';
             }, 0);
        }
    } else if (currentData.isPinyin && pinyinInputType === 'mcq') {
        // --- Mode MCQ ---
        currentData.currentCharIndex = 0; // Toujours commencer au premier caractère quand on focus un mot
        currentData.selectedPinyins = []; // Vider les sélections précédentes pour ce mot
        generateAndDisplayPinyinOptions(); // Génère les options pour le premier caractère
    } else { // Mode caractère
        const inputEl = document.getElementById('blanks-input-char');
        if (inputEl) {
            setTimeout(() => {
                 inputEl.focus();
                 inputEl.value = '';
             }, 0);
        }
    }
}

function validateBlank(isPinyin) {
hidePinyinTonePopup();
    if (currentBlankIndex >= fillBlanksData.length) return;

    const currentData = fillBlanksData[currentBlankIndex];
    if (!currentData || !currentData.element) return;

    // --- 1. Récupération des inputs ---
    const inputElId = isPinyin ? 'blanks-input-pinyin' : 'blanks-input-char';
    const inputEl = document.getElementById(inputElId);
    if (!inputEl) return;
	
	if (inputEl) inputEl.blur();

    const userAnswer = inputEl.value.trim();
    let isCorrect = false;

    if (isPinyin) {
        // --- Mode Pinyin (Pinyin avec tons attendu) ---
        
        // 1a. Construire la chaîne Pinyin correcte attendue (avec tons diacritiques)
        // Les pinyins dans currentData.pinyinAnswers sont déjà en diacritiques (e.g., nǐ, hǎo)
        const correctPinyinDiacritic = currentData.pinyinAnswers.join('');
        
        // 1b. Normaliser les deux chaînes pour une comparaison (retirer espaces et mettre en minuscule)
        const userNoSpace = userAnswer.toLowerCase().replace(/\s+/g, '');
        const correctNoSpace = correctPinyinDiacritic.toLowerCase().replace(/\s+/g, '');
        
        // 1c. Comparaison
        isCorrect = userNoSpace === correctNoSpace;

        // Si la comparaison directe échoue, tentons une comparaison alternative
        // au cas où l'utilisateur aurait saisi le caractère Hanzi.
        if (!isCorrect) {
             const hanziAnswer = currentData.originalWord;
             isCorrect = userAnswer === hanziAnswer;
        }

    } else {
        // --- Mode Caractères (Hanzi attendu) ---
        const correctAnswer = currentData.originalWord;
        isCorrect = userAnswer === correctAnswer;
    }
    
    // --- 2. Mise à jour de l'UI et progression ---

    // Retirer le focus visuel, même si c'est incorrect
    currentData.element.classList.remove('current-blank'); 

    if (isCorrect) {
        currentData.element.textContent = currentData.originalWord;
        currentData.element.classList.add('filled-blank-correct');
        currentData.status = 'correct';
        
        // Vider le champ d'entrée
        inputEl.value = '';

        // Trouver le prochain trou non rempli
        let nextIndex = currentBlankIndex + 1;
        while(nextIndex < fillBlanksData.length && fillBlanksData[nextIndex].status !== 'pending') {
            nextIndex++;
        }
        
        if (nextIndex < fillBlanksData.length) {
            focusBlank(nextIndex);
        } else {
            // Fin de la phrase
            inputEl.blur();
            showResult(true, '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg> Phrase complétée !');
            setTimeout(() => {
              if (currentSentenceIndex < sentences.length - 1) {
                goToSentence(1);
              } else {
                showGameResults();
              }
            }, 1500);
        }
    } else {
        // --- Réponse incorrecte ---
        const errorMsg = isPinyin ? "Pinyin incorrect. Essayez encore !" : "Mot incorrect. Essayez encore !";
showResult(false, '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> ' + errorMsg);
        
        // Afficher le résultat temporairement
        setTimeout(() => {
            const resultDiv = document.getElementById('gameResult');
            if (resultDiv) resultDiv.style.display = 'none';
        }, 2000);

        // Réinitialiser le trou pour la prochaine tentative
        focusBlank(currentBlankIndex); 
        inputEl.value = ''; // Vider le champ
    }
}

function handlePinyinInput(event) {
    const inputEl = event.target;
    const vowelRegex = /[aeiouüv]/i;
    const key = event.key;
    const isPopupVisible = document.getElementById('pinyinTonePopup').style.display === 'block';

    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Backspace', 'Delete', 'Enter', 'Tab', 'Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Escape'].includes(key)) {
        hidePinyinTonePopup();
        pinyinInputBuffer = '';
        return;
    }

    if (isPopupVisible && (['1','2','3','4','5','&','é','"','\'','('].includes(key) || key === ' ')) {
        event.preventDefault();
        let tone = 0;
        switch(key) {
            case '1': case '&': tone = 1; break;
            case '2': case 'é': tone = 2; break;
            case '3': case '"': tone = 3; break;
            case '4': case '\'': tone = 4; break;
            case '5': case '(': tone = 5; break;
            case ' ': tone = 5; break;
        }

        const pinyinWithTone = applyToneToVowel(pinyinInputBuffer, tone);
        insertAtCursor(inputEl, pinyinWithTone);
        hidePinyinTonePopup();
        pinyinInputBuffer = '';
    }
    else if (!isPopupVisible && vowelRegex.test(key) && !event.ctrlKey && !event.altKey && !event.metaKey && key.length === 1) {
        pinyinInputBuffer = key;
        showPinyinTonePopup(inputEl, key);
        event.preventDefault();
    }
    else if (isPopupVisible && key.length === 1) {
         insertAtCursor(inputEl, pinyinInputBuffer);
         hidePinyinTonePopup();
         pinyinInputBuffer = '';
    }
     else if (key.length > 1) {
         event.preventDefault();
     }
}

// =====================================================
// NOUVELLES FONCTIONS POUR PINYIN MCQ
// =====================================================

function generateAndDisplayPinyinOptions() {
    const mcqContainer = document.getElementById('pinyin-mcq-options');
    if (!mcqContainer || pinyinInputType !== 'mcq') return;

    mcqContainer.innerHTML = ''; // Vider les anciennes options
    const currentData = fillBlanksData[currentBlankIndex];
    if (!currentData || currentData.status !== 'pending') return;

    const word = currentData.originalWord;
    const charIndex = currentData.currentCharIndex;

    if (charIndex >= word.length) {
        console.warn("Tentative de générer des options au-delà de la fin du mot.");
        return;
    }

    const character = word[charIndex];
    const correctPinyinWithTone = currentData.pinyinAnswers[charIndex];

    if (!correctPinyinWithTone) {
        console.error(`Pinyin introuvable pour le caractère '${character}' du mot '${word}'`);
        mcqContainer.textContent = "Erreur Pinyin";
        return;
    }

    // Génère les options DANS L'ORDRE 1, 2, 3, 4, 5
    const options = generatePinyinVariations(correctPinyinWithTone);

    // --- CETTE LIGNE EST SUPPRIMÉE ---
    // options.sort(() => Math.random() - 0.5); // <-- SUPPRIMER CETTE LIGNE DE MÉLANGE

    // Affiche les options dans l'ordre reçu
    options.forEach(pinyin => {
        const btn = document.createElement('button');
        btn.className = 'pinyin-option-btn';
        btn.textContent = pinyin;
        btn.onclick = () => handlePinyinOptionClick(pinyin);
        mcqContainer.appendChild(btn);
    });

    // Mettre en évidence le caractère actif dans l'indice
    highlightActiveHintChar(currentData.element, charIndex);
}

function highlightActiveHintChar(blankElement, charIndex) {
    // Enlever la surbrillance précédente dans ce mot
    blankElement.querySelectorAll('.active-char-hint').forEach(span => span.classList.remove('active-char-hint'));

    // Trouver et surligner le nouveau caractère actif (s'il existe)
    const charSpan = blankElement.querySelector(`span[data-char-index="${charIndex}"]`);
    if (charSpan) {
        charSpan.classList.add('active-char-hint');
    }
}

function generatePinyinVariations(correctPinyinWithTone) {
    // 1. Validation de l'entrée (inchangée)
    if (!correctPinyinWithTone || correctPinyinWithTone.trim() === '') {
        console.error("generatePinyinVariations a reçu un pinyin vide ou invalide:", correctPinyinWithTone);
        return ['?', '?', '?', '?', '?'];
    }
    correctPinyinWithTone = correctPinyinWithTone.toLowerCase();

    // 2. Extraire la syllabe de base (inchangée)
    let basePinyin = '';
    const baseVowels = {
        'āáǎà': 'a', 'ēéěè': 'e', 'īíǐì': 'i', 'ōóǒò': 'o', 'ūúǔù': 'u', 'ǖǘǚǜü': 'v'
    };
    let foundVowelWithTone = false;
    for (let i = 0; i < correctPinyinWithTone.length; i++) {
        let char = correctPinyinWithTone[i];
        let baseVowelFound = false;
        for (const accentedChars in baseVowels) {
            if (accentedChars.includes(char)) {
                basePinyin += baseVowels[accentedChars];
                baseVowelFound = true;
                foundVowelWithTone = true;
                break;
            }
        }
        if (!baseVowelFound) {
            basePinyin += char;
        }
    }
    basePinyin = basePinyin.replace(/v/g, 'ü');
    if (!foundVowelWithTone) {
        basePinyin = correctPinyinWithTone.replace(/[1-5]/g, '');
    }
    const vowelRegex = /[aeiouü]/i;
    if (!basePinyin || !vowelRegex.test(basePinyin)) {
         console.warn("N'a pas pu déterminer une base pinyin valide pour:", correctPinyinWithTone, "-> Base dérivée:", basePinyin);
          if (!vowelRegex.test(basePinyin)) {
             // Si la base est invalide, on ne peut pas générer les tons dans l'ordre
             // Retournons 5 fois le pinyin original (ou des '?') pour éviter une erreur
             const fallbackOption = correctPinyinWithTone || '?';
             return [fallbackOption, fallbackOption, fallbackOption, fallbackOption, fallbackOption];
          }
    }

    // --- MODIFICATION ICI ---
    // 3. Générer les 5 variations de tons DANS L'ORDRE [1, 2, 3, 4, 5]
    const result = [];
    const tones = [1, 2, 3, 4, 5]; // Ordre fixe

    tones.forEach(toneNum => {
        // Re-remplacer ü par v pour numericToDiacriticPinyin
        const pinyinNum = basePinyin.replace(/ü/g, 'v') + toneNum;
        result.push(numericToDiacriticPinyin(pinyinNum).toLowerCase());
    });
    // --- FIN DE LA MODIFICATION ---

    // 4. Pas besoin de Set, de compléter ou de mélanger
    // console.log("Options générées pour", correctPinyinWithTone, ":", result); // Pour débogage
    return result; // Retourne directement le tableau ordonné
}

function handlePinyinOptionClick(selectedPinyin) {
    const currentData = fillBlanksData[currentBlankIndex];
    if (!currentData || currentData.status !== 'pending') return;

    const charIndex = currentData.currentCharIndex;

    // 1. Enregistrer le choix et avancer
    currentData.selectedPinyins[charIndex] = selectedPinyin;
    currentData.currentCharIndex++;

    // 2. Vérifier si le MOT est terminé
    if (currentData.currentCharIndex >= currentData.originalWord.length) {
        // --- MOT COMPLET ---
        // 2a. Valider le mot
        let isWordCorrect = true;
        for (let i = 0; i < currentData.originalWord.length; i++) {
            if (currentData.selectedPinyins[i] !== currentData.pinyinAnswers[i]) {
                isWordCorrect = false;
                break;
            }
        }

        // 2b. Gérer la réponse
        if (isWordCorrect) {
            // --- MOT CORRECT ---
            currentData.status = 'correct';
            currentData.element.classList.remove('current-blank');
            currentData.element.classList.add('filled-blank-correct');
            currentData.element.innerHTML = currentData.originalWord; // Afficher le mot chinois
            currentData.element.classList.remove('blank-with-hint');

            // 2c. Trouver le prochain mot
            let nextBlankIndex = currentBlankIndex + 1;
            while (nextBlankIndex < fillBlanksData.length && fillBlanksData[nextBlankIndex].status !== 'pending') {
                nextBlankIndex++;
            }

            if (nextBlankIndex < fillBlanksData.length) {
                focusBlank(nextBlankIndex); // Passer au mot suivant
            } else {
                // --- PHRASE COMPLÈTE ---
                document.getElementById('pinyin-mcq-options').innerHTML = ''; // Vider les options
                const allWordsCorrect = fillBlanksData.every(data => data.status === 'correct');
                const mcqMessage = allWordsCorrect ? '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg> Phrase complétée !' : '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Phrase complétée (avec des erreurs).';
showResult(allWordsCorrect, mcqMessage);
                
                setTimeout(() => {
                    if (currentSentenceIndex < sentences.length - 1) {
                        goToSentence(1);
                    } else {
                        showGameResults(); // Fin du jeu
                    }
                }, 2000);
            }
        } else {
            // --- MOT INCORRECT ---
            currentData.status = 'incorrect'; // Statut temporaire
            currentData.element.classList.remove('current-blank');
            currentData.element.classList.add('filled-blank-incorrect'); // Appliquer le style rouge (modifié)
            
            // Afficher le mot chinois (incorrect) pour voir l'erreur
            currentData.element.innerHTML = currentData.originalWord;
            currentData.element.classList.remove('blank-with-hint');

            // Vider les options QCM pour montrer l'erreur
            document.getElementById('pinyin-mcq-options').innerHTML = ''; 

            // 2d. Réinitialiser le mot après un délai
            setTimeout(() => {
                currentData.element.classList.remove('filled-blank-incorrect'); // Retirer le rouge
                
                // Ré-afficher l'indice (les caractères chinois)
                const showPinyinHint = document.getElementById('showPinyinHintCheck').checked;
                if (showPinyinHint) {
                    currentData.element.innerHTML = ''; // Vider
                    currentData.originalWord.split('').forEach((char, charIdx) => {
                        const charSpan = document.createElement('span');
                        charSpan.textContent = char;
                        charSpan.dataset.charIndex = charIdx;
                        currentData.element.appendChild(charSpan);
                    });
                    currentData.element.classList.add('blank-with-hint');
                } else {
                    currentData.element.textContent = '_'.repeat(currentData.originalWord.length);
                }

                currentData.element.classList.add('current-blank'); // Remettre en focus
                currentData.status = 'pending'; // Prêt pour nouvel essai
                currentData.currentCharIndex = 0; // Recommencer au 1er caractère
                currentData.selectedPinyins = []; // Vider les sélections
                
                // Regénérer les options pour le 1er caractère
                generateAndDisplayPinyinOptions(); 
            }, 1500); // 1.5s pour voir l'erreur
        }
    } else {
        // --- PASSER AU CARACTÈRE SUIVANT DU MÊME MOT ---
        // Pas de validation, on affiche juste les options suivantes
        generateAndDisplayPinyinOptions();
    }
}


function showPinyinTonePopup(inputElement, vowel) {
    const popup = document.getElementById('pinyinTonePopup');
     if (!popup) return;

    const rect = inputElement.getBoundingClientRect();
    popup.style.top = `${rect.bottom + window.scrollY + 5}px`;
    popup.style.left = `${rect.left + window.scrollX}px`;

    const toneMarks = { a:['ā','á','ǎ','à','a'], e:['ē','é','ě','è','e'], i:['ī','í','ǐ','ì','i'], o:['ō','ó','ǒ','ò','o'], u:['ū','ú','ǔ','ù','u'], ü:['ǖ','ǘ','ǚ','ǜ','ü'], v:['ǖ','ǘ','ǚ','ǜ','ü'] };
    const baseVowel = vowel.toLowerCase();
    const marks = toneMarks[baseVowel];

    if(marks) {
        popup.innerHTML = `
            <span class="tone-option" data-tone="1">${marks[0]}<kbd>&</kbd></span>
            <span class="tone-option" data-tone="2">${marks[1]}<kbd>é</kbd></span>
            <span class="tone-option" data-tone="3">${marks[2]}<kbd>"</kbd></span>
            <span class="tone-option" data-tone="4">${marks[3]}<kbd>'</kbd></span>
            <span class="tone-option" data-tone="5">${marks[4]}<kbd>(</kbd></span>
            <span class="tone-option" data-tone="0">${marks[4]}<kbd>Space</kbd></span>
        `;
        popup.querySelectorAll('.tone-option').forEach(option => {
             option.onclick = null;
             option.onclick = () => {
                const tone = parseInt(option.dataset.tone);
                const pinyinWithTone = applyToneToVowel(pinyinInputBuffer, tone === 0 ? 5 : tone);
                 insertAtCursor(inputElement, pinyinWithTone);
                 hidePinyinTonePopup();
                 pinyinInputBuffer = '';
            };
        });
         popup.style.display = 'block';
    } else {
        insertAtCursor(inputElement, vowel);
        hidePinyinTonePopup();
        pinyinInputBuffer = '';
    }
}

function hidePinyinTonePopup() {
    const popup = document.getElementById('pinyinTonePopup');
    if (popup) popup.style.display = 'none';
}

function applyToneToVowel(vowel, toneNum) {
    const toneMarks = { a:['ā','á','ǎ','à','a'], e:['ē','é','ě','è','e'], i:['ī','í','ǐ','ì','i'], o:['ō','ó','ǒ','ò','o'], u:['ū','ú','ǔ','ù','u'], ü:['ǖ','ǘ','ǚ','ǜ','ü'], v:['ǖ','ǘ','ǚ','ǜ','ü'] };
    const baseVowel = vowel.toLowerCase();
    const marks = toneMarks[baseVowel];
    if (marks && toneNum >= 1 && toneNum <= 5) {
        return marks[toneNum - 1];
    }
    return vowel;
}

function insertAtCursor(inputElement, text) {
  const start = inputElement.selectionStart;
  const end = inputElement.selectionEnd;
  const originalValue = inputElement.value;
  inputElement.value = originalValue.substring(0, start) + text + originalValue.substring(end);
  inputElement.selectionStart = inputElement.selectionEnd = start + text.length;
   inputElement.dispatchEvent(new Event('input', { bubbles: true }));
   inputElement.focus();
}

function validateAnswer() {
  const resultDiv = document.getElementById('gameResult');
  let isCorrect = false;
  let allBlanksFilled = false;
  let activeInput = null; // Declare activeInput here for broader scope if needed, though not strictly necessary with const below

  switch (currentGameMode) {
    case 'reorder-drag':
      const userSentence = document.getElementById('userSentence');
      const userWords = Array.from(userSentence.querySelectorAll('.word-token'))
        .map(token => token.textContent);
      const userAnswer = userWords.join('');
      isCorrect = normalizeForComparison(userAnswer) === normalizeForComparison(originalSentence);
      break;

    case 'free-input':
      // DÉCLARATION CORRECTE avec 'const'
      const freeInputElement = document.getElementById('freeInput'); 
      // Vérifier si l'élément existe avant de l'utiliser
      if (freeInputElement) {
          const userAnswerFree = freeInputElement.value.trim();
          freeInputElement.blur(); // <-- CLAVIER FERMÉ
          isCorrect = normalizeForComparison(userAnswerFree) === normalizeForComparison(originalSentence);
      } else {
          console.error("Input element #freeInput not found!");
          isCorrect = false; // Marquer comme incorrect si l'input n'est pas trouvé
      }
      break;

    case 'fill-blanks-char':
    case 'fill-blanks-pinyin':
      const isPinyin = currentGameMode === 'fill-blanks-pinyin';
      const inputElId = isPinyin ? 'blanks-input-pinyin' : 'blanks-input-char';
      const inputEl = document.getElementById(inputElId);
      
      // Validate the current blank if there's input
      if(inputEl && inputEl.value.trim() !== "") {
          validateBlank(isPinyin); // This function now handles .blur() internally
      }
      
      // Check if all blanks are filled *after* potential validation
      allBlanksFilled = fillBlanksData.every(data => data.status === 'correct' || data.status === 'incorrect');
      isCorrect = fillBlanksData.every(data => data.status === 'correct');

      // If not all blanks are filled yet, we don't proceed to show final result or navigate
      if (!allBlanksFilled) {
           // We might still want to show a temporary result from validateBlank,
           // but the overall sentence result isn't ready.
           // The return here prevents showResult below from being called prematurely.
           return; 
      }
      // If all blanks *are* filled, isCorrect holds the final sentence correctness,
      // and we proceed to showResult below.
      break;

    case 'live-typing':
    case 'time-attack':
      // Validation for these modes is handled within their specific keydown listeners (initLiveTypingMode)
      // This function shouldn't be called directly for them via the validate button.
      return; 

  } // End switch

  // Show the result (unless handled internally like in fill-blanks before completion)
  const correctMessage = '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg> Correct !';
const incorrectMessage = '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Incorrect. Essayez encore !';
showResult(isCorrect, isCorrect ? correctMessage : incorrectMessage);

  // Handle navigation or retry based on correctness
  if (isCorrect && !currentGameMode.startsWith('fill-blanks')) {
    // Correct answer for reorder or free-input: move to next or finish
    setTimeout(() => {
      if (currentSentenceIndex < sentences.length - 1) {
        goToSentence(1);
      } else {
        showGameResults();
      }
    }, 2000);
  } else if (!isCorrect && currentGameMode === 'reorder-drag') {
    // Incorrect reorder: reset the current sentence
    setTimeout(() => {
      initReorderMode(); // Reset words
      if(resultDiv) resultDiv.style.display = 'none'; // Hide result message
    }, 3000);
  } else if (!isCorrect && currentGameMode === 'free-input') {
    // Incorrect free-input: just hide the message, keep user input
    setTimeout(() => {
      if(resultDiv) resultDiv.style.display = 'none'; // Hide result message
      // Optionally re-focus the input:
      // const freeInputForFocus = document.getElementById('freeInput');
      // if (freeInputForFocus) freeInputForFocus.focus();
    }, 3000);
  } else if (isCorrect && currentGameMode.startsWith('fill-blanks')) {
    // Correct fill-blanks (all filled): Auto-next is handled within validateBlank's last step
    // No action needed here.
  } else if (!isCorrect && currentGameMode.startsWith('fill-blanks')) {
    // Incorrect fill-blanks (all filled but some wrong): Focus first error
    setTimeout(() => {
      if(resultDiv) resultDiv.style.display = 'none'; // Hide result message
      const firstErrorIndex = fillBlanksData.findIndex(d => d.status === 'incorrect');
      if(firstErrorIndex !== -1) {
          focusBlank(firstErrorIndex); // Re-focus the first incorrect blank
      }
    }, 3000);
  }
}

function showGameResults() {
    stopGameTimer();
    alert("Jeu terminé ! Scores et stats à afficher ici.");
}

function showResult(success, message) {
    const resultDiv = document.getElementById('gameResult');
    if(!resultDiv) return;


    resultDiv.className = success ? 'game-result success' : 'game-result error';
    resultDiv.innerHTML = message;
    resultDiv.style.display = 'block';
}

function giveHint() {
    if (currentGameMode === 'reorder-drag') {

        const availableWords = document.getElementById('availableWords');
        const userSentence = document.getElementById('userSentence');

        // *** MODIFICATION 1: Utiliser currentSentenceTokens et inclure la ponctuation (sauf espaces) ***
        const wordsAndPunc = currentSentenceTokens
            .filter(t => (t.type === 'word' || t.type === 'punc') && !/\s/.test(t.text))
            .map(t => t.text);

        const userTokens = Array.from(userSentence.querySelectorAll('.word-token'));
        const userWords = userTokens.map(t => t.textContent);

        let needsReset = false;

        if (userWords.length !== hintsRevealed) {
            needsReset = true;
        } else {
            for (let i = 0; i < hintsRevealed; i++) {
                // *** MODIFICATION 2: Comparer avec wordsAndPunc ***
                if (userWords[i] !== wordsAndPunc[i]) {
                    needsReset = true;
                    break;
                }
            }
        }

        if (needsReset) {
            userTokens.forEach(token => {
                availableWords.appendChild(token);
            });
            hintsRevealed = 0;
        }

        // *** MODIFICATION 3: Comparer avec wordsAndPunc.length ***
        if (hintsRevealed >= wordsAndPunc.length) return;

        const availableTokens = Array.from(availableWords.querySelectorAll('.word-token'));
        // *** MODIFICATION 4: Obtenir le prochain token (mot ou ponctuation) ***
        const nextToken = wordsAndPunc[hintsRevealed];

        // *** MODIFICATION 5: Trouver le token (y compris ponctuation) ***
        // Recherche simple, peut échouer si le même token est présent plusieurs fois (ex: "de de")
        // Une logique plus robuste impliquerait de compter les tokens déjà utilisés.
        // Pour ce cas, nous utilisons find qui prend le *premier* disponible.
        const token = availableTokens.find(t => t.textContent === nextToken);

        if (token) {
            token.classList.add('hint-revealed');
            userSentence.appendChild(token);
            hintsRevealed++;

            setTimeout(() => {
            token.classList.remove('hint-revealed');
            }, 1000);
        }

    } else if (currentGameMode === 'free-input') {
        // *** MODIFICATION 6: Utiliser currentSentenceTokens et inclure la ponctuation (sauf espaces) ***
        const wordsAndPunc = currentSentenceTokens
            .filter(t => (t.type === 'word' || t.type === 'punc') && !/\s/.test(t.text))
            .map(t => t.text);

        // *** MODIFICATION 7: Comparer avec wordsAndPunc.length ***
        if (hintsRevealed >= wordsAndPunc.length) return;

        const freeInput = document.getElementById('freeInput');

        // *** MODIFICATION 8: Logique d'indice simplifiée et correcte (sans espaces) ***
        // On reconstruit simplement la phrase correcte jusqu'à l'indice 'hintsRevealed'
        hintsRevealed++; // Révéler le prochain token
        const correctTextSoFar = wordsAndPunc.slice(0, hintsRevealed).join(''); // Join sans espaces
        freeInput.value = correctTextSoFar;

        freeInput.focus();
        freeInput.selectionStart = freeInput.selectionEnd = freeInput.value.length;

    } else if (currentGameMode === 'fill-blanks-char' || currentGameMode === 'fill-blanks-pinyin') {
        if (currentBlankIndex < fillBlanksData.length) {
            const currentData = fillBlanksData[currentBlankIndex];
            if(currentData.status === 'pending') {
                const inputElId = currentGameMode === 'fill-blanks-pinyin' ? 'blanks-input-pinyin' : 'blanks-input-char';
                document.getElementById(inputElId).value = currentGameMode === 'fill-blanks-pinyin' ? currentData.pinyinAnswer : currentData.originalWord;
                 validateBlank(currentGameMode === 'fill-blanks-pinyin');
            }
        }
    }
}

function goToSentence(direction) {
    const newIndex = currentSentenceIndex + direction;
    if (newIndex < 0 || newIndex >= sentences.length) {
        return;
    }
    currentSentenceIndex = newIndex;
    loadSentence();
}

function quitGame() {
    document.getElementById('gamePage').classList.remove('active');
    document.getElementById('homePage').style.display = 'block';
    stopGameTimer();
}

function startGameTimer() {
    console.log("DEBUG: Attempting to start timer for mode:", currentGameMode);
    stopGameTimer(); // Clear any previous timer

    const statTimeDisplay = document.getElementById('statTime');

    if (!statTimeDisplay) {
        console.error("DEBUG: Timer display element #statTime not found!");
        return; 
    }

    if (currentGameMode === 'time-attack') {
        // --- Mode Minuteur (Time Attack) ---
        console.log("DEBUG: Setting up Time Attack countdown...");
        
        // Votre logique dynamique (correcte)
        const targetCPM = parseInt(document.getElementById('cpmAttackTarget').value, 10);
        const targetText = originalSentence.replace(/[,\s]/g, '');
        let targetSeconds = Math.ceil((targetText.length / targetCPM) * 60);
        if (targetSeconds < 5) targetSeconds = 5; // Minimum 5 secondes

        let remainingSeconds = targetSeconds;
        console.log("DEBUG: Target seconds:", targetSeconds);

        const updateCountdownUI = () => {
            const minutes = Math.floor(remainingSeconds / 60).toString().padStart(2, '0');
            const seconds = (remainingSeconds % 60).toString().padStart(2, '0');
            const timeString = `${minutes}:${seconds}`;
            statTimeDisplay.textContent = timeString; // Mettre à jour le bon élément
        };

        updateCountdownUI(); // Affichage initial

        gameTimerInterval = setInterval(() => {
            remainingSeconds--;
            updateCountdownUI();

            if (remainingSeconds <= 0) {
                 console.log("DEBUG: Time Attack finished.");
                stopGameTimer();
                showResult(false, '<svg class="result-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg> Temps écoulé ! Perdu.');
                const inputEl = document.getElementById('time-attack-input');
                if (inputEl) inputEl.disabled = true;
            }
        }, 1000);
         console.log("DEBUG: Time Attack interval set with ID:", gameTimerInterval);

    // ===================================
    // === LA CORRECTION EST SUR CETTE LIGNE ===
    // ===================================
    } else if (currentGameMode === 'live-typing') { 
        // L'ID correct est 'live-typing', et non 'frappe-directe'
        
        // --- Mode Chronomètre (Frappe Live) ---
        console.log("DEBUG: Setting up standard chronometer...");
        gameStartTime = Date.now();

        const updateChronoUI = () => {
             const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
             const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
             const seconds = (elapsed % 60).toString().padStart(2, '0');
             const timeString = `${minutes}:${seconds}`;
             statTimeDisplay.textContent = timeString; // Mettre à jour le bon élément
        };

        updateChronoUI(); // Affichage initial (00:00)

        gameTimerInterval = setInterval(updateChronoUI, 1000);
        console.log("DEBUG: Chrono interval set with ID:", gameTimerInterval);
    }
    // Les autres modes (reorder, etc.) ne déclencheront pas le 'else if' et n'auront pas de timer.
}

function stopGameTimer() {
    if (gameTimerInterval) {
        clearInterval(gameTimerInterval);
        gameTimerInterval = null;
    }
}

function checkAndResizeFonts() {
  if (window.innerWidth > 600) return;

  const elementsToResize = [
    document.getElementById('translationHint'),
    document.getElementById('blanks-display-text-char'),
    document.getElementById('blanks-display-text-pinyin'),
    document.getElementById('typing-target-text'),
    document.getElementById('time-attack-target-text'),
    document.getElementById('free-input-target-text')
  ];

  const translationThreshold = 90;
  const gameTextThreshold = 130;

  elementsToResize.forEach(el => {
    if (!el) return;
    el.classList.remove('shrink-text');
    const height = el.offsetHeight;
    let threshold = (el.id === 'translationHint') ? translationThreshold : gameTextThreshold;
    if (height > threshold) {
      el.classList.add('shrink-text');
    }
  });
}

function resetLiveStats() {
    document.getElementById('statErrors').textContent = '0';
    document.getElementById('statAccuracy').textContent = '0%';
    document.getElementById('statChars').textContent = '0/0';
    document.getElementById('statTime').textContent = '0s';
}

function updateGameOptionsUI() {
    const selectedMode = document.getElementById('gameMode').value;

    // Cacher toutes les options de mode spécifiques
    document.querySelectorAll('.game-mode-option').forEach(el => el.style.display = 'none');

    // Gérer la visibilité de l'ancienne case à cocher traduction
    const translationCheckContainer = document.getElementById('showTranslationCheckContainer');
    if (translationCheckContainer) {
        translationCheckContainer.style.display = (selectedMode === 'free-input') ? 'none' : 'block';
    }

    // Afficher les options spécifiques au mode sélectionné
    switch (selectedMode) {
        case 'free-input':
            const freeInputOpts = document.getElementById('freeInputOptions');
            if (freeInputOpts) freeInputOpts.style.display = 'block';
            break;
        case 'time-attack':
            const timeAttackOpts = document.getElementById('timeAttackOptions');
            if (timeAttackOpts) timeAttackOpts.style.display = 'block';
            break;
        case 'fill-blanks-char':
            // Pour les caractères, afficher seulement les options de niveaux/indice
            const fillBlanksOptsChar = document.getElementById('fillBlanksOptions');
            if (fillBlanksOptsChar) fillBlanksOptsChar.style.display = 'block';
            break;
        case 'fill-blanks-pinyin':
            // Pour le pinyin, afficher la nouvelle section ET l'ancienne
            const pinyinTypeOpts = document.getElementById('pinyinInputTypeOptions');
            const fillBlanksOptsPinyin = document.getElementById('fillBlanksOptions');
            if (pinyinTypeOpts) pinyinTypeOpts.style.display = 'block';
            if (fillBlanksOptsPinyin) fillBlanksOptsPinyin.style.display = 'block';
            break;
        // Ajoutez d'autres cas si nécessaire pour d'autres modes
    }
}

// =====================================================
// READ MODE FUNCTIONS
// =====================================================
function detectSentenceBoundaries() {
  readSentenceBoundaries = []; // Réinitialiser

  // En mode Super Zen, une seule "phrase" (le contenu affiché)
  if (readSuperZen) {
    readSentenceBoundaries.push({
      chineseStart: 0,
      chineseEnd: readChars.length,
      translationStart: 0,
      translationEnd: readTranslationChars.length,
      chineseLength: readChars.length,
      translationLength: readTranslationChars.length,
    });
    console.log('📝 Phrase Super Zen détectée:', readSentenceBoundaries);
    return;
  }

  // --- Détection normale (CORRIGÉE) ---
  const chinesePunct = new Set(['。', '！', '？']);
  const translationPunct = new Set(['.', '!', '?']);
  
  const expectedSentenceCount = readSentences.length; // LA SOURCE DE VÉRITÉ

  let currentChineseStart = 0;
  let currentTranslationStart = 0;

  // Parcourir les caractères chinois pour trouver les fins de phrases
  for (let i = 0; i < readChars.length; i++) {
    const char = readChars[i];
    const text = char.textContent;

    const isChineseEnd = chinesePunct.has(text);
    const isLastChineseChar = (i === readChars.length - 1);
    const notDone = readSentenceBoundaries.length < expectedSentenceCount; // On n'a pas encore toutes nos phrases

    if ((isChineseEnd || isLastChineseChar) && notDone) {
      const chineseEnd = i + 1; // Inclure la ponctuation ou le dernier caractère
      const chineseLength = chineseEnd - currentChineseStart;

      // Trouver la fin de phrase correspondante dans la traduction
      let translationEnd = currentTranslationStart;
      let translationLength = 0;

      if (readTranslationChars.length > 0) {
          
          // Sommes-nous sur la toute dernière phrase attendue ?
          const isLastExpectedSentence = (readSentenceBoundaries.length === expectedSentenceCount - 1);

          if (isLastExpectedSentence) {
               // Si c'est la dernière phrase, on prend TOUT ce qui reste.
               translationEnd = readTranslationChars.length;
               console.log(`Boundary ${readSentenceBoundaries.length}: Last sentence. Grabbing all remaining translation.`);
          } else {
              // Ce n'est pas la dernière phrase. On cherche la prochaine ponctuation.
              // Position approximative attendue
               const expectedRatio = (i+1) / readChars.length;
               const expectedTranslationPos = Math.floor(expectedRatio * readTranslationChars.length);
               
               let foundPunct = false;
               // Chercher à partir de la position de départ.
               // On cherche .!? OU le span ' ' des paragraphes
               const searchStart = Math.max(currentTranslationStart, expectedTranslationPos - 15); // Regarde un peu en arrière

               for(let j = searchStart; j < readTranslationChars.length; j++) {
                   const trChar = readTranslationChars[j];
                   if (!trChar) continue; // Sécurité
                   const trText = trChar.textContent;
                   const isPunct = translationPunct.has(trText);
                   // Le ' ' est un span inséré entre les paragraphes par prepareTranslationForTyping
                   const isParaBreak = (trText === ' ' && j > currentTranslationStart); 

                   if (isPunct || isParaBreak) {
                       translationEnd = j + 1; // Inclure le délimiteur
                       foundPunct = true;
                       console.log(`Boundary ${readSentenceBoundaries.length}: Found delimiter at ${j}`);
                       break;
                   }
               }
               
               // SI ON NE TROUVE RIEN (ex: pas de point)
               if (!foundPunct) {
                   // NE PAS PRENDRE TOUTE LA FIN.
                   // Utiliser le ratio comme "meilleure estimation".
                   // On devine une position basée sur le ratio, en s'assurant qu'elle avance
                   translationEnd = Math.floor(expectedTranslationPos + (expectedTranslationPos - currentTranslationStart) * 0.5); 
                   translationEnd = Math.max(translationEnd, currentTranslationStart + 5); // Avancer d'au moins 5
                   translationEnd = Math.min(translationEnd, readTranslationChars.length); // Ne pas dépasser
                   
                   // S'assurer qu'on n'est pas bloqué
                   if (translationEnd <= currentTranslationStart) {
                       translationEnd = expectedTranslationPos; // Fallback sur le ratio pur
                   }
                   // S'assurer de ne pas prendre la dernière phrase par erreur
                   if (readSentenceBoundaries.length < expectedSentenceCount - 2) {
                       translationEnd = Math.min(translationEnd, readTranslationChars.length - 5); // Garder une marge
                   }
                   translationEnd = Math.max(currentTranslationStart + 1, translationEnd); // Forcer à avancer
                   
                   console.log(`Boundary ${readSentenceBoundaries.length}: NO delimiter. Guessing end at ${translationEnd}`);
               }
          }
          translationLength = translationEnd - currentTranslationStart;
      }


      readSentenceBoundaries.push({
        chineseStart: currentChineseStart,
        chineseEnd: chineseEnd,
        translationStart: currentTranslationStart,
        translationEnd: translationEnd,
        chineseLength: chineseLength,
        translationLength: translationLength,
      });

      // Mettre à jour les points de départ pour la prochaine phrase
      currentChineseStart = chineseEnd;
      currentTranslationStart = translationEnd;

       // Si on a consommé toute la traduction, on arrête
       if(currentTranslationStart >= readTranslationChars.length) break;
    }
  }

  // S'il reste de la traduction mais pas de chinois (rare)
  if(currentTranslationStart < readTranslationChars.length && readSentenceBoundaries.length < expectedSentenceCount) {
      readSentenceBoundaries.push({
          chineseStart: currentChineseStart,
          chineseEnd: readChars.length,
          translationStart: currentTranslationStart,
          translationEnd: readTranslationChars.length,
          chineseLength: 0,
          translationLength: readTranslationChars.length - currentTranslationStart
      });
  }
  
  console.log('📝 Phrases détectées (FIXED):', readSentenceBoundaries.length, readSentenceBoundaries);
}

function startReadMode() {
  // === CORRECTIF: S'assurer que readPage n'est pas dans gamePage ===
  const readPageEl = document.getElementById('readPage');
  if (readPageEl && readPageEl.parentElement.id === 'gamePage') {
    document.body.appendChild(readPageEl);
    console.log('🔧 Correctif: readPage repositionné hors de gamePage');
  }
  
  console.log('=== DÉBUT startReadMode ===');
  
  // === 1. VALIDATIONS INITIALES ===
  const zhText = document.getElementById('inputZh').value.trim();
  console.log('Texte chinois:', zhText ? zhText.substring(0, 50) + '...' : 'VIDE');
  
  if (!zhText) {
    alert('⚠️ Veuillez entrer un texte chinois.');
    return;
  }
  
  console.log('Dict chargé:', dict && dict.wordSet ? dict.wordSet.size + ' mots' : 'NON');
  console.log('LevelMap chargé:', levelMap ? levelMap.size + ' mots' : 'NON');
  
  if (!dict || dict.wordSet.size === 0) {
    alert('⚠️ Veuillez charger un dictionnaire CC-CEDICT.');
    return;
  }
  if (!levelMap || levelMap.size === 0) {
    alert('⚠️ Veuillez charger une liste HSK/Fréquence.');
  }

  // === 2. RÉCUPÉRATION DES PARAMÈTRES (AVANT LE RENDU) ===
  console.log('Récupération des paramètres...');
  
  // Mode d'affichage
  readDisplayMode = document.getElementById('displayMode').value;
  console.log('Mode affichage:', readDisplayMode);
  
  // Taille de police
  readFontSize = parseInt(document.getElementById('fontSize').value);
  console.log('Taille police:', readFontSize);
  
  // Vitesse (CPM)
  readCPM = parseInt(document.getElementById('cpm').value);
  console.log('CPM:', readCPM);
  
  // Catégorie (HSK ou Fréquence)
  const activeCategory = document.querySelector('#readCategorySelector .category-btn.active');
  readCategory = activeCategory ? activeCategory.getAttribute('data-category') : 'hsk';
  console.log('Catégorie:', readCategory);
  
  // Niveaux sélectionnés
  readSelectedLevels = new Set();
  const selector = readCategory === 'hsk' ? '#hskSelector' : '#freqSelector';
  document.querySelectorAll(`${selector} .hsk-selector-btn.active`).forEach(btn => {
    readSelectedLevels.add(Number(btn.getAttribute('data-level')));
  });
  console.log('Niveaux sélectionnés:', Array.from(readSelectedLevels));

  // === 3. TRAITEMENT DU TEXTE ===
  console.log('Traitement du texte...');
  const normalizedText = normalizeChineseText(zhText);
  readSentences = splitSentences(normalizedText);
  console.log('Phrases détectées:', readSentences.length);

  // Traitement de la traduction
  const trText = document.getElementById('inputTr').value.trim();
  if (trText) {
    readTranslations = trText.split(/\s*\/\/\s*/).flatMap(part => {
      return part.split(/(?<=[.!?])\s+/g);
    }).filter(Boolean).map(s => s.trim());
  } else {
    readTranslations = [];
  }
  console.log('Traductions:', readTranslations.length);

  // === 4. TRANSITION VERS LA PAGE DE LECTURE ===
  console.log('Transition vers page lecture...');
  document.getElementById('homePage').style.display = 'none';
  document.getElementById('readPage').classList.add('active');
  
  // Afficher la taille de police dans l'UI
  document.getElementById('readFontSize').textContent = readFontSize + 'px';

  // === 5. RÉINITIALISATION DES ÉTATS ===
  console.log('Réinitialisation des états...');
  readCurrentSentence = 0;
  readSuperZen = false;
  readSuperZenType = false;
  readFocusMode = false;
  isFlipped = false;
  
  // Retirer la classe 'active' du bouton Focus
  const focusBtn = document.getElementById('readFocusToggle');
  if (focusBtn) focusBtn.classList.remove('active');
  
  // Retirer la classe 'super-zen' de la page
  const page = document.getElementById('readPage');
  page.classList.remove('super-zen');

  // === 6. RENDU DU CONTENU (MAINTENANT LES VARIABLES SONT PRÊTES) ===
  console.log('Appel de renderReadText()...');
  try {
    renderReadText(); // Crée readChars et readTranslationChars
    console.log('renderReadText() OK - Chars:', readChars.length);
  } catch (error) {
    console.error('ERREUR dans renderReadText():', error);
    alert('Erreur lors du rendu du texte : ' + error.message);
    return;
  }
  
  // === 7. DÉTECTION DES PHRASES ET CONFIGURATION ===
  console.log('Configuration de l\'interface...');
  try {
    detectSentenceBoundaries(); // Nécessite que readChars existe
    createReadFilters(); // Crée les chips de filtre HSK/Freq
    updateReadDifficulty(); // Calcule et affiche la difficulté
    updateReadModeButton(); // Met à jour le bouton "Instant/Frappe"
    updateFocusButtonState(); // Active/désactive le bouton Focus
    console.log('Configuration OK');
  } catch (error) {
    console.error('ERREUR dans la configuration:', error);
  }

  // === 8. GESTION DU BOUTON FLIP (MOBILE) ===
  const isMobile = window.matchMedia('(max-width: 900px)').matches;
  const flipBtn = document.getElementById('readFlipBtn');
  const container = document.getElementById('readTextContainer');
  
  if (flipBtn && container) {
    if (isMobile && readTranslations.length > 0 && container.classList.contains('has-flip')) {
      flipBtn.style.display = 'flex';
	  setTimeout(adjustFlipHeight, 100);
    } else {
      flipBtn.style.display = 'none';
    }
  }

  // === 9. LANCEMENT DE L'ANIMATION (SI MODE FRAPPE) ===
  if (readDisplayMode === 'type') {
    console.log('Lancement animation frappe...');
    startTypeAnimation();
  } else {
    console.log('Mode instantané - pas d\'animation');
    stopTypeAnimation();
  }
  
  console.log('=== FIN startReadMode ===');
}

function createReadFilters() {
  const legend = document.getElementById('readFilterLegend');
  const existingChips = legend.querySelectorAll('.read-legend-chip:not(.read-legend-focus)');
  existingChips.forEach(chip => chip.remove());

  const focusBtn = document.getElementById('readFocusToggle');

  if (readCategory === 'hsk') {
    for (let i = 1; i <= 7; i++) {
      const chip = document.createElement('button');
      chip.className = `read-legend-chip level-${i === 7 ? '79' : i}`;
      chip.setAttribute('data-level', i);
      chip.textContent = i === 7 ? 'HSK 7-9' : `HSK ${i}`;
      if (readSelectedLevels.has(i)) {
        chip.classList.add('active');
      }
      chip.addEventListener('click', () => toggleReadFilter(i));

      if (focusBtn) {
        legend.insertBefore(chip, focusBtn);
      } else {
        legend.appendChild(chip);
      }
    }
  } else {
    const freqLabels = ['0-1k', '1-2k', '2-3k', '3-4k', '4-5k', '5-7k', '7-10k', '10-15k', '15-40k'];
    for (let i = 1; i <= 9; i++) {
      const chip = document.createElement('button');
      chip.className = `read-legend-chip freq-${i}`;
      chip.setAttribute('data-level', i);
      chip.textContent = freqLabels[i - 1];
      if (readSelectedLevels.has(i)) {
        chip.classList.add('active');
      }
      chip.addEventListener('click', () => toggleReadFilter(i));

      if (focusBtn) {
        legend.insertBefore(chip, focusBtn);
      } else {
        legend.appendChild(chip);
      }
    }
  }
}

function toggleReadFilter(level) {
  if (readSelectedLevels.has(level)) {
    readSelectedLevels.delete(level);
  } else {
    readSelectedLevels.add(level);
  }

  const chip = document.querySelector(`.read-legend-chip[data-level="${level}"]`);
  if (chip) {
    chip.classList.toggle('active');
  }

  applyReadColors();
}

function applyReadColors() {
  const chars = document.querySelectorAll('.read-char');
  const filteredWords = new Set();
  let lastVisibleWord = null;

  // Supprimer d'abord tous les espaces focus existants
  document.querySelectorAll('.focus-space').forEach(space => space.remove());

  chars.forEach(char => {
    const word = char.getAttribute('data-word');

    // Réinitialiser les classes de couleur
    char.className = 'read-char'; // Garde la classe de base

    if (!word) { // Gérer la ponctuation et les espaces
      if (readFocusMode) {
        char.style.display = 'none';
        char.style.visibility = 'hidden';
      } else {
        char.style.display = 'inline';
        char.style.visibility = 'visible';
      }
      return;
    }

    // C'est un caractère de mot
    const lvl = getLevel(word, readCategory);
    const shouldHighlight = lvl > 0 && readSelectedLevels.has(lvl);

    if (readFocusMode) {
      if (shouldHighlight) {
        char.style.display = 'inline';
        char.style.visibility = 'visible';
        char.classList.add(levelClassFor(word, readCategory));
        filteredWords.add(word);

        // Ajouter un espace après le mot COMPLET s'il est différent du précédent
        const nextChar = char.nextElementSibling;
        const isLastCharOfWord = !nextChar || nextChar.getAttribute('data-word') !== word;

        if (isLastCharOfWord && word !== lastVisibleWord) {
           lastVisibleWord = word; // Mettre à jour après avoir traité le dernier caractère
           // Insérer l'espace APRES le caractère courant
           const space = document.createElement('span');
           space.textContent = ' ';
           space.className = 'read-char focus-space'; // Marquer l'espace
           space.style.display = 'inline';
           space.style.visibility = 'visible';
           char.parentNode.insertBefore(space, char.nextSibling);
        } else if (!isLastCharOfWord) {
             // Si on est au milieu d'un mot, s'assurer que lastVisibleWord est bien le mot courant
             lastVisibleWord = word;
        }

      } else {
        char.style.display = 'none';
        char.style.visibility = 'hidden';
      }
    } else { // Mode normal (pas Focus)
      char.style.display = 'inline';
      char.style.visibility = 'visible';
      lastVisibleWord = null; // Réinitialiser pour le mode normal

      if (shouldHighlight) {
        char.classList.add(levelClassFor(word, readCategory));
      }
    }
  });

  if (readFocusMode && filteredWords.size > 0) {
    const wordsList = Array.from(filteredWords).join(' ');
    navigator.clipboard.writeText(wordsList).then(() => {
      console.log('📋 Copié:', filteredWords.size, 'mots.');
    }).catch(err => {
      console.log('⚠️ Erreur de copie:', err);
    });
  }
}

function updateReadDifficulty() {
  // console.log("Updating difficulty..."); 

  // Get elements first
  const gaugeContainer = document.getElementById('rc-difficulty-gauge'); // Container (jauge desktop ET chip mobile)
  const textEl = document.getElementById('readDifficultyText'); // Texte difficulté (commun)
  const desktopFill = document.getElementById('readDifficultyFill'); // Remplissage barre desktop
  const desktopLabel = gaugeContainer ? gaugeContainer.querySelector('.difficulty-label') : null; // Label desktop

  // --- Handle case with no sentences ---
  if (!readSentences || readSentences.length === 0) {
      if (textEl) { textEl.textContent = '—'; textEl.style.color = 'var(--muted)'; }
      if (gaugeContainer) { gaugeContainer.style.borderColor = 'var(--muted)'; } // Bordure chip mobile
      if (desktopFill) { desktopFill.style.width = `0%`; desktopFill.style.background = 'var(--muted)';}
      return;
  }

  // --- Prepare tokenSents ---
  const tokenSents = readSentences.map(s =>
      segmentText(s, dict.wordSet, dict.maxLen)
      .filter(t => t.type === 'word' || t.type === 'punc')
  );

  // --- Handle case with no tokens ---
  if (!tokenSents || tokenSents.length === 0 || tokenSents.flat().length === 0) {
       if (textEl) { textEl.textContent = '—'; textEl.style.color = 'var(--muted)'; }
       if (gaugeContainer) { gaugeContainer.style.borderColor = 'var(--muted)'; } // Bordure chip mobile
       if (desktopFill) { desktopFill.style.width = `0%`; desktopFill.style.background = 'var(--muted)';}
      return;
  }

  // --- Appeler calculateDifficulty ---
  const diff = calculateDifficulty(tokenSents, readCategory);
  // console.log("Calculated diff object:", diff); 

  // --- Afficher le résultat ---
  if (diff && gaugeContainer && textEl) { 

    // --- Mettre à jour le texte (commun) ---
    textEl.textContent = diff.label;

    // --- Déterminer si on est en affichage mobile (chip) ou desktop (gauge) ---
    // On vérifie si le label de la jauge est visible (il est caché sur mobile)
    const isMobileChip = desktopLabel && window.getComputedStyle(desktopLabel).display === 'none';

    if (isMobileChip) {
        // --- Mettre à jour le CHIP MOBILE ---
        textEl.style.color = diff.color; // Couleur dynamique pour le texte du chip
        gaugeContainer.style.borderColor = diff.color; // Couleur dynamique pour la bordure du chip
    } else {
        // --- Mettre à jour la JAUGE DESKTOP ---
        textEl.style.color = 'var(--fg)'; // Couleur standard pour le texte de la jauge
        gaugeContainer.style.borderColor = 'var(--border)'; // Bordure standard pour la jauge
        if (desktopFill) { // Mettre à jour le remplissage
            desktopFill.style.width = `${diff.scorePct}%`;
            desktopFill.style.background = diff.color;
        }
    }

  } else {
      // --- Gérer l'erreur d'affichage ---
      console.error("updateReadDifficulty: Could not update display.", {diff, gaugeContainer, textEl, desktopFill});
       // Reset Mobile Chip & Desktop Text on error
       if(textEl) { textEl.textContent = 'Erreur'; textEl.style.color = 'var(--muted)'; }
       if(gaugeContainer) gaugeContainer.style.borderColor = 'var(--muted)'; 
       // Reset Desktop Gauge fill on error
       if (desktopFill) { desktopFill.style.width = `0%`; desktopFill.style.background = 'var(--muted)';}
  }
}

function renderReadText() {
  const container = document.getElementById('readTextContainer');
  let readTextEl = document.getElementById('readText');
  let readTranslationEl = document.getElementById('readTranslation');
  const isMobile = window.matchMedia('(max-width: 900px)').matches;

  readChars = [];
  readTranslationChars = []; // Clear arrays
  container.classList.remove('has-flip'); // Reset flip class

  // === VÉRIFICATION : S'assurer que readSentences existe ===
  if (!readSentences || readSentences.length === 0) {
    console.error("renderReadText: readSentences est vide ou non défini !");
    container.innerHTML = '<div class="read-text">Erreur : Aucune phrase à afficher</div>';
    return;
  }

  // === VÉRIFICATION : S'assurer que dict existe ===
  if (!dict || !dict.wordSet || dict.wordSet.size === 0) {
    console.error("renderReadText: Dictionnaire non chargé !");
    container.innerHTML = '<div class="read-text">Erreur : Dictionnaire non chargé</div>';
    return;
  }

  // --- Reconstruction conditionnelle de l'HTML ---
  if (readSuperZen) {
    container.innerHTML = `
      <div class="read-text" id="readText"></div>
      <div class="read-translation" id="readTranslation"></div>
    `;
    readTextEl = document.getElementById('readText');
    readTranslationEl = document.getElementById('readTranslation');
    container.className = 'read-text-container';
    
    const sentence = readSentences[readCurrentSentence] || '';
    const tokens = segmentText(sentence, dict.wordSet, dict.maxLen);
    tokens.forEach(token => appendToken(token, readTextEl, readChars));
    
    // --- MODIFICATION ICI ---
    // Appliquer la taille de police Super Zen actuelle
if (readTranslations[readCurrentSentence]) {
        readTranslationEl.textContent = readTranslations[readCurrentSentence];
        readTranslationEl.style.display = 'block';
    } else {
        readTranslationEl.style.display = 'none';
    }
    // --- FIN DE LA MODIFICATION ---
    
    const szProgress = document.getElementById('szProgress');
    if(szProgress) szProgress.textContent = `${readCurrentSentence + 1}/${readSentences.length}`;

  } else if (isMobile && readTranslations.length > 0) {
    container.innerHTML = `
      <div class="flip-container" id="flipContainer">
        <div class="flip-inner">
          <div class="flip-front read-text" id="readText"></div>
          <div class="flip-back read-translation" id="readTranslation"></div>
        </div>
      </div>
    `;
    readTextEl = document.getElementById('readText');
    readTranslationEl = document.getElementById('readTranslation');
    const flipContainer = document.getElementById('flipContainer');
    container.className = 'read-text-container has-flip';
    if(isFlipped && flipContainer) flipContainer.classList.add('flipped');
    
    readSentences.forEach((sentence, idx) => {
        const tokens = segmentText(sentence, dict.wordSet, dict.maxLen);
        tokens.forEach(token => appendToken(token, readTextEl, readChars));
        if (idx < readSentences.length - 1) appendToken({ text: ' ', type: 'punc' }, readTextEl, readChars);
    });
    
    readTranslations.forEach((tr) => {
        const p = document.createElement('p'); 
        p.textContent = tr; 
        p.style.marginBottom = '12px';
        readTranslationEl.appendChild(p);
    });

  } else { // Desktop or Mobile without translation
    container.innerHTML = `
      <div class="read-text" id="readText"></div>
      <div class="read-translation" id="readTranslation"></div>
    `;
    readTextEl = document.getElementById('readText');
    readTranslationEl = document.getElementById('readTranslation');
    container.className = 'read-text-container';
    
    readSentences.forEach((sentence, idx) => {
      const tokens = segmentText(sentence, dict.wordSet, dict.maxLen);
      tokens.forEach(token => appendToken(token, readTextEl, readChars));
      if (idx < readSentences.length - 1) appendToken({ text: ' ', type: 'punc' }, readTextEl, readChars);
    });
    
    if (readTranslations.length > 0) {
        readTranslations.forEach((tr) => {
            const p = document.createElement('p'); 
            p.textContent = tr; 
            p.style.marginBottom = '12px';
            readTranslationEl.appendChild(p);
        });
        readTranslationEl.style.display = 'block';
    } else {
        readTranslationEl.style.display = 'none';
    }
  }

  // --- Application de la taille de police ---
  if (readTextEl) readTextEl.style.fontSize = readFontSize + 'px';
  if (readTranslationEl) readTranslationEl.style.fontSize = (readFontSize * 0.8) + 'px';

  // --- Préparation pour la frappe SEULEMENT si nécessaire ---
  if (readDisplayMode === 'type' || readSuperZenType) {
      prepareTranslationForTyping();
      readChars.forEach(char => char.style.visibility = 'hidden');
      readTranslationChars.forEach(char => char.style.visibility = 'hidden');
      readCurrentIndex = 0;
      readTranslationCurrentIndex = 0;
  } else {
      readChars.forEach(char => char.style.visibility = 'visible');
      if(readTranslationEl) {
           readTranslationEl.style.visibility = 'visible';
           Array.from(readTranslationEl.querySelectorAll('span')).forEach(span => span.style.visibility = 'visible');
      }
  }
  applyReadStyles();
  applyReadColors(); // Appliquer les couleurs HSK/Freq toujours à la fin
}


function updateFocusButtonState() {
    const focusBtn = document.getElementById('readFocusToggle');
    if (focusBtn) {
        // Désactiver si PAS en mode SuperZen ET SI en mode Frappe
        focusBtn.disabled = (!readSuperZen && readDisplayMode === 'type');

        // Optionnel : Retirer la classe 'active' si désactivé
        if (focusBtn.disabled) {
            focusBtn.classList.remove('active');
            // S'assurer que readFocusMode est false si le bouton est désactivé
            // readFocusMode = false; // Décommenter si le focus doit être forcé off
        }
    }
}

// Helper pour renderReadText: Ajoute un token (mot ou ponctuation) au DOM
function appendToken(token, parentElement, charArray) {
  // --- Vérifications initiales ---
  if (!token || !parentElement || !charArray) {
    console.error("Erreur dans appendToken: Argument manquant.", { token, parentElement, charArray });
    return; // Ne rien faire si les arguments sont invalides
  }

  const word = token.text; // Le texte du token (peut être un mot, un caractère, ou de la ponctuation)

  // --- Cas 1: Ponctuation ou Espace ---
  if (token.type === 'punc' || /\s/.test(word)) {
    const span = document.createElement('span');
    span.textContent = word;
    span.className = 'read-char'; // Classe de base pour tous les spans
    // Note: Pas d'écouteur de clic sur la ponctuation/espaces
    parentElement.appendChild(span);
    charArray.push(span); // Ajouter au tableau global des caractères chinois
  }
  // --- Cas 2: Mot Chinois ---
  else if (token.type === 'word' && word.length > 0) {
    // Sécurité : vérifier que readCategory est défini avant de l'utiliser
    const category = readCategory || 'hsk'; // Utilise 'hsk' par défaut si indéfini
    const lvl = getLevel(word, category); // Récupère le niveau HSK/Freq du mot complet

    // === MODIFICATION : Créer un wrapper pour le mot ===
    const wordWrapper = document.createElement('span');
    wordWrapper.className = 'read-word'; // Nouvelle classe pour le wrapper
    wordWrapper.setAttribute('data-word-wrapper', word); // Mettre le mot sur le wrapper

    // Itérer sur chaque caractère du mot pour créer un span individuel
    for (let i = 0; i < word.length; i++) {
      const char = word[i]; // Caractère individuel
      const span = document.createElement('span');
      span.textContent = char;
      span.className = 'read-char'; // Classe de base
      span.setAttribute('data-word', word); // Stocke le mot complet sur chaque caractère

      // Ajouter la classe de couleur HSK/Freq si applicable
      // Sécurité : vérifier que readSelectedLevels existe
      if (lvl > 0 && readSelectedLevels && readSelectedLevels.has(lvl)) {
        const levelClassName = levelClassFor(word, category); // Obtient la classe (e.g., 'hsk1', 'freq3')
        if (levelClassName) {
          span.classList.add(levelClassName);
        }
      }

      // [SUPPRIMÉ] L'ancien addEventListener('click') est retiré d'ici
      
      // Ajouter le span au wrapper (au lieu de 'parentElement')
      wordWrapper.appendChild(span);
      charArray.push(span); // Ajouter au tableau global (inchangé)
    }
    
    // Ajouter le wrapper au parent
    parentElement.appendChild(wordWrapper);
    
  } else {
    // Cas imprévu (e.g., token.type inconnu ou mot vide)
    console.warn("appendToken: Type de token inconnu ou mot vide ignoré:", token);
  }
}


function openDictModal(word) {
  console.log('🔍 openDictModal appelée avec:', word);

  // --- 1. Récupération des éléments ---
  const modal = document.getElementById('dictModal');
  const charEl = document.getElementById('dictChar');
  const tabsContainer = document.getElementById('dictTabsContainer');
  const panesContainer = document.getElementById('dictPanesContainer');
  const closeBtn = document.getElementById('closeDictModal');
  const content = modal.querySelector('.dict-modal-content');

  if (!modal || !content || !charEl || !tabsContainer || !panesContainer) {
    console.error("Erreur critique: Éléments du modal (tabs/panes) manquants !");
    return;
  }

  // --- 2. Vider l'ancien contenu ---
  charEl.textContent = word;
  tabsContainer.innerHTML = '';
  panesContainer.innerHTML = '';
  const existingTagsContainer = content.querySelector('.dict-tags-container');
  if (existingTagsContainer) {
    existingTagsContainer.remove();
  }

  // --- 3. Gestion des Tags (HSK / Fréquence) ---
  const hskLevel = getLevel(word, 'hsk');
  const freqLevel = getLevel(word, 'freq');
  const freqLabels = ['0-1k', '1-2k', '2-3k', '3-4k', '4-5k', '5-7k', '7-10k', '10-15k', '15-40k'];

  if (hskLevel > 0 || freqLevel > 0) {
    const tagsContainer = document.createElement('div');
    tagsContainer.className = 'dict-tags-container';
    if (hskLevel > 0) {
      const hskTag = document.createElement('span');
      const hskClassSuffix = hskLevel === 7 ? '79' : hskLevel;
      const hskText = hskLevel === 7 ? 'HSK 7-9' : `HSK ${hskLevel}`;
      hskTag.className = `dict-tag level-${hskClassSuffix}`;
      hskTag.textContent = hskText;
      tagsContainer.appendChild(hskTag);
    }
    if (freqLevel > 0 && freqLevel <= freqLabels.length) {
      const freqTag = document.createElement('span');
      freqTag.className = `dict-tag freq-${freqLevel}`;
      freqTag.textContent = freqLabels[freqLevel - 1];
      tagsContainer.appendChild(freqTag);
    }
    charEl.after(tagsContainer);
  }

  // --- 4. Recherche & Logique de tri ---
  const entries = dict.entries.get(word); // Récupère le TABLEAU d'entrées
  let entriesToDisplay = entries;

  if (entries && entries.length > 1 && word.length === 1 && POLYPHONE_FREQ_MAP.has(word)) {
    console.log('Application du tri de fréquence pour:', word);
    const freqList = POLYPHONE_FREQ_MAP.get(word);
    const freqMap = new Map();
    freqList.forEach((p, index) => {
        if (!freqMap.has(p)) freqMap.set(p, index);
    });
    console.log('Carte de fréquence:', freqMap);

    // Tri sur une COPIE
    entriesToDisplay = [...entries].sort((a, b) => {
        const pinyinA = numericToDiacriticPinyin(a.pinyin);
        const pinyinB = numericToDiacriticPinyin(b.pinyin);
        const scoreA = freqMap.has(pinyinA) ? freqMap.get(pinyinA) : 99;
        const scoreB = freqMap.has(pinyinB) ? freqMap.get(pinyinB) : 99;
        return scoreA - scoreB;
    });
    console.log('Entrées triées:', entriesToDisplay.map(e => e.pinyin));
  }

  // ================================================================
  // DÉBUT DE LA LOGIQUE DE FUSION DES DOUBLONS
  // ================================================================

  // 5. Créer une carte pour regrouper les définitions par pinyin
  const groupedPinyinMap = new Map();

  if (entriesToDisplay) {
    entriesToDisplay.forEach(entry => {
      // 5a. Normaliser le pinyin (e.g., "bo2" -> "bó" -> "bó")
      const pinyinDiacritic = numericToDiacriticPinyin(entry.pinyin);
      const groupKey = pinyinDiacritic.toLowerCase(); // Clé de groupement

      // 5b. Si le groupe n'existe pas, l'initialiser
      if (!groupedPinyinMap.has(groupKey)) {
        groupedPinyinMap.set(groupKey, {
          pinyin: pinyinDiacritic, // Conserver la casse originale pour l'affichage (e.g., Bó)
          defs: new Set() // Utiliser un Set pour dédupliquer automatiquement les définitions
        });
      }

      // 5c. Ajouter les définitions au Set
      const groupData = groupedPinyinMap.get(groupKey);
      if (entry.defs && entry.defs.length > 0) {
        entry.defs.forEach(def => groupData.defs.add(def));
      }
    });
  }
  
  console.log('Groupes fusionnés:', groupedPinyinMap);

  // 6. Générer l'UI à partir de la carte fusionnée
  const groupedEntries = Array.from(groupedPinyinMap.values());

  if (groupedEntries.length > 1) {
    // --- CAS 1: PLUSIEURS PRONONCIATIONS FUSIONNÉES -> AFFICHER LES ONGLETS ---
    tabsContainer.style.display = 'flex';

    groupedEntries.forEach((group, index) => {
      // a. Créer l'onglet (bouton)
      const tabBtn = document.createElement('button');
      tabBtn.className = 'dict-tab-btn';
      tabBtn.dataset.tabId = `dict-pane-${index}`;
      tabBtn.textContent = group.pinyin.split(' ')[0]; // Pinyin pour l'onglet
      tabsContainer.appendChild(tabBtn);

      // b. Créer le panneau (définition)
      const pane = document.createElement('div');
      pane.className = 'dict-pane';
      pane.id = `dict-pane-${index}`;
      
      let paneHTML = `<div class="dict-pinyin">${group.pinyin}</div>`; // Pinyin complet dans le panneau
      paneHTML += '<div class="dict-definitions">';
      
      if (group.defs.size > 0) {
        group.defs.forEach(def => { // Itérer sur le Set de définitions uniques
          paneHTML += `<div class="dict-def">${def.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</div>`;
        });
      } else {
        paneHTML += `<div class="dict-def">Aucune définition.</div>`;
      }
      
      paneHTML += '</div>';
      pane.innerHTML = paneHTML;
      panesContainer.appendChild(pane);

      // c. Activer le premier
      if (index === 0) {
        tabBtn.classList.add('active');
        pane.classList.add('active');
      }
    });

  } else if (groupedEntries.length === 1) {
    // --- CAS 2: UNE SEULE PRONONCIATION FUSIONNÉE -> PAS D'ONGLETS ---
    tabsContainer.style.display = 'none';
    
    const group = groupedEntries[0]; // Prendre le seul groupe

    const pane = document.createElement('div');
    pane.className = 'dict-pane active';
    pane.id = `dict-pane-0`;
    
    let paneHTML = `<div class="dict-pinyin">${group.pinyin}</div>`;
    paneHTML += '<div class="dict-definitions">';
    
    if (group.defs.size > 0) {
      group.defs.forEach(def => {
        paneHTML += `<div class="dict-def">${def.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</div>`;
      });
    } else {
      paneHTML += `<div class="dict-def">Aucune définition.</div>`;
    }
    
    paneHTML += '</div>';
    pane.innerHTML = paneHTML;
    panesContainer.appendChild(pane);

  } else {
    // --- CAS 3: NON TROUVÉ (avec fallback sur le 1er caractère) ---
    tabsContainer.style.display = 'none';

    const firstChar = word.charAt(0);
    if (word.length > 1) {
        const firstCharEntries = dict.entries.get(firstChar);
        if (firstCharEntries && firstCharEntries.length > 0) {
            openDictModal(firstChar); // Appel récursif
            return;
        }
    }
    
    panesContainer.innerHTML = '<div class="dict-pane active"><div class="dict-definitions"><div class="dict-def">Aucune définition trouvée.</div></div></div>';
  }
  
  // ================================================================
  // FIN DE LA LOGIQUE DE FUSION
  // ================================================================

  // --- 7. Afficher le Modal ---
  modal.classList.add('active');
  if (closeBtn) setTimeout(() => closeBtn.focus(), 50);
}

function closeModal(modalId) { // Fonction closeModal générique conservée
    const modal = document.getElementById(modalId);
    if(modal) modal.classList.remove('active');
}


// *** NOUVELLE LOGIQUE DE REVEAL ***
// Garder une référence au timer pour la traduction
let readTranslationTimer = null;

// Fonction pour démarrer/redémarrer les animations
function startTypeAnimation() {
  stopTypeAnimation(); // Arrête tout timer précédent

  readCurrentIndex = 0;
  readTranslationCurrentIndex = 0;
  readIsPlaying = true;

  // Mettre à jour l'icône Play/Pause...
  const btn = document.getElementById('readPlayPause');
  if (btn) btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';
  const szBtn = document.getElementById('szBtnPlay');
  if (szBtn && readSuperZen) szBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';

  // --- Préparer les textes ---
  readChars.forEach(char => char.style.visibility = 'hidden');
  prepareTranslationForTyping(); // Assure que readTranslationChars est prêt et caché

  // Réinitialiser la barre de progression
  const progressBar = document.getElementById('readProgressBar');
  if(progressBar) progressBar.style.width = '0%';

  // S'assurer que les boundaries sont détectées (pour Superzen)
  detectSentenceBoundaries();

  // --- Lancer les animations ---
  const chineseCharDelay = (readChars.length > 0 && readCPM > 0) ? (60000 / readCPM) : Infinity;
  const minDelay = 10;
  const effectiveChineseDelay = Math.max(minDelay, chineseCharDelay);

  // === NOUVELLE LOGIQUE DE TIMING ===
  let translationCharDelay = null; // null = mode Superzen (dynamique), valeur = mode Frappe (fixe)

  if (!readSuperZen) {
      // On est en mode "Frappe" normal. On force la synchro globale.
      const totalChineseDuration = readChars.length * effectiveChineseDelay;
      if (readTranslationChars.length > 0) {
          translationCharDelay = totalChineseDuration / readTranslationChars.length;
          translationCharDelay = Math.max(minDelay, translationCharDelay); // Appliquer le délai minimum
      }
      console.log(`SYNC MODE: Global. ZH Delay: ${effectiveChineseDelay.toFixed(2)}ms. TR Delay: ${translationCharDelay ? translationCharDelay.toFixed(2) : 'N/A'}ms`);
  } else {
      console.log("SYNC MODE: Superzen (par phrase).");
  }
  // === FIN NOUVELLE LOGIQUE ===

  if (readChars.length > 0 && chineseCharDelay !== Infinity) {
      scheduleNextChineseChar(effectiveChineseDelay);
  } else {
      checkAnimationEnd();
  }

  // Lancer la traduction - elle calculera son premier délai à l'intérieur
  if (readTranslationChars.length > 0) {
      // On passe le délai (fixe ou null)
      scheduleNextTranslationChar(translationCharDelay); 
  } else {
       checkAnimationEnd();
  }
}

// --- Fonction pour arrêter toutes les animations ---
function stopTypeAnimation() {
  readIsPlaying = false;

  if (readTimer) { clearTimeout(readTimer); readTimer = null; }
  if (readTranslationTimer) { clearTimeout(readTranslationTimer); readTranslationTimer = null; }
  if (readPauseTimeout) { clearTimeout(readPauseTimeout); readPauseTimeout = null; }

  // Mettre à jour l'icône Play/Pause... (comme avant)
  const btn = document.getElementById('readPlayPause');
  if (btn) btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
  const szBtn = document.getElementById('szBtnPlay');
  if (szBtn && readSuperZen) szBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
}



// Fonction récursive pour l'animation chinoise
function scheduleNextChineseChar(delay) {
    if (!readIsPlaying || readCurrentIndex >= readChars.length) {
        checkAnimationEnd();
        return;
    }
    const char = readChars[readCurrentIndex];
    if (char) char.style.visibility = 'visible';
    readCurrentIndex++;
    const progress = (readCurrentIndex / readChars.length) * 100;
    const progressBar = document.getElementById('readProgressBar');
    if (progressBar) progressBar.style.width = `${progress}%`;
    if(readTimer) clearTimeout(readTimer); // Sécurité
    readTimer = setTimeout(() => scheduleNextChineseChar(delay), delay);
}

// --- Fonction récursive pour l'animation de traduction (MODIFIED - calcule délai DYNAMIQUEMENT) ---
function scheduleNextTranslationChar(forcedDelay = null) {
    if (!readIsPlaying || readTranslationCurrentIndex >= readTranslationChars.length) {
        checkAnimationEnd();
        return;
    }

    let translationCharDelay = 500; // Un délai par défaut
    const minDelay = 10; // Délai minimum

    if (forcedDelay !== null) {
        // --- CAS 1: Mode "Frappe" Normal (Délai global fixe) ---
        translationCharDelay = forcedDelay;
    } else {
        // --- CAS 2: Mode "Superzen" (Délai dynamique par phrase) ---
        // (C'est l'ancienne logique, qui fonctionne pour Superzen)
        if (readSentenceBoundaries.length === 0) {
             console.error("Superzen: Pas de boundaries. Fallback.");
             translationCharDelay = (readCPM > 0) ? (60000 / readCPM) : 500;
        } else {
            // 1. Trouver la phrase (boundary) correspondant à l'index de traduction ACTUEL
            let currentSentenceData = null;
            let boundaryIndex = -1;
            for(let i = 0; i < readSentenceBoundaries.length; i++) {
                // La boundary est valide si l'index de traduction est DANS ses limites de traduction
                if (readTranslationCurrentIndex >= readSentenceBoundaries[i].translationStart &&
                    readTranslationCurrentIndex < readSentenceBoundaries[i].translationEnd)
                {
                     currentSentenceData = readSentenceBoundaries[i];
                     boundaryIndex = i;
                     break;
                }
            }
            // Cas spécial: si l'index de traduction a dépassé la fin, mais qu'il en reste (peut arriver si boundaries imparfaites)
            // On prend la dernière boundary comme référence pour le délai.
             if (!currentSentenceData && readTranslationCurrentIndex < readTranslationChars.length && readSentenceBoundaries.length > 0) {
                 currentSentenceData = readSentenceBoundaries[readSentenceBoundaries.length - 1];
                 boundaryIndex = readSentenceBoundaries.length - 1;
                 console.warn("Translation index out of bounds, using last sentence data.");
             }

            // 2. Calculer le délai basé sur la durée de la phrase chinoise correspondante
            if (currentSentenceData) {
                const chineseCharDelay = (readCPM > 0) ? (60000 / readCPM) : 500;
                // Durée totale de la phrase chinoise (ms)
                const chineseSentenceDuration = currentSentenceData.chineseLength * chineseCharDelay;

                // Calculer le délai par caractère de traduction pour CETTE phrase
                if (currentSentenceData.translationLength > 0 && chineseSentenceDuration > 0) {
                    translationCharDelay = chineseSentenceDuration / currentSentenceData.translationLength;
                } else if (currentSentenceData.translationLength > 0 && chineseSentenceDuration <= 0) {
                    // Si phrase chinoise vide/instantanée, utiliser vitesse de base
                    translationCharDelay = chineseCharDelay;
                } else {
                    // Pas de traduction pour cette phrase, délai infini (ne devrait pas arriver ici si check initial ok)
                     translationCharDelay = Infinity;
                }
            } else {
                // Pas trouvé de boundary valide -> utiliser délai par défaut
                console.warn("Could not find sentence boundary for translation index:", readTranslationCurrentIndex);
                translationCharDelay = (readCPM > 0) ? (60000 / readCPM) : 500;
            }
        }
    }

    // Assurer un délai minimum
    translationCharDelay = Math.max(minDelay, translationCharDelay);

    // 3. Révéler et Planifier (si délai valide)
    if (translationCharDelay !== Infinity) {
        const trChar = readTranslationChars[readTranslationCurrentIndex];
        if (trChar) trChar.style.visibility = 'visible';
        readTranslationCurrentIndex++;

        // Planifier le prochain avec le délai calculé (et passer forcedDelay à nouveau)
        if(readTranslationTimer) clearTimeout(readTranslationTimer); // Clear previous
        readTranslationTimer = setTimeout(() => scheduleNextTranslationChar(forcedDelay), translationCharDelay);
    } else {
        // Délai infini (pas de trad pour cette phrase?), attendre simplement la fin du chinois
        checkAnimationEnd(); // Vérifier si le chinois est fini
        // Ne pas replanifier ce timer s'il n'y a rien à faire
    }
}


// --- Fonction pour vérifier si les deux animations sont terminées ---
function checkAnimationEnd() {
    if (!readIsPlaying && !document.getElementById('readPage').classList.contains('active')) return;

    const chineseDone = readCurrentIndex >= readChars.length;
    const translationDone = readTranslationCurrentIndex >= readTranslationChars.length;

    if (chineseDone && translationDone && readIsPlaying) {
        console.log("Animations terminées (Per Sentence Fixed Delay) !");
        stopTypeAnimation(); // Met l'état à false et met à jour l'UI

        if (readSuperZen && readSuperZenType && readCurrentSentence < readSentences.length - 1) {
             if (readPauseTimeout) clearTimeout(readPauseTimeout);
             readPauseTimeout = setTimeout(() => {
                  if(readSuperZen && readSuperZenType && readIsPlaying === false) {
                    superZenNext();
                  }
             }, 1500); // Pause
        }
    }
}


// Assurez-vous que togglePlayPause utilise bien start/stop (Unchanged from correct previous version)
function togglePlayPause() {
  if (readIsPlaying) {
    // PAUSING
    console.log("Pausing animation...");
    stopTypeAnimation(); // Met l'état à false et nettoie les timers
  } else {
    // RESUMING (Only if in a typing mode)
    if (readDisplayMode === 'type' || readSuperZenType) {
      console.log("Resuming animation...");
      readIsPlaying = true; // Set state to playing

      // --- Update button icons ---
      const btn = document.getElementById('readPlayPause');
      if (btn) btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';
      const szBtn = document.getElementById('szBtnPlay');
      if (szBtn && readSuperZen) szBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';

      // --- Re-schedule the next character reveal WITHOUT resetting indices ---
      // Recalculate delays based on current state (important for translation)
      const chineseCharDelay = (readChars.length > 0 && readCPM > 0) ? (60000 / readCPM) : Infinity;
      const minDelay = 10;
      const effectiveChineseDelay = Math.max(minDelay, chineseCharDelay);

      // === NOUVELLE LOGIQUE DE TIMING (POUR REPRISE) ===
      let translationCharDelay = null; // null = mode Superzen (dynamique)
      if (!readSuperZen) {
          // On est en mode "Frappe" normal. On re-calcule le délai fixe.
          const totalChineseDuration = readChars.length * effectiveChineseDelay;
          if (readTranslationChars.length > 0) {
              translationCharDelay = totalChineseDuration / readTranslationChars.length;
              translationCharDelay = Math.max(minDelay, translationCharDelay);
          }
      }
      // === FIN NOUVELLE LOGIQUE ===


      // Re-schedule Chinese character if not finished
      if (readCurrentIndex < readChars.length && chineseCharDelay !== Infinity) {
          if(readTimer) clearTimeout(readTimer); // Clear just in case
          readTimer = setTimeout(() => scheduleNextChineseChar(effectiveChineseDelay), effectiveChineseDelay); // Use delay for first resume tick too
      } else {
           checkAnimationEnd(); // Check if finished
      }

      // Re-schedule Translation character if not finished
      if (readTranslationCurrentIndex < readTranslationChars.length) {
          if(readTranslationTimer) clearTimeout(readTranslationTimer); // Clear just in case
          // Schedule normally, il passera le bon délai (fixe ou null)
          readTranslationTimer = setTimeout(() => scheduleNextTranslationChar(translationCharDelay), 50); // Start check shortly after resume
      } else {
          checkAnimationEnd(); // Check if finished
      }
    }
    // If not in typing mode, clicking play does nothing (button should be disabled anyway)
  }
}

function prepareTranslationForTyping() {
  readTranslationChars = []; // Vider l'array
  readTranslationCurrentIndex = 0; // Réinitialiser l'index

  let translationContainer;

  if (readSuperZen) {
    translationContainer = document.getElementById('readTranslation');
  } else {
    const flipBack = document.querySelector('.flip-back#readTranslation');
    translationContainer = flipBack || document.getElementById('readTranslation');
  }

  if (!translationContainer) {
      console.warn("Translation container not found for typing preparation.");
      return;
  }

  const clone = translationContainer.cloneNode(true);
  translationContainer.innerHTML = '';

  function processNode(node) {
      if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          for (let i = 0; i < text.length; i++) {
              const span = document.createElement('span');
              span.className = 'read-char'; // <--- CORRECTION AJOUTÉE ICI
              span.textContent = text[i];
              span.style.visibility = 'hidden';
              translationContainer.appendChild(span);
              readTranslationChars.push(span);
          }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
          const isParagraph = node.tagName === 'P';
          Array.from(node.childNodes).forEach(processNode);
          if (isParagraph && node !== clone.lastElementChild) {
              const spaceSpan = document.createElement('span');
              spaceSpan.className = 'read-char'; // <--- CORRECTION AJOUTÉE ICI
              spaceSpan.textContent = ' ';
              spaceSpan.style.visibility = 'hidden';
              translationContainer.appendChild(spaceSpan);
              readTranslationChars.push(spaceSpan);
          }
      }
  }
  Array.from(clone.childNodes).forEach(processNode);
   // console.log("Prepared translation chars:", readTranslationChars.length); // Keep for debug if needed
}


function toggleReadMode() {
  stopTypeAnimation(); // Always stop animation when toggling

  const playPauseBtn = document.getElementById('readPlayPause');

  if (readDisplayMode === 'instant') {
    // Switching TO 'type'
    readDisplayMode = 'type';
    startTypeAnimation(); // Start animation (will enable button via updateReadModeButton)
  } else {
    // Switching FROM 'type' TO 'instant'
    readDisplayMode = 'instant';
    // Make sure all text is visible
    readChars.forEach(char => char.style.visibility = 'visible');
    // Ensure translation text (not spans) is visible if prepared
    const translationEl = document.querySelector('#readTranslation, .flip-back#readTranslation');
    if (translationEl) {
        // Option 1: Just show existing spans (simpler)
         readTranslationChars.forEach(char => char.style.visibility = 'visible');
        // Option 2: Re-render original text (cleaner but might cause flicker)
        // renderReadText(); // Re-rendering handles visibility based on new mode
    }
    const progressBar = document.getElementById('readProgressBar');
    if(progressBar) progressBar.style.width = '100%';
    // Disable play button explicitly here as updateReadModeButton runs right after
    if(playPauseBtn) playPauseBtn.disabled = true;
  }
  updateReadModeButton(); // Update visual state of toggle button and play button
  updateFocusButtonState();
}

function updateReadModeButton() {
  const btn = document.getElementById('readModeToggle');
  if (btn) {
    const span = btn.querySelector('span');
    if (readDisplayMode === 'instant') {
      span.textContent = 'Instant';
      btn.classList.remove('active'); // Remove active class in instant mode
    } else { // 'type' mode
      span.textContent = 'Frappe';
      btn.classList.add('active'); // Add active class in type mode
    }
  }
  // Also update the main play/pause button state based on the mode
  const playPauseBtn = document.getElementById('readPlayPause');
  if(playPauseBtn) {
      // Disable if mode is 'instant'
      playPauseBtn.disabled = (readDisplayMode === 'instant');
  }
}

function toggleSuperZen() {
  const page = document.getElementById('readPage');
  const mainPlayPauseBtn = document.getElementById('readPlayPause');
  const szPlayBtn = document.getElementById('szBtnPlay');

  readSuperZen = !readSuperZen;
  stopTypeAnimation(); 

  if (readSuperZen) {
    // Entrée en Super Zen
    page.classList.add('super-zen');
    readCurrentSentence = 0;
    readSuperZenType = false; 
    
    // szCurrentFontSize a été supprimé
    
    const typeBtn = document.getElementById('szBtnType');
    if(typeBtn) typeBtn.classList.remove('active');

    if(mainPlayPauseBtn) mainPlayPauseBtn.disabled = true;
    if(szPlayBtn) szPlayBtn.disabled = true;

    renderReadText(); 
    readChars.forEach(char => char.style.visibility = 'visible');
    readTranslationChars.forEach(char => char.style.visibility = 'visible');

  } else {
    // Sortie de Super Zen
    page.classList.remove('super-zen');
    readSuperZenType = false;
    isFlipped = false; 

    if(mainPlayPauseBtn) {
        mainPlayPauseBtn.disabled = (readDisplayMode === 'instant');
    }

    renderReadText(); 
    
    // --- AJOUT : Effacer les styles de police Super Zen ---
    const readTextEl = document.getElementById('readText');
    const readTranslationEl = document.getElementById('readTranslation');
    if(readTextEl) readTextEl.style.fontSize = ''; // Effacer le style en ligne
    if(readTranslationEl) readTranslationEl.style.fontSize = ''; // Effacer le style en ligne
    applyReadStyles(); // Ré-appliquer les styles normaux

    if (readDisplayMode === 'type') {
      startTypeAnimation();
    } else {
      readChars.forEach(char => char.style.visibility = 'visible');
      const translationEl = document.querySelector('#readTranslation, .flip-back#readTranslation');
       if (translationEl) {
           Array.from(translationEl.querySelectorAll('span')).forEach(span => span.style.visibility = 'visible');
       }
    }
  }
  
  updateFocusButtonState();

  const flipBtn = document.getElementById('readFlipBtn');
  const container = document.getElementById('readTextContainer');
  const isMobile = window.matchMedia('(max-width: 900px)').matches;
  if(flipBtn && container){
      flipBtn.style.display = (isMobile && !readSuperZen && readTranslations.length > 0 && container.classList.contains('has-flip')) ? 'flex' : 'none';
  }
}


function toggleSuperZenType() {
  const btn = document.getElementById('szBtnType');
  const szPlayBtn = document.getElementById('szBtnPlay');
  if (!btn || !szPlayBtn) return;

  readSuperZenType = !readSuperZenType;

  if (readSuperZenType) {
    // Entering SZ Typing
    btn.classList.add('active');
    szPlayBtn.disabled = false; // Enable SZ play button
    // Render might be needed if switching from non-SZ type mode,
    // but startTypeAnimation includes prepare/hide steps anyway.
    // renderReadText(); // Optional, depends if content needs refreshing
    startTypeAnimation(); // Start animation for the current sentence
  } else {
    // Exiting SZ Typing
    btn.classList.remove('active');
    stopTypeAnimation();
    szPlayBtn.disabled = true; // Disable SZ play button
    // Make sure all text for the current sentence is visible
    readChars.forEach(char => char.style.visibility = 'visible');
    readTranslationChars.forEach(char => char.style.visibility = 'visible');
  }
}

function superZenNext() {
  if (readCurrentSentence < readSentences.length - 1) {
    stopTypeAnimation(); // Arrête l'anim en cours
    readCurrentSentence++;
    renderReadText(); // Affiche la nouvelle phrase
    if (readSuperZenType) {
      startTypeAnimation(); // Redémarre l'anim si on est en mode frappe
    } else {
       // Sinon s'assurer que tout est visible
        readChars.forEach(char => char.style.visibility = 'visible');
        readTranslationChars.forEach(char => char.style.visibility = 'visible');
    }
  }
}

function superZenPrev() {
  if (readCurrentSentence > 0) {
    stopTypeAnimation();
    readCurrentSentence--;
    renderReadText();
    if (readSuperZenType) {
      startTypeAnimation();
    } else {
       readChars.forEach(char => char.style.visibility = 'visible');
       readTranslationChars.forEach(char => char.style.visibility = 'visible');
    }
  }
}

function superZenTogglePlay() {
  // Fonctionne seulement si on est en mode frappe Super Zen
  if(readSuperZenType) {
      togglePlayPause();
  }
}

function adjustFontSize(delta) {
  readFontSize = Math.max(16, Math.min(72, readFontSize + delta));
  document.getElementById('readFontSize').textContent = readFontSize + 'px';
  applyReadStyles(); // Appeler la nouvelle fonction
}

function toggleFlip() {
  const flipContainer = document.getElementById('flipContainer');
  if (flipContainer) {
    isFlipped = !isFlipped;
    flipContainer.classList.toggle('flipped');

    // Ajuste la hauteur après le début de l'animation (300ms est la moitié de 0.6s)
    // pour lire la hauteur de la face qui devient visible.
    setTimeout(adjustFlipHeight, 300); 
  }
}

function adjustFlipHeight() {
    const flipContainer = document.getElementById('flipContainer');
    // Vérifie si on est en mode flip mobile
    if (flipContainer && flipContainer.closest('.has-flip') && window.matchMedia('(max-width: 900px)').matches) {
        const flipInner = flipContainer.querySelector('.flip-inner');
        const activeFace = flipContainer.querySelector(isFlipped ? '.flip-back' : '.flip-front');

        if (flipInner && activeFace) {
            // S'assure que la face est visible pour calculer scrollHeight
            const wasHidden = activeFace.style.visibility === 'hidden';
            if (wasHidden) activeFace.style.visibility = 'visible'; // Rend temporairement visible si besoin

            const contentHeight = activeFace.scrollHeight;
            flipInner.style.height = `${contentHeight}px`; // Applique la hauteur au conteneur interne

            if (wasHidden) activeFace.style.visibility = 'hidden'; // Cache à nouveau si c'était le cas

            // Optionnel: Log pour débogage
            // console.log(`AdjustFlipHeight: Flipped=${isFlipped}, Face=${activeFace.classList.contains('flip-back') ? 'Back' : 'Front'}, Height=${contentHeight}px`);
        }
    }
}

function toggleFocusMode() {
  readFocusMode = !readFocusMode;
  const btn = document.getElementById('readFocusToggle');
  if(btn) btn.classList.toggle('active');

  applyReadColors(); // Applique le filtrage/masquage

  if (readFocusMode) {
    showCopyNotification();
  }
}

function showCopyNotification() {
  let notif = document.getElementById('copyNotification');
  if (!notif) {
    notif = document.createElement('div');
    notif.id = 'copyNotification';
    notif.style.cssText = `
      position: fixed; top: 80px; right: 24px; background: var(--accent);
      color: white; padding: 12px 20px; border-radius: 8px; font-size: 14px;
      font-weight: 600; box-shadow: var(--shadow); z-index: 10000;
      opacity: 0; transform: translateY(-10px); transition: all 0.3s ease;
      pointer-events: none;
    `;
    notif.textContent = '📋 Mots copiés !';
    document.body.appendChild(notif);
  }

  setTimeout(() => {
    notif.style.opacity = '1';
    notif.style.transform = 'translateY(0)';
  }, 10);

  setTimeout(() => {
    notif.style.opacity = '0';
    notif.style.transform = 'translateY(-10px)';
  }, 2000);
}

function closeReadMode() {
  stopTypeAnimation();
  document.getElementById('readPage').classList.remove('active');
  document.getElementById('homePage').style.display = 'block';

  const flipBtn = document.getElementById('readFlipBtn');
  if (flipBtn) flipBtn.style.display = 'none';

  // Réinitialiser les états spécifiques au mode lecture
  readSuperZen = false;
  readSuperZenType = false;
  isFlipped = false;
  readFocusMode = false;
  readIsPlaying = false;
}

// =====================================================
// MODAL FUNCTIONS (Génériques)
// =====================================================
function showSentencesPreviewModal(zhSentences, trSentences) {
    const modal = document.getElementById('sentencesPreviewModal');
    const body = document.getElementById('sentencesPreviewModalBody');
     if(!modal || !body) return;

    body.innerHTML = '';

    const count = Math.max(zhSentences.length, trSentences.length);
    if (count === 0) {
        body.textContent = "Aucune phrase à afficher.";
    } else {
        for (let i = 0; i < count; i++) {
            const item = document.createElement('div');
            item.className = 'sentence-preview-item';
            const num = document.createElement('div');
            num.className = 'sentence-preview-number'; num.textContent = i + 1;
            const texts = document.createElement('div');
            texts.className = 'sentence-preview-texts';
            const zhDiv = document.createElement('div');
            zhDiv.className = 'sentence-preview-zh'; zhDiv.textContent = zhSentences[i] || '(Pas de texte chinois)';
            const trDiv = document.createElement('div');
            trDiv.className = 'sentence-preview-tr'; trDiv.textContent = trSentences[i] || '(Pas de traduction)';
            texts.appendChild(zhDiv); texts.appendChild(trDiv);
            item.appendChild(num); item.appendChild(texts);
            body.appendChild(item);
        }
    }
    modal.classList.add('active');
}


// =====================================================
// EVENT LISTENERS (DOM LOADED)
// =====================================================
document.addEventListener('DOMContentLoaded', () => {
  console.log('=== APP FUSIONNÉE CHARGÉE (v2 - Read Fixes) ===');
  // Installe les écouteurs de resize/orientation/visualViewport pour le calcul de max-height
if (typeof bindResizeForAvailableWords === 'function') {
  bindResizeForAvailableWords();
}

// Premier calcul global (utile si on démarre directement en jeu sur mobile)
if (typeof resizeAvailableWords === 'function') {
  requestAnimationFrame(resizeAvailableWords);
}
const launchTextEl = document.getElementById('launchText');
      if (launchTextEl) {
        launchTextEl.textContent = 'Lancer la lecture';
      }
  // --- Éléments ---
  const modeGameBtn = document.getElementById('modeGameBtn');
  const modeReadBtn = document.getElementById('modeReadBtn');
  const tab1Btn = document.getElementById('tab1Btn');
  const tab2Btn = document.getElementById('tab2Btn');
  const themeBtns = document.querySelectorAll('.theme-btn');
  const gameCategoryBtns = document.querySelectorAll('#gameCategorySelector .category-btn');
  const gameHskBtns = document.querySelectorAll('#gameHskSelector .hsk-selector-btn');
  const gameFreqBtns = document.querySelectorAll('#gameFreqSelector .hsk-selector-btn');
  const readCategoryBtns = document.querySelectorAll('#readCategorySelector .category-btn');
  const readHskBtns = document.querySelectorAll('#hskSelector .hsk-selector-btn');
  const readFreqBtns = document.querySelectorAll('#freqSelector .hsk-selector-btn');
  const cpmAttackSlider = document.getElementById('cpmAttackTarget');
  const cpmReadSlider = document.getElementById('cpm');
  const inputZh = document.getElementById('inputZh');
  const inputTr = document.getElementById('inputTr');
  const dictFileInput = document.getElementById('dictFile');
  const hskFileInput = document.getElementById('hskFile');
  const launchBtn = document.getElementById('launchBtn');
  const quitGameBtn = document.getElementById('quitGameBtn');
  const hintBtn = document.getElementById('hintBtn');
  const validateBtn = document.getElementById('validateBtn');
  const prevSentenceBtn = document.getElementById('prevSentenceBtn');
  const nextSentenceBtn = document.getElementById('nextSentenceBtn');
  const restartBtn = document.getElementById('restartBtn');
  const gameModeSelect = document.getElementById('gameMode');

  const readCloseBtn = document.getElementById('readCloseBtn');
  const readPlayPauseBtn = document.getElementById('readPlayPause');
  const readModeToggleBtn = document.getElementById('readModeToggle');
  const readZenToggleBtn = document.getElementById('readZenToggle');
  const readFocusToggleBtn = document.getElementById('readFocusToggle');
  const readFontUpBtn = document.getElementById('readFontUp');
  const readFontDownBtn = document.getElementById('readFontDown');
  const readFlipBtn = document.getElementById('readFlipBtn');
  const readProgress = document.getElementById('readProgress');

  const szBtnQuit = document.getElementById('szBtnQuit');
  const szBtnType = document.getElementById('szBtnType');
  const szBtnPrev = document.getElementById('szBtnPrev');
  const szBtnPlay = document.getElementById('szBtnPlay');
  const szBtnNext = document.getElementById('szBtnNext');

  const closeDictModalBtn = document.getElementById('closeDictModal');
  const closeSentencesPreviewModalBtn = document.getElementById('closeSentencesPreviewModal');
  const dictModalEl = document.getElementById('dictModal');
  const sentencesPreviewModalEl = document.getElementById('sentencesPreviewModal');
  
  // --- NOUVEAU : GESTIONNAIRE D'ONGLETS POUR LE DICTIONNAIRE ---
  const globalTabsContainer = document.getElementById('dictTabsContainer');
  if (globalTabsContainer) {
    globalTabsContainer.addEventListener('click', (e) => {
      const clickedTab = e.target.closest('.dict-tab-btn');
      if (!clickedTab) return; // Clic en dehors d'un bouton

      const tabId = clickedTab.dataset.tabId;
      if (!tabId) return;
      
      const modalContent = clickedTab.closest('.dict-modal-content');
      if (!modalContent) return;

      // 1. Désactiver tous les onglets et panneaux
      modalContent.querySelectorAll('.dict-tab-btn').forEach(btn => btn.classList.remove('active'));
      modalContent.querySelectorAll('.dict-pane').forEach(pane => pane.classList.remove('active'));

      // 2. Activer le bon
      clickedTab.classList.add('active');
      const targetPane = modalContent.querySelector(`#${tabId}`);
      if (targetPane) {
        targetPane.classList.add('active');
      }
    });
  }

  // --- Attachement des listeners ---
  if(modeGameBtn) modeGameBtn.addEventListener('click', () => switchMode('game'));
  if(modeReadBtn) modeReadBtn.addEventListener('click', () => switchMode('read'));
  if(tab1Btn) tab1Btn.addEventListener('click', () => switchTab('1'));
  if(tab2Btn) tab2Btn.addEventListener('click', () => switchTab('2'));

  themeBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const theme = this.dataset.theme;
      document.body.setAttribute('data-theme', theme);
      themeBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
    });
  });

  gameCategoryBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const category = this.dataset.category;
      gameCategoryBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      const gameHskSel = document.getElementById('gameHskSelector');
      const gameFreqSel = document.getElementById('gameFreqSelector');
      if(gameHskSel && gameFreqSel) {
          gameHskSel.style.display = category === 'hsk' ? 'grid' : 'none';
          gameFreqSel.style.display = category === 'hsk' ? 'none' : 'grid';
      }
    });
  });
  gameHskBtns.forEach(btn => btn.addEventListener('click', function() { this.classList.toggle('active'); }));
  gameFreqBtns.forEach(btn => btn.addEventListener('click', function() { this.classList.toggle('active'); }));

  readCategoryBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const category = this.dataset.category;
      readCategory = category; // Mettre à jour la variable globale
      readCategoryBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      const hskSel = document.getElementById('hskSelector');
      const freqSel = document.getElementById('freqSelector');
      const label = document.getElementById('levelSelectorLabel');
      if(hskSel && freqSel && label) {
          hskSel.style.display = category === 'hsk' ? 'grid' : 'none';
          freqSel.style.display = category === 'hsk' ? 'none' : 'grid';
          label.textContent = category === 'hsk' ? 'Niveaux HSK à surligner' : 'Tranches de fréquence à surligner';
      }
      // Mettre à jour les filtres affichés si on est en mode lecture
      if (document.getElementById('readPage').classList.contains('active')) {
          createReadFilters();
          applyReadColors();
          updateReadDifficulty();
      }
    });
  });
  readHskBtns.forEach(btn => btn.addEventListener('click', function() { this.classList.toggle('active'); }));
  readFreqBtns.forEach(btn => btn.addEventListener('click', function() { this.classList.toggle('active'); }));

  if(cpmAttackSlider) cpmAttackSlider.addEventListener('input', (e) => {
    const valueEl = document.getElementById('cpmAttackTargetValue');
    if(valueEl) valueEl.textContent = e.target.value + ' car/min';
  });
  if(cpmReadSlider) cpmReadSlider.addEventListener('input', (e) => {
    const valueEl = document.getElementById('cpmValue');
    readCPM = parseInt(e.target.value, 10); // Mettre à jour la variable globale
    if(valueEl) valueEl.textContent = readCPM + ' car/min';
  });
  
  const readInterligneSlider = document.getElementById('readInterligne_slider'); // <-- ID CORRIGÉ
  const readInterligneValue = document.getElementById('readInterligneValue');
  const readLineHeightSpan = document.getElementById('readLineHeight'); // Span de la toolbar

  if (readInterligneSlider && readInterligneValue) {
      readInterligneSlider.addEventListener('input', (e) => {
          const percent = e.target.value;
          readInterligne = parseFloat(percent) / 100;
          readInterligneValue.textContent = percent + '%'; // Met à jour le span du slider
          if (readLineHeightSpan) readLineHeightSpan.textContent = percent + '%'; // Met à jour le span de la toolbar
          applyReadStyles();
      });
  }

  const readSpacingSlider = document.getElementById('readSpacing_slider'); // <-- ID CORRIGÉ
  const readSpacingValue = document.getElementById('readSpacingValue');
  const readSpacingSpan = document.getElementById('readSpacing'); // Span de la toolbar

  if (readSpacingSlider && readSpacingValue) {
      readSpacingSlider.addEventListener('input', (e) => {
          const px = e.target.value;
          readSpacing = parseInt(px, 10);
          readSpacingValue.textContent = px + ' px'; // Met à jour le span du slider
          if (readSpacingSpan) readSpacingSpan.textContent = px + ' px'; // Met à jour le span de la toolbar
          applyReadStyles();
      });
  }

  if(inputZh) inputZh.addEventListener('input', updateSentencesPreview);
  if(inputTr) inputTr.addEventListener('input', updateSentencesPreview);

if(dictFileInput) dictFileInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = () => { 
      dict = parseCedict(reader.result); 
      document.getElementById('dictStatus').innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="var(--correct)" stroke-width="2" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 4px; margin-top: -2px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg> (${dict.wordSet.size} mots)`; 
    };
    reader.readAsText(file, 'utf-8');
  });
  if(hskFileInput) hskFileInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = () => { 
      levelMap = csvToLevelMap(reader.result); 
      document.getElementById('hskStatus').innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="var(--correct)" stroke-width="2" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 4px; margin-top: -2px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg> (${levelMap.size} mots)`; 
    };
    reader.readAsText(file, 'utf-8');
  });

  if (launchBtn) {
    launchBtn.addEventListener('click', () => {
      if (appMode === 'game') {
        startGame();
      } else {
        // Mode Lecture
        const readModeSetting = document.getElementById('readDisplayModeSetting').value;
        const oldDisplayModeSelect = document.getElementById('displayMode');

        // S'assurer que l'ancien <select> masqué a la bonne valeur
        if (readModeSetting === 'instant' || readModeSetting === 'superzen') {
          oldDisplayModeSelect.value = 'instant';
        } else { // 'type'
          oldDisplayModeSelect.value = 'type';
        }

        // Lancer la lecture
        startReadMode();

        // Si Superzen est choisi, l'activer juste après le lancement
        if (readModeSetting === 'superzen') {
          // Petit délai pour laisser à startReadMode le temps de s'initialiser
          setTimeout(toggleSuperZen, 50); 
        }
      }
    });
  }

  // GAME BUTTONS
  if(quitGameBtn) quitGameBtn.addEventListener('click', quitGame);
  if(hintBtn) hintBtn.addEventListener('click', giveHint);
  if(validateBtn) validateBtn.addEventListener('click', validateAnswer);
  if(restartBtn) restartBtn.addEventListener('click', loadSentence);
  if(prevSentenceBtn) prevSentenceBtn.addEventListener('click', () => goToSentence(-1));
  if(nextSentenceBtn) nextSentenceBtn.addEventListener('click', () => goToSentence(1));
  
  const gameModeSelector = document.getElementById('gameModeSelector');
  const gameModeInput = document.getElementById('gameMode'); // Le hidden input

  if (gameModeSelector && gameModeInput) {
  // Gérer le clic sur la grille de boutons
  gameModeSelector.addEventListener('click', (e) => {
    const button = e.target.closest('.game-mode-btn');
    if (!button) return; // Clic en dehors d'un bouton

    const newMode = button.dataset.mode;
    
    // 1. Mettre à jour la valeur de l'input caché
    gameModeInput.value = newMode;
    
    // 2. Mettre à jour l'UI (classe 'active')
    gameModeSelector.querySelectorAll('.game-mode-btn').forEach(btn => btn.classList.remove('active'));
    button.classList.add('active');

    // 3. Appeler la fonction existante qui met à jour les options
    updateGameOptionsUI(); 
  });
}

const readDisplaySelector = document.getElementById('readDisplayModeSelector');
  const readDisplayInput = document.getElementById('readDisplayModeSetting');
  const oldDisplayModeSelect = document.getElementById('displayMode'); // L'ancien <select> masqué

  if (readDisplaySelector && readDisplayInput && oldDisplayModeSelect) {
      readDisplaySelector.addEventListener('click', (e) => {
          const button = e.target.closest('.display-mode-btn');
          if (!button) return;

          const newMode = button.dataset.mode;
          
          // 1. Mettre à jour l'input caché qui stocke notre choix
          readDisplayInput.value = newMode;

          // 2. Mettre à jour l'ancien <select> masqué pour compatibilité
          if (newMode === 'instant' || newMode === 'superzen') {
              oldDisplayModeSelect.value = 'instant';
          } else { // 'type'
              oldDisplayModeSelect.value = 'type';
          }

          // 3. Mettre à jour l'interface des boutons
          readDisplaySelector.querySelectorAll('.display-mode-btn').forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
      });
  }

const freeInputDisplaySelector = document.getElementById('freeInputDisplaySelector');
const freeInputDisplayModeInput = document.getElementById('freeInputDisplayMode');

if (freeInputDisplaySelector && freeInputDisplayModeInput) {
    freeInputDisplaySelector.addEventListener('click', (e) => {
        const button = e.target.closest('.display-mode-btn');
        if (!button) return;

        const newMode = button.dataset.mode;
        freeInputDisplayModeInput.value = newMode;

        freeInputDisplaySelector.querySelectorAll('.display-mode-btn').forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
    });
}

  // READ BUTTONS
  if(readCloseBtn) readCloseBtn.addEventListener('click', closeReadMode);
  if(readPlayPauseBtn) readPlayPauseBtn.addEventListener('click', togglePlayPause);
  if(readModeToggleBtn) readModeToggleBtn.addEventListener('click', toggleReadMode);
  if(readZenToggleBtn) readZenToggleBtn.addEventListener('click', toggleSuperZen);
  if(readFocusToggleBtn) readFocusToggleBtn.addEventListener('click', toggleFocusMode);
 
  const readInterligneDownBtn = document.getElementById('readInterligneDown');
  const readInterligneUpBtn = document.getElementById('readInterligneUp');
  const readSpacingDownBtn = document.getElementById('readSpacingDown');
  const readSpacingUpBtn = document.getElementById('readSpacingUp');
 if(readFontUpBtn) readFontUpBtn.addEventListener('click', () => adjustFontSize(4));
  if(readFontDownBtn) readFontDownBtn.addEventListener('click', () => adjustFontSize(-4));
  // Attacher les listeners aux nouveaux boutons
  if(readInterligneDownBtn) readInterligneDownBtn.addEventListener('click', () => adjustInterligne(-5));
  if(readInterligneUpBtn) readInterligneUpBtn.addEventListener('click', () => adjustInterligne(5));
  if(readSpacingDownBtn) readSpacingDownBtn.addEventListener('click', () => adjustSpacing(-1));
  if(readSpacingUpBtn) readSpacingUpBtn.addEventListener('click', () => adjustSpacing(1));

  // Le listener pour le flip button (qui était juste après votre bloc)
  if(readFlipBtn) readFlipBtn.addEventListener('click', toggleFlip);
  

  // --- GESTION CACHER/AFFICHER CONTROLES MOBILE ---
  const readPage = document.getElementById('readPage');
  const hideControlsBtn = document.getElementById('hideControlsBtn');
  const showControlsBtn = document.getElementById('showControlsBtn');

  if (readPage && hideControlsBtn && showControlsBtn) {
    hideControlsBtn.addEventListener('click', () => {
      readPage.classList.add('controls-hidden');
    });

    showControlsBtn.addEventListener('click', () => {
      readPage.classList.remove('controls-hidden');
    });
  }

  // SUPER ZEN BUTTONS
  if(szBtnQuit) szBtnQuit.addEventListener('click', toggleSuperZen); // Quitter revient à désactiver le mode
  if(szBtnType) szBtnType.addEventListener('click', toggleSuperZenType);
  if(szBtnPrev) szBtnPrev.addEventListener('click', superZenPrev);
  if(szBtnNext) szBtnNext.addEventListener('click', superZenNext);
  if(szBtnPlay) szBtnPlay.addEventListener('click', superZenTogglePlay);

  // --- GESTION DU SWIPER MOBILE ---
  const readControlsInner = document.getElementById('readControlsInner');
  const readControlsDots = document.getElementById('readControlsDots');

  if(readControlsInner && readControlsDots) {
    readControlsInner.addEventListener('scroll', () => {
      // Mettre à jour les dots uniquement si on est en affichage mobile
      if (window.getComputedStyle(readControlsDots).display === 'flex') {
        const panelWidth = readControlsInner.offsetWidth;
        const scrollLeft = readControlsInner.scrollLeft;
        
        // Calculer l'index du panneau le plus proche
        // + panelWidth / 2 pour centrer la détection
        const activeIndex = Math.floor((scrollLeft + panelWidth / 2) / panelWidth);

        readControlsDots.querySelectorAll('.dot').forEach(dot => {
          dot.classList.remove('active');
          if (parseInt(dot.dataset.index) === activeIndex) {
            dot.classList.add('active');
          }
        });
      }
    });
  }
  
 
  // READ PROGRESS BAR
  if(readProgress) readProgress.onclick = (e) => {
    // Ne fonctionne que si l'animation est active ou en pause
    if (readDisplayMode !== 'type' && !readSuperZenType) return;
    if (!readIsPlaying) stopTypeAnimation(); // Stop avant de sauter

    const rect = e.currentTarget.getBoundingClientRect();
    const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)); // Clamp between 0 and 1

    // Calculer les nouveaux index
    readCurrentIndex = Math.floor(percent * readChars.length);
    const ratio = (readTranslationChars.length > 0 && readChars.length > 0) ? readTranslationChars.length / readChars.length : 1;
    readTranslationCurrentIndex = Math.floor(readCurrentIndex * ratio);


    // Mettre à jour l'affichage immédiatement
    readChars.forEach((char, idx) => {
        char.style.visibility = (idx < readCurrentIndex) ? 'visible' : 'hidden';
    });
    readTranslationChars.forEach((char, idx) => {
        char.style.visibility = (idx < readTranslationCurrentIndex) ? 'visible' : 'hidden';
    });

    // Mettre à jour la barre de progression
    const progressBar = document.getElementById('readProgressBar');
    if(progressBar) progressBar.style.width = (percent * 100) + '%';

    // Redémarrer l'animation si elle était en cours
    if (readIsPlaying) {
        // Annuler le timeout précédent pour éviter un double appel
        if (readTimer) clearTimeout(readTimer);
        // Redémarrer après un court délai pour laisser le navigateur rafraîchir
        readTimer = setTimeout(revealNextChar, 50);
    } else {
        // Si on était en pause, on met à jour l'icône car on a avancé
         const btn = document.getElementById('readPlayPause');
         if (btn) btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
         const szBtn = document.getElementById('szBtnPlay');
         if (szBtn && readSuperZen) szBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
    }
  };

  // MODAL CLOSE BUTTONS (Fusionnés)
  if(closeDictModalBtn) closeDictModalBtn.addEventListener('click', () => closeModal('dictModal'));
  if(closeSentencesPreviewModalBtn) closeSentencesPreviewModalBtn.addEventListener('click', () => closeModal('sentencesPreviewModal'));
  if(dictModalEl) dictModalEl.addEventListener('click', (e) => { if(e.target === dictModalEl) closeModal('dictModal'); });
  if(sentencesPreviewModalEl) sentencesPreviewModalEl.addEventListener('click', (e) => { if(e.target === sentencesPreviewModalEl) closeModal('sentencesPreviewModal'); });

const pinyinTypeSelector = document.querySelector('.pinyin-input-type-selector');
  const pinyinTypeInput = document.getElementById('pinyinInputType');

  if (pinyinTypeSelector && pinyinTypeInput) {
      pinyinTypeSelector.addEventListener('click', (e) => {
          const button = e.target.closest('.pinyin-input-type-btn');
          if (!button) return;

          const newType = button.dataset.type;
          pinyinTypeInput.value = newType;
          pinyinInputType = newType; // Mettre à jour la variable globale

          pinyinTypeSelector.querySelectorAll('.pinyin-input-type-btn').forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');

          // Si on est déjà en jeu Pinyin, recharger la phrase pour appliquer le changement
          if (document.getElementById('gamePage').classList.contains('active') && currentGameMode === 'fill-blanks-pinyin') {
              loadSentence();
          }
      });
  }
  
  // 1. Sécurité : on s'assure que le modal dictionnaire est bien tout en haut du DOM
  const modal = document.getElementById('dictModal');
  if (modal && modal.parentNode !== document.body) {
    document.body.appendChild(modal);
  }

  // === DÉBUT DE LA MODIFICATION (V2) ===
  
  // 2. On attache UN SEUL écouteur de clic sur la PAGE de lecture (parent stable)
  const readPageRoot = document.getElementById('readPage'); // <-- PARENT STABLE
  if (readPageRoot && !readPageRoot.dataset.dictBound) {
    
    readPageRoot.addEventListener('click', (e) => {
      
      // 0. Vérifier que le clic provient bien de la zone de texte chinois
      const readTextElement = e.target.closest('#readText, .flip-front.read-text');
      if (!readTextElement) return; // Clic en dehors (ex: sur la traduction, un bouton...)

      // 1. Trouver le wrapper du mot cliqué
      const wordSpanWrapper = e.target.closest('.read-word'); 
      if (!wordSpanWrapper) return; // Clic sur ponctuation ou espace

      // 2. Ouvrir le modal
      const w = wordSpanWrapper.dataset.wordWrapper; 
      if (w) {
          console.log(`Clic (délégué) détecté sur le mot '${w}'`);
          openDictModal(w); 
      } 
      
      // --- NOUVELLE LOGIQUE DE HIGHLIGHT ---
      
      // 3. Trouver tous les caractères de ce mot
      const charsInWord = wordSpanWrapper.querySelectorAll('.read-char');
      
      // 4. Appliquer la classe de tap
      charsInWord.forEach(char => {
          char.classList.add('char-tapped');
      });

      // 5. Retirer la classe après un délai
      setTimeout(() => {
          charsInWord.forEach(char => {
              char.classList.remove('char-tapped');
          });
      }, 400);// Doit correspondre ou être > à la transition CSS
      // --- FIN NOUVELLE LOGIQUE ---

bindResizeForAvailableWords();

    }); // Fin addEventListener
    // === FIN DE LA MODIFICATION ===

    // petit flag pour ne pas binder deux fois si tu relances renderReadText()
    readPageRoot.dataset.dictBound = '1';
  }

  // --- Initialisation finale ---
  updateSentencesPreview();
  switchMode('read');
  updateGameOptionsUI();
  
  // =====================================================
  // CHARGEMENT AUTOMATIQUE DES FICHIERS (AUTO-LOAD)
  // =====================================================
  
  async function autoLoadFiles() {
    // Noms de vos fichiers sur GitHub (respectez les majuscules/minuscules)
    const DICT_FILENAME = 'cedict_ts.u8'; 
    const HSK_FILENAME = 'niveaux.csv'; 

    // 1. Chargement du Dictionnaire
    try {
      const dictStatusEl = document.getElementById('dictStatus');
      if(dictStatusEl) dictStatusEl.textContent = "Chargement auto en cours...";

      const response = await fetch(DICT_FILENAME);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const text = await response.text();
      dict = parseCedict(text); // Utilise votre fonction existante
      
      if(dictStatusEl) {
        dictStatusEl.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="var(--correct)" stroke-width="2" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 4px; margin-top: -2px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg> Auto-chargé (${dict.wordSet.size} mots)`;
        dictStatusEl.style.color = "var(--correct)";
        dictStatusEl.style.borderColor = "var(--correct)";
      }
      console.log("Dictionnaire chargé automatiquement.");
    } catch (e) {
      console.warn("Impossible de charger le dictionnaire automatiquement (Fichier non trouvé ?)", e);
      const dictStatusEl = document.getElementById('dictStatus');
      if(dictStatusEl) dictStatusEl.textContent = "Fichier auto non trouvé (Utilisez l'import manuel)";
    }

    // 2. Chargement de la liste HSK/Freq
    try {
      const hskStatusEl = document.getElementById('hskStatus');
      if(hskStatusEl) hskStatusEl.textContent = "Chargement auto en cours...";

      const response = await fetch(HSK_FILENAME);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      
      const text = await response.text();
      levelMap = csvToLevelMap(text); // Utilise votre fonction existante
      
      if(hskStatusEl) {
        hskStatusEl.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="var(--correct)" stroke-width="2" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 4px; margin-top: -2px;"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg> Auto-chargé (${levelMap.size} mots)`;
        hskStatusEl.style.color = "var(--correct)";
        hskStatusEl.style.borderColor = "var(--correct)";
      }
      
      // Mise à jour immédiate de la difficulté si on est déjà en mode lecture
      if(typeof updateReadDifficulty === 'function') updateReadDifficulty();

      console.log("Liste HSK chargée automatiquement.");
    } catch (e) {
      console.warn("Impossible de charger la liste HSK automatiquement.", e);
      const hskStatusEl = document.getElementById('hskStatus');
      if(hskStatusEl) hskStatusEl.textContent = "Fichier auto non trouvé (Utilisez l'import manuel)";
    }
  }

  // Lancer le chargement automatique
  autoLoadFiles();
  
  console.log('=== INITIALISATION TERMINÉE (Read Fixes Applied) ===');
});


</script>
</body>
</html>
