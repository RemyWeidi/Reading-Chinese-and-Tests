<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lecteur Chinois HSK - Version Complète</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;600;700;800&family=Inter:wght@400;500;600;700;800&family=Noto+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0b0b0c;
  --fg: #f7f7f7;
  --muted: #b5b5b8;
  --panel: #141417;
  --accent: #7aa2ff;
  --card: #101014;
  --border: #22232a;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
  --hsk1: #08d259;
  --hsk2: #229fff;
  --hsk3: #fccf46;
  --hsk4: #ffa52f;
  --hsk5: #ff47c2;
  --hsk6: #c30f54;
  --hsk79: #a0086d;
  --freq1: #4ade80;
  --freq2: #22d3ee;
  --freq3: #60a5fa;
  --freq4: #3b82f6;
  --freq5: #fbbf24;
  --freq6: #fb923c;
  --freq7: #ef4444;
  --freq8: #dc2626;
  --freq9: #7c3aed;
  --correct: #22c55e;
  --incorrect: #ef4444;
}

[data-theme="light"] {
  --bg: #f8fafc;
  --fg: #0f172a;
  --muted: #64748b;
  --panel: #ffffff;
  --accent: #2563eb;
  --card: #ffffff;
  --border: #e2e8f0;
  --shadow: 0 4px 20px rgba(0,0,0,.08);
}

[data-theme="paper"] {
  --bg: #faf8f3;
  --fg: #3e2723;
  --muted: #8d6e63;
  --panel: #fffef7;
  --accent: #d84315;
  --card: #fffef7;
  --border: #d7ccc8;
  --shadow: 0 2px 10px rgba(62,39,35,.1);
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

body {
  font-family: 'Inter', system-ui, sans-serif;
  background: var(--bg);
  color: var(--fg);
  font-size: 16px;
  line-height: 1.6;
  min-height: 100vh;
  transition: background 0.3s, color 0.3s;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 24px;
  padding-bottom: 120px;
}

.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: var(--shadow);
  transition: all 0.3s;
}

.card:hover { transform: translateY(-2px); }

.section-title {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 16px;
  color: var(--fg);
  display: flex;
  align-items: center;
  gap: 8px;
}

.home-header {
  text-align: center;
  margin-bottom: 32px;
  padding: 20px 0;
}

.home-title {
  font-size: 42px;
  font-weight: 800;
  margin-bottom: 8px;
  color: var(--fg);
}

.home-subtitle {
  font-size: 16px;
  color: var(--muted);
}

.mode-toggle-container {
  display: flex;
  gap: 12px;
  margin-bottom: 32px;
  padding: 8px;
  background: var(--panel);
  border-radius: 16px;
  border: 1px solid var(--border);
}

.mode-toggle-btn {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 20px;
  background: transparent;
  border: 2px solid transparent;
  border-radius: 12px;
  color: var(--muted);
  font-weight: 700;
  cursor: pointer;
  font-size: 15px;
  transition: all 0.3s;
}

.mode-toggle-btn:hover { border-color: var(--accent); }
.mode-toggle-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.mode-icon { width: 32px; height: 32px; }

.tabs-container { margin-bottom: 80px; }

.tabs-nav {
  display: flex;
  gap: 8px;
  margin-bottom: 24px;
  padding: 6px;
  background: var(--panel);
  border-radius: 12px;
  border: 1px solid var(--border);
}

.tab-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 14px 20px;
  background: transparent;
  border: none;
  border-radius: 8px;
  color: var(--muted);
  font-weight: 600;
  font-size: 15px;
  cursor: pointer;
  transition: all 0.2s;
}

.tab-btn:hover { background: var(--border); }
.tab-btn.active { background: var(--accent); color: white; }

.tab-number {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  background: rgba(255,255,255,0.1);
  border-radius: 50%;
  font-size: 13px;
  font-weight: 700;
}

.tab-content { display: none; }
.tab-content.active { display: block; animation: fadeIn 0.3s; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.input-group { margin-bottom: 20px; }

.input-group label {
  display: block;
  font-size: 14px;
  font-weight: 600;
  color: var(--muted);
  margin-bottom: 8px;
}

textarea, input[type="file"], select {
  width: 100%;
  padding: 12px 14px;
  font-family: 'Noto Sans SC', 'Inter', sans-serif;
  font-size: 15px;
  background: var(--panel);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 12px;
  outline: none;
  transition: all 0.2s;
}

textarea { min-height: 140px; resize: vertical; }

textarea:focus, input:focus, select:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(122, 162, 255, 0.1);
}

.status-chip {
  display: inline-block;
  margin-top: 8px;
  padding: 6px 12px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  font-size: 13px;
  color: var(--muted);
}
.status-chip.clickable {
    cursor: pointer;
    transition: background 0.2s, color 0.2s;
}
.status-chip.clickable:hover {
    background: var(--border);
    color: var(--fg);
}


.theme-switcher { display: flex; gap: 12px; }

.theme-btn {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 2px solid var(--border);
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.theme-btn:hover { transform: scale(1.1); border-color: var(--accent); }

.theme-btn.active::after {
  content: '✓';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 16px;
  font-weight: bold;
  text-shadow: 0 0 4px rgba(0,0,0,0.5);
}

.theme-dark { background: #0b0b0c; }
.theme-light { background: #f8fafc; }
.theme-paper { background: #faf8f3; }

.category-selector {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
}

.category-btn {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 16px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 12px;
  color: var(--muted);
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.category-btn:hover { transform: translateY(-2px); border-color: var(--accent); }
.category-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

.category-icon { width: 24px; height: 24px; }
.category-label { font-size: 13px; text-transform: uppercase; }

.hsk-selector-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 8px;
}

.hsk-selector-btn {
  padding: 12px 16px;
  border: 2px solid var(--border);
  border-radius: 10px;
  background: var(--panel);
  color: var(--fg);
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  opacity: 0.5;
}

.hsk-selector-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.hsk-selector-btn.active { opacity: 1; border-color: transparent; }

.hsk-selector-btn[data-level="1"].active { background: var(--hsk1); color: #fff; }
.hsk-selector-btn[data-level="2"].active { background: var(--hsk2); color: #fff; }
.hsk-selector-btn[data-level="3"].active { background: var(--hsk3); color: #333; }
.hsk-selector-btn[data-level="4"].active { background: var(--hsk4); color: #fff; }
.hsk-selector-btn[data-level="5"].active { background: var(--hsk5); color: #fff; }
.hsk-selector-btn[data-level="6"].active { background: var(--hsk6); color: #fff; }
.hsk-selector-btn[data-level="7"].active { background: var(--hsk79); color: #fff; }

#freqSelector .hsk-selector-btn[data-level="1"].active,
#gameFreqSelector .hsk-selector-btn[data-level="1"].active { background: var(--freq1); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="2"].active,
#gameFreqSelector .hsk-selector-btn[data-level="2"].active { background: var(--freq2); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="3"].active,
#gameFreqSelector .hsk-selector-btn[data-level="3"].active { background: var(--freq3); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="4"].active,
#gameFreqSelector .hsk-selector-btn[data-level="4"].active { background: var(--freq4); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="5"].active,
#gameFreqSelector .hsk-selector-btn[data-level="5"].active { background: var(--freq5); color: #333; }
#freqSelector .hsk-selector-btn[data-level="6"].active,
#gameFreqSelector .hsk-selector-btn[data-level="6"].active { background: var(--freq6); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="7"].active,
#gameFreqSelector .hsk-selector-btn[data-level="7"].active { background: var(--freq7); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="8"].active,
#gameFreqSelector .hsk-selector-btn[data-level="8"].active { background: var(--freq8); color: #fff; }
#freqSelector .hsk-selector-btn[data-level="9"].active,
#gameFreqSelector .hsk-selector-btn[data-level="9"].active { background: var(--freq9); color: #fff; }

.game-mode-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
  gap: 12px;
}

.game-mode-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 10px;
  padding: 16px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 12px;
  color: var(--muted);
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
  font-size: 14px;
  min-height: 100px; /* Pour un alignement uniforme */
}

.game-mode-btn svg {
  width: 28px;
  height: 28px;
  stroke-width: 2;
}

.game-mode-btn:hover {
  border-color: var(--accent);
  color: var(--fg);
  transform: translateY(-2px);
}

.game-mode-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

.game-mode-btn.active svg {
    color: white; /* Assure que l'icône est blanche si elle hérite de la couleur */
}

.display-mode-selector {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.display-mode-btn {
    padding: 14px 10px;
    background: var(--panel);
    border: 2px solid var(--border);
    border-radius: 10px;
    color: var(--muted);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    font-size: 13px;
}

.display-mode-btn:hover {
    border-color: var(--accent);
    color: var(--fg);
}

.display-mode-btn.active {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
}

.slider-container {
  display: flex;
  align-items: center;
  gap: 12px;
}

.slider {
  flex: 1;
  height: 6px;
  background: var(--border);
  border-radius: 3px;
  outline: none;
  -webkit-appearance: none;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  background: var(--accent);
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

.slider-value {
  min-width: 90px;
  font-size: 13px;
  font-weight: 600;
  color: var(--muted);
  text-align: right;
}

.checkbox-container {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 14px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s;
  margin-bottom: 12px;
}

.checkbox-container:hover {
  border-color: var(--accent);
  background: var(--border);
}

.checkbox-container input[type="checkbox"] {
  width: 20px;
  height: 20px;
  cursor: pointer;
  accent-color: var(--accent);
}

.checkbox-container label {
  flex: 1;
  cursor: pointer;
  font-size: 15px;
  font-weight: 500;
  color: var(--fg);
  margin: 0;
}

.floating-cta {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
}

.btn-launch {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px 32px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 14px;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 8px 24px rgba(122, 162, 255, 0.4);
  transition: all 0.3s;
}

.btn-launch:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 32px rgba(122, 162, 255, 0.5);
}

.launch-icon {
  width: 24px;
  height: 24px;
}

/* ================================================= */
/* ================ PAGE DE JEU ================== */
/* ================================================= */
.game-page {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  overflow: hidden;
  z-index: 9999;
}

.game-page.active { display: flex; flex-direction: column; }

/* --- Styles pour le Timer déplacé --- */
#gameTimer {
  position: fixed; 
  bottom: 10px;       
  left: 50%;       
  transform: translateX(-50%);
  font-size: 32px; 
  font-weight: 700;
  color: var(--accent); 
  z-index: 10000;  
  padding: 0;      
  line-height: 48px; 
  height: 48px;    
  margin: 0;       
}

/* MODIFICATION : Rétablir le style du bouton Quitter pour la barre de navigation */
.btn-quit {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  color: var(--muted);
  border: 2px solid var(--border);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.2s;
  margin-left: auto; /* Positionne le bouton tout à droite */
}

.btn-quit:hover {
  background: transparent;
  color: var(--accent);
  border-color: var(--accent);
}

.btn-quit svg { width: 20px; height: 20px; }

.game-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 20px 20px 20px 20px;
  overflow-y: hidden;
  gap: 20px;
  width: 100%;
  max-width: 900px;
  margin: 0 auto;
  height: 100vh;
  padding-bottom: 250px;
}

#gameFooterFixed {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 10000;
    padding: 12px 20px;
    background: var(--panel); 
    border-top: 1px solid var(--border);
    box-shadow: var(--shadow);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
}

#gameFooterFixed > * {
    max-width: 900px; /* Limiter la largeur des éléments du pied de page */
    width: 100%;
}

.stats-grid, .game-nav, .game-actions {
    margin: 0 !important;
}

/* -- Bloc de Progression -- */
.progress-section {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 20px;
  width: 100%;
}

.progress-bar {
  height: 12px;
  background: var(--panel);
  border-radius: 6px;
  overflow: hidden;
  margin-bottom: 12px;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), #5684ff);
  transition: width 0.3s ease;
  border-radius: 6px;
  width: 0%;
}

.progress-info {
  display: flex;
  justify-content: space-between;
  font-size: 14px;
  color: var(--muted);
}

#gameTimer {
    font-size: 16px;
    font-weight: 600;
    color: var(--accent);
    padding: 0 8px;
}

/* -- Bloc de Phrase -- */
.translation-hint {
  font-size: 16px;
  color: var(--muted);
  text-align: center;
  padding: 20px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 14px;
  width: 100%;
  line-height: 1.6;
}

.game-main-content {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 24px;
  min-height: 150px;
  flex: 1;
  overflow-y: auto;
}

.game-section {
  width: 100%;
}

.game-section-title {
  font-size: 16px;
  font-weight: 700;
  color: var(--muted);
  margin-bottom: 12px;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* -- Mode: Réorganiser -- */
#reorder-drag-mode {
    display: flex;
    flex-direction: column;
    gap: 16px;
}
.words-zone {
  min-height: 100px;
  padding: 20px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 14px;
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  justify-content: center;
}

.drop-zone {
  border-style: dashed;
  border-color: var(--accent);
}

.word-token {
  padding: 12px 20px;
  background: var(--card);
  border: 2px solid var(--border);
  border-radius: 10px;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 24px;
  font-weight: 500;
  cursor: grab;
  transition: all 0.2s;
  user-select: none;
  touch-action: none;
}

#availableWords .word-token {
  font-size: 18px; /* Réduction de 25% (24px * 0.75) */
}

#userSentence .word-token {
  font-size: 20px; /* Réduction de 15% (24px * 0.85 ≈ 20px) */
}

.word-token:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  border-color: var(--accent);
}

.word-token.dragging {
  opacity: 0.5;
  cursor: grabbing;
  background: var(--accent);
  color: white;
}

.word-token.hint-revealed {
  animation: highlight 0.6s ease-out;
}

@keyframes highlight {
  0%, 100% { background: var(--card); }
  50% { background: var(--accent); color: white; }
}

.drop-placeholder {
  width: 80px;
  height: 48px;
  border: 2px dashed var(--accent);
  border-radius: 10px;
  background: rgba(122, 162, 255, 0.1);
  transition: all 0.2s;
  flex-shrink: 0;
}

.drop-placeholder.drag-over {
  background: rgba(122, 162, 255, 0.3);
  transform: scale(1.05);
}

/* -- Mode: Saisie Libre -- */
.free-textarea {
  width: 100%;
  min-height: 120px;
  padding: 16px;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 20px;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
  border-radius: 14px;
  outline: none;
  resize: vertical;
}

.free-textarea:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(122, 162, 255, 0.1);
}

/* -- Mode: Frappe Live & Time Attack -- */
#live-typing-mode, #time-attack-mode {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.typing-target-text {
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 28px;
  font-weight: 500;
  line-height: 1.8;
  padding: 20px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  min-height: 100px;
  text-align: center;
}
.typing-target-text span {
  color: var(--muted); /* Ajouté : Couleur par défaut grise */
  transition: color 0.2s, background 0.2s;
}
.typing-target-text .char-correct {
  color: var(--correct);
}
.typing-target-text .char-incorrect {
  color: var(--incorrect);
  background: rgba(239, 68, 68, 0.2);
  border-radius: 4px;
  text-decoration: underline wavy var(--incorrect);
}
.typing-target-text .char-current {
  background: var(--accent);
  color: white;
  border-radius: 4px;
}
.typing-input {
  width: 100%;
  padding: 16px;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 20px;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
  border-radius: 14px;
  outline: none;
  margin-top: 20px;
  transition: border-color 0.2s;
  min-height: 80px;
  resize: vertical;
}
.typing-input:focus {
  border-color: var(--accent);
}
.typing-instruction {
    text-align: center;
    color: var(--muted);
    font-style: italic;
    margin-top: -10px;
    margin-bottom: 10px;
}


/* -- Mode: Phrases à Trous -- */
#fill-blanks-char-mode, #fill-blanks-pinyin-mode {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.blanks-display-text {
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 28px;
  font-weight: 500;
  line-height: 1.8;
  padding: 20px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  min-height: 100px;
  text-align: center;
}
.blank-space {
  display: inline-block;
  min-width: 40px;
  padding: 0 8px;
  margin: 0 4px;
  border-bottom: 2px solid var(--muted);
  color: var(--muted);
  font-weight: 700;
  cursor: pointer;
}
.blank-space.current-blank {
  border-bottom-color: var(--accent);
  color: var(--accent);
  background: rgba(122, 162, 255, 0.1);
  border-radius: 4px;
}
.blank-space.filled-blank-correct {
  border-bottom: 2px solid transparent;
  color: var(--correct);
  font-weight: 500;
  cursor: default;
}
.blank-space.filled-blank-incorrect {
  border-bottom: 2px solid transparent;
  color: var(--incorrect);
  font-weight: 500;
}

.blank-space.blank-with-hint {
  color: var(--muted);
  opacity: 0.8;
  vertical-align: baseline;
  transition: color 0.2s, opacity 0.2s;
}

.blank-space.blank-with-hint.current-blank {
  color: var(--accent);
  opacity: 1;
}

.blank-space.filled-blank-correct.blank-with-hint {
  color: var(--correct);
  opacity: 1;
  border-bottom-color: transparent;
}

.blanks-input {
  width: 100%;
  padding: 16px;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 20px;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
  border-radius: 14px;
  outline: none;
  margin-top: 20px;
}
.blanks-input:focus {
  border-color: var(--accent);
}

/* -- Popup Pinyin (Mode 6) -- */
#pinyinTonePopup {
  position: absolute;
  background: var(--card);
  border: 1px solid var(--accent);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  padding: 8px;
  display: none;
  z-index: 10002;
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 18px;
}

.tone-option {
  display: inline-block;
  padding: 4px 8px;
  cursor: pointer;
  border-radius: 4px;
}
.tone-option:hover {
  background: var(--panel);
}
.tone-option kbd {
  font-size: 12px;
  color: var(--muted);
  font-weight: 600;
  margin-left: 4px;
}

#blanks-input-pinyin,
#pinyinTonePopup,
#dictModalBody { /* Assurez-vous que le modal générique est aussi inclus */
    font-family: 'Noto Sans', 'Noto Sans SC', sans-serif;
}

/* -- Actions et Résultats -- */
.game-result {
  display: none;
  padding: 16px 24px;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  text-align: center;
  animation: slideDown 0.3s ease-out;
  width: 100%;
  margin-top: 10px;
  margin-bottom: 13px
}

@keyframes slideDown {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

.game-result.success {
  background: rgba(34, 197, 94, 0.2);
  color: #16a34a;
  border: 2px solid rgba(34, 197, 94, 0.4);
}

.game-result.error {
  background: rgba(239, 68, 68, 0.2);
  color: #dc2626;
  border: 2px solid rgba(239, 68, 68, 0.4);
}

.game-actions {
  display: flex;
  gap: 16px;
  justify-content: center;
  width: 100%;
  flex-wrap: wrap;
}

.btn-game {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 14px 28px;
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-game svg { width: 20px; height: 20px; }

.btn-hint {
  display: none;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
}

.btn-hint:hover {
  background: var(--border);
  transform: translateY(-1px);
}

.btn-validate {
  background: var(--accent);
  color: white;
}

.btn-validate:hover {
  filter: brightness(1.1);
  transform: translateY(-1px);
}

.btn-restart {
  display: none;
  background: var(--panel);
  color: var(--fg);
  border: 2px solid var(--border);
}
.btn-restart:hover {
  background: var(--border);
  transform: translateY(-1px);
}

/* -- Stats -- */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
  gap: 8px; /* Réduit */
  width: 100%;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px; /* Réduit */
}

.stat-box {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 6px; /* Réduit de moitié */
  text-align: center;
}

.stat-label { font-size: 10px; color: var(--muted); margin-bottom: 2px; text-transform: uppercase;} /* Police réduite */
.stat-value { font-size: 16px; font-weight: 700; color: var(--accent); } /* Police réduite */

/* -- Navigation -- */
.game-nav {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 14px;
  box-shadow: var(--shadow);
  width: 100%;
}

#prevSentenceBtn {
  margin-left: auto;
}

.game-container > .progress-section,
.game-container > .translation-hint,
.game-container > .game-result,
.game-container > .game-actions,
.game-container > .stats-grid,
.game-container > .game-nav {
  flex-shrink: 0;
}

.btn-nav {
  display: flex;
  align-items: center;
  gap: 6px; /* Réduit */
  padding: 10px 14px; /* Réduit */
  background: var(--panel);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 10px;
  font-size: 14px; /* Réduit */
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-nav:hover {
  background: var(--border);
  transform: translateY(-1px);
}

.btn-nav:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-nav svg { width: 16px; height: 16px; } /* Réduit */

.sentence-counter {
  padding: 10px 12px; /* Réduit */
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 10px;
  font-size: 14px; /* Réduit */
  font-weight: 600;
  color: var(--muted);
  white-space: nowrap; /* Ajouté pour empêcher le retour à la ligne */
}

/* Style pour le sélecteur Clavier/Choix Multiple */
.pinyin-input-type-selector {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  margin-top: 8px; /* Un peu d'espace après le label */
}

.pinyin-input-type-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 10px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 10px;
  color: var(--muted);
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
  font-size: 13px;
}

.pinyin-input-type-btn svg {
  width: 18px;
  height: 18px;
  flex-shrink: 0;
}

.pinyin-input-type-btn:hover {
  border-color: var(--accent);
  color: var(--fg);
}

.pinyin-input-type-btn.active {
  background: var(--accent);
  color: white;
  border-color: var(--accent);
}

/* Conteneur des options Pinyin MCQ */
.pinyin-mcq-container {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 25px; /* Espace au-dessus des options */
}

/* Boutons d'option Pinyin MCQ */
.pinyin-option-btn {
  padding: 10px 18px;
  background: var(--panel);
  border: 2px solid var(--border);
  border-radius: 10px;
  color: var(--fg);
  font-size: 18px; /* Taille de police pour le pinyin */
  font-weight: 500;
  font-family: 'Noto Sans', 'Noto Sans SC', sans-serif; /* Assurer la bonne police */
  cursor: pointer;
  transition: all 0.2s;
  min-width: 80px; /* Largeur minimale */
  text-align: center;
}

.pinyin-option-btn:hover {
  border-color: var(--accent);
  background: var(--border);
}

/* Style pour indiquer le caractère actif dans le trou (indice) */
.blank-space.blank-with-hint .active-char-hint {
  display: inline-block; /* Nécessaire pour appliquer le fond */
  background-color: rgba(122, 162, 255, 0.2); /* Fond bleu léger */
  border-radius: 3px;
}

/* Animation pour feedback incorrect */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

.pinyin-option-btn.mcq-incorrect {
  animation: shake 0.3s ease-in-out;
  border-color: var(--incorrect) !important;
  background: rgba(239, 68, 68, 0.2); /* Fond rouge léger */
}

/* ================================================= */
/* =============== FIN PAGE DE JEU ================= */
/* ================================================= */

/* ================================================= */
/* ============== PAGE DE LECTURE ================ */
/* ================================================= */
.read-page {
  display: none;
  position: fixed;
  inset: 0;
  background: var(--bg);
  overflow: hidden;
  z-index: 9999;
}

.read-page.active { display: flex; flex-direction: column; }

/* Barre de Contrôle - Lecture */
.read-controls {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: var(--panel);
  border-bottom: 1px solid var(--border);
  padding: 12px 16px; /* Ajuster padding légèrement */
  display: flex;
  align-items: center;
  gap: 10px; /* Réduire l'espacement un peu */
  z-index: 10000;
  box-shadow: var(--shadow);
  flex-wrap: nowrap; /* EMPÊCHER le retour à la ligne par défaut (desktop) */
  min-height: 70px; /* Garder une hauteur minimale */
  overflow-x: auto; /* Permettre le défilement horizontal si ça dépasse sur très petit écran */
}

.read-close {
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #ef4444;
  color: white;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  flex-shrink: 0;
}

.read-close:hover { background: #dc2626; }

.read-play-pause {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  flex-shrink: 0;
}

.read-play-pause svg { width: 24px; height: 24px; }

.read-play-pause:hover { filter: brightness(1.1); }

.read-mode-toggle, .read-zen-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--fg);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}

.read-mode-toggle svg, .read-zen-toggle svg {
  width: 18px;
  height: 18px;
}

.read-mode-toggle:hover { background: var(--border); }


/* Style for the active mode toggle button */
.read-mode-toggle.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

/* Style for disabled buttons (Play/Pause) */
#readPlayPause:disabled,
#szBtnPlay:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  filter: grayscale(50%); /* Optional: make it look more disabled */
}

/* Style pour le bouton Focus désactivé */
#readFocusToggle:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  filter: grayscale(50%); /* Optionnel: le rend plus gris */
  /* Empêcher l'effet hover quand désactivé */
  pointer-events: none;
}

.read-zen-toggle {
  background: var(--accent);
  border: 1px solid var(--accent);
  color: white;
}

.read-zen-toggle:hover { filter: brightness(1.1); }

.read-font-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-shrink: 0;
}

.read-font-btn {
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--fg);
  font-size: 14px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
}

.read-font-btn:hover { background: var(--border); }

.read-font-size {
  font-size: 12px;
  color: var(--muted);
  font-weight: 600;
  min-width: 45px;
  text-align: center;
}

.difficulty-gauge {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 8px 12px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 10px;
  flex-shrink: 0;
}

.difficulty-label {
  font-size: 10px;
  color: var(--muted);
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.difficulty-bar {
  height: 6px;
  background: var(--border);
  border-radius: 3px;
  overflow: hidden;
  position: relative;
  width: 80px;
}

.difficulty-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.5s ease, background 0.5s ease;
}

.difficulty-text {
  font-size: 12px;
  font-weight: 700;
  color: var(--fg);
}

.read-filter-legend {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  align-items: center;
  min-width: 0
}

.read-filter-legend span {
  font-size: 11px;
  color: var(--muted);
  font-weight: 600;
  white-space: nowrap;
  margin-right: 6px; /* Espace après "FILTRES:" */
}

.read-legend-chip {
  padding: 6px 12px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid;
  background: transparent;
  white-space: nowrap;
  flex-shrink: 0; /* Empêche les chips de rétrécir */
}

.read-legend-chip:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}

.read-legend-chip.level-1 { border-color: var(--hsk1); color: var(--hsk1); }
.read-legend-chip.level-2 { border-color: var(--hsk2); color: var(--hsk2); }
.read-legend-chip.level-3 { border-color: var(--hsk3); color: var(--hsk3); }
.read-legend-chip.level-4 { border-color: var(--hsk4); color: var(--hsk4); }
.read-legend-chip.level-5 { border-color: var(--hsk5); color: var(--hsk5); }
.read-legend-chip.level-6 { border-color: var(--hsk6); color: var(--hsk6); }
.read-legend-chip.level-79 { border-color: var(--hsk79); color: var(--hsk79); }

.read-legend-chip.freq-1 { border-color: var(--freq1); color: var(--freq1); }
.read-legend-chip.freq-2 { border-color: var(--freq2); color: var(--freq2); }
.read-legend-chip.freq-3 { border-color: var(--freq3); color: var(--freq3); }
.read-legend-chip.freq-4 { border-color: var(--freq4); color: var(--freq4); }
.read-legend-chip.freq-5 { border-color: var(--freq5); color: var(--freq5); }
.read-legend-chip.freq-6 { border-color: var(--freq6); color: var(--freq6); }
.read-legend-chip.freq-7 { border-color: var(--freq7); color: var(--freq7); }
.read-legend-chip.freq-8 { border-color: var(--freq8); color: var(--freq8); }
.read-legend-chip.freq-9 { border-color: var(--freq9); color: var(--freq9); }

.read-legend-chip.active.level-1 { background: var(--hsk1); border-color: var(--hsk1); color: #fff; }
.read-legend-chip.active.level-2 { background: var(--hsk2); border-color: var(--hsk2); color: #fff; }
.read-legend-chip.active.level-3 { background: var(--hsk3); border-color: var(--hsk3); color: #333; }
.read-legend-chip.active.level-4 { background: var(--hsk4); border-color: var(--hsk4); color: #fff; }
.read-legend-chip.active.level-5 { background: var(--hsk5); border-color: var(--hsk5); color: #fff; }
.read-legend-chip.active.level-6 { background: var(--hsk6); border-color: var(--hsk6); color: #fff; }
.read-legend-chip.active.level-79 { background: var(--hsk79); border-color: var(--hsk79); color: #fff; }

.read-legend-chip.active.freq-1 { background: var(--freq1); border-color: var(--freq1); color: #fff; }
.read-legend-chip.active.freq-2 { background: var(--freq2); border-color: var(--freq2); color: #fff; }
.read-legend-chip.active.freq-3 { background: var(--freq3); border-color: var(--freq3); color: #fff; }
.read-legend-chip.active.freq-4 { background: var(--freq4); border-color: var(--freq4); color: #fff; }
.read-legend-chip.active.freq-5 { background: var(--freq5); border-color: var(--freq5); color: #333; }
.read-legend-chip.active.freq-6 { background: var(--freq6); border-color: var(--freq6); color: #fff; }
.read-legend-chip.active.freq-7 { background: var(--freq7); border-color: var(--freq7); color: #fff; }
.read-legend-chip.active.freq-8 { background: var(--freq8); border-color: var(--freq8); color: #fff; }
.read-legend-chip.active.freq-9 { background: var(--freq9); border-color: var(--freq9); color: #fff; }

.read-legend-focus {
  /* Inherited/Base Styles (from .read-legend-chip potentially) */
  display: flex; /* Overrides default inline-block if chip uses it */
  align-items: center; /* Vertical alignment */
  padding: 5px 10px; /* Same padding as chips */
  border-radius: 12px; /* Same border radius */
  font-size: 10px; /* Same font size */
  font-weight: 600; /* Same font weight */
  cursor: pointer; /* Pointer cursor */
  transition: all 0.2s; /* Same transition */
  white-space: nowrap; /* Prevent wrapping text */
  background: transparent; /* Ensure no background inherited */
  gap: 6px; /* Space between icon/text if any */
  border: 2px solid #ffffff !important; /* Specific white border */
  color: #ffffff !important; /* Specific white text color */
  margin-left: 10px; /* Space after filter chips */
  flex-shrink: 0; /* Prevent shrinking */
}

.read-legend-focus:hover {
  transform: scale(1.05); /* Same hover effect as chips */
  box-shadow: 0 2px 8px rgba(0,0,0,0.15); /* Same hover effect */
  border-color: #ffffff !important;
  color: #ffffff !important;
  background: transparent; /* Ensure no background on hover */
}

.read-legend-focus.active {
  background: #ffffff !important;
  border-color: #ffffff !important;
  color: var(--bg) !important;
}

/* Barre de Progression - Rétablir flex: 1 */
.read-progress {
  flex: 1 1 auto; /* Prend l'espace disponible, peut rétrécir mais préfère s'étendre */
  min-width: 150px; /* Largeur minimale raisonnable */
  height: 8px;
  background: var(--border);
  border-radius: 999px;
  overflow: hidden;
  cursor: pointer;
  margin: 0 10px; /* Marges H simples */
}

.read-progress-bar {
  height: 100%;
  background: var(--accent);
  width: 0%;
  transition: width 0.1s linear;
}

.read-content {
  position: absolute;
  top: 80px; /* Espace pour la barre de contrôle */
  left: 0;
  right: 0;
  bottom: 0;
  overflow-y: auto;
  padding: 40px;
  display: flex;
  flex-direction: row; /* Défaut pour desktop */
  align-items: flex-start;
  justify-content: center;
  gap: 40px;
}

/* Ajustement de la hauteur du contenu en fonction de la barre de contrôle */
.read-page.active .read-content {
    /* Calcul dynamiquement via JS si nécessaire, ou valeur fixe suffisante */
    top: 80px; /* Ou une valeur plus grande si la barre prend 2 lignes */
}


.read-text-container {
  max-width: 1400px;
  width: 100%;
  display: flex;
  flex-direction: row; /* Défaut pour desktop */
  gap: 40px;
  align-items: flex-start;
}

.read-text {
  font-family: 'Noto Sans SC', sans-serif;
  line-height: 2.2;
  flex: 1;
  min-width: 0;
  padding: 30px;
  background: var(--card);
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
}

.read-translation {
  font-family: 'Inter', sans-serif;
  line-height: 1.8;
  flex: 1;
  min-width: 0;
  padding: 30px;
  background: var(--panel);
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
  color: var(--muted);
  font-style: italic;
  font-size: 0.9em; /* Légèrement plus petit */
}


/* ===== EFFET FLIP 3D POUR MOBILE ===== */
.flip-container {
  perspective: 1000px;
  width: 100%;
  min-height: 400px; /* Hauteur minimale pour la visibilité */
  position: relative;
}

/* Recto (chinois) cliquable par défaut */
.flip-container .flip-front {
  z-index: 2;
  pointer-events: auto;
  backface-visibility: hidden;
}

/* Verso (traduction) présent mais non cliquable tant qu'on n'a pas retourné */
.flip-container .flip-back {
  position: absolute;
  inset: 0;
  width: 100%;
  pointer-events: none;          /* ← clé pour ne plus bloquer les clics */
  z-index: 1;
  backface-visibility: hidden;
  transform: rotateY(180deg);
}

/* Quand la carte est retournée (ajoute .flipped sur #flipContainer), on inverse */
.flip-container.flipped .flip-front {
position: absolute;
  pointer-events: none;
  z-index: 1;
}
.flip-container.flipped .flip-back {
  pointer-events: auto;
  z-index: 2;
}

.flip-container.flipped .flip-inner {
  transform: rotateY(180deg);
}

.flip-inner {
  position: relative; /* Changé de absolute à relative */
  width: 100%;
  height: auto;
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.flip-front,
.flip-back {
  position: absolute; /* Garder absolute pour la superposition */
  top: 0; /* Assurer l'alignement */
  left: 0; /* Assurer l'alignement */
  width: 100%;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  padding: 30px;
  border-radius: 16px;
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
  height: auto;
}

.flip-front {
  background: var(--card);
  font-family: 'Noto Sans SC', sans-serif;
  line-height: 2.2;
  z-index: 2; /* S'assurer que le front est devant initialement */
}

.flip-back {
  background: var(--panel);
  color: var(--muted);
  font-style: italic;
  font-family: 'Inter', sans-serif;
  line-height: 1.8;
  transform: rotateY(180deg);
}

.read-flip-btn {
  display: none; /* Hidden by default, shown via JS/media query */
  position: fixed;
  bottom: 80px;
  right: 24px;
  width: 56px;
  height: 56px;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 50%;
  box-shadow: 0 4px 20px rgba(122, 162, 255, 0.4);
  cursor: pointer;
  z-index: 100;
  transition: all 0.3s;
  /* --- CENTERING STYLES --- */
  display: flex; /* Ensure it's flex */
  align-items: center; /* Vertical center */
  justify-content: center; /* Horizontal center */
  padding: 0; /* Remove padding if it interferes */
}
.read-flip-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 25px rgba(122, 162, 255, 0.5);
}
.read-flip-btn svg {
  width: 28px; /* Adjust size as needed */
  height: 28px; /* Adjust size as needed */
  display: block; /* Helps prevent extra space below SVG */
}
/* Adjust position if overlapping with Super Zen controls */
.read-page.super-zen .read-flip-btn {
    bottom: 100px;
}

.read-progress {
    display: none !important; /* Garder caché sur mobile */
  }
/* Légende des Filtres - Pas d'extension, groupée */
.read-filter-legend {
  display: flex;
  gap: 6px;
  align-items: center;
  flex-shrink: 0; /* Ne pas rétrécir les filtres eux-mêmes */
  /* Pas de flex: 1, pas de flex-basis, pas d'order par défaut */
}
   .read-legend-focus {
       margin-left: 8px; /* Simple marge sur mobile */
       order: 11; /* Mettre le bouton focus après les filtres */
       margin-top: 8px; /* Ajouter un espace si ça passe à la ligne */
   }
}
.read-flip-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 25px rgba(122, 162, 255, 0.5);
}

.read-flip-btn svg {
  width: 28px;
  height: 28px;
}

.read-char {
  display: inline;
  transition: color 0.2s, background-color 0.2s; /* Transition plus simple */
  cursor: pointer;
  position: relative; /* Garder pour le hover potentiel */
}

/* Enlever l'effet de scale au survol, peut causer des décalages */
/* .read-char:hover {
  transform: scale(1.05);
  z-index: 10;
} */

.read-char.hsk1 { color: var(--hsk1); }
.read-char.hsk2 { color: var(--hsk2); }
.read-char.hsk3 { color: var(--hsk3); }
.read-char.hsk4 { color: var(--hsk4); }
.read-char.hsk5 { color: var(--hsk5); }
.read-char.hsk6 { color: var(--hsk6); }
.read-char.hsk79 { color: var(--hsk79); }

.read-char.freq1 { color: var(--freq1); }
.read-char.freq2 { color: var(--freq2); }
.read-char.freq3 { color: var(--freq3); }
.read-char.freq4 { color: var(--freq4); }
.read-char.freq5 { color: var(--freq5); }
.read-char.freq6 { color: var(--freq6); }
.read-char.freq7 { color: var(--freq7); }
.read-char.freq8 { color: var(--freq8); }
.read-char.freq9 { color: var(--freq9); }

/* ================================================= */
/* ============= MODAL GÉNÉRIQUE (JEU) ============= */
/* ================================================= */
.modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2000;
  align-items: center;
  justify-content: center;
  padding: 20px;
  animation: modalFadeIn 0.3s;
}

.modal.active { display: flex; }

@keyframes modalFadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.modal-content {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 32px;
  max-width: 600px;
  width: 95%;
  max-height: 85vh;
  overflow-y: auto;
  animation: modalSlideIn 0.3s;
  position: relative;
}

@keyframes modalSlideIn {
  from { transform: translateY(-50px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--border);
}

.modal-title { font-size: 20px; font-weight: 800; color: var(--fg); }

.modal-close {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
  color: var(--muted);
}

.modal-close:hover { background: #ef4444; color: white; border-color: #ef4444; }

/* Styles spécifiques pour le modal d'aperçu des phrases */
#sentencesPreviewModal .modal-body {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
#sentencesPreviewModal .sentence-preview-item {
  display: flex;
  align-items: flex-start;
  gap: 16px;
  padding: 16px;
  background: var(--panel);
  border-radius: 10px;
  border: 1px solid var(--border);
}
#sentencesPreviewModal .sentence-preview-number {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--accent);
  color: white;
  border-radius: 50%;
  font-weight: 700;
  font-size: 14px;
  flex-shrink: 0;
  margin-top: 4px;
}
#sentencesPreviewModal .sentence-preview-texts {
  flex: 1;
}
#sentencesPreviewModal .sentence-preview-zh {
  font-family: 'Noto Sans SC', sans-serif;
  font-size: 18px;
  margin-bottom: 8px;
  color: var(--fg);
  line-height: 1.7;
}
#sentencesPreviewModal .sentence-preview-tr {
  font-size: 14px;
  color: var(--muted);
  line-height: 1.6;
}

/* ================================================= */
/* =========== MODAL DICT (LECTURE) ================ */
/* ================================================= */
.dict-modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(4px);
  z-index: 99999;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.dict-modal.active {
  display: flex;
}

.dict-modal-content {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 48px 32px 32px 32px;
  max-width: 500px;
  width: 100%;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  animation: modalSlideIn 0.3s ease-out; /* Réutilise l'animation */
  position: relative;
}

.dict-modal-close {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  color: var(--muted);
  transition: all 0.2s;
  z-index: 1;
}

.dict-modal-close:hover {
  background: #ef4444;
  color: white;
  border-color: #ef4444;
}

.dict-char {
  font-size: 72px;
  font-family: 'Noto Sans SC', sans-serif;
  text-align: center;
  margin-bottom: 16px;
  font-weight: 500;
  color: var(--fg);
}

.dict-pinyin {
  font-size: 28px;
  color: var(--accent);
  text-align: center;
  margin-bottom: 24px;
  font-weight: 600;
}

/* --- INSERT TAG STYLES HERE --- */
.dict-tags-container {
    text-align: center;
    margin-top: 8px; /* Espace après le pinyin */
    margin-bottom: 20px; /* Espace avant les définitions */
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
}
.dict-tag {
    display: inline-block;
    padding: 5px 12px;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 600;
    line-height: 1.2;
    color: #fff;
}
/* Couleurs HSK */
.dict-tag.level-1 { background: var(--hsk1); color: #fff; }
.dict-tag.level-2 { background: var(--hsk2); color: #fff; }
.dict-tag.level-3 { background: var(--hsk3); color: #333; }
.dict-tag.level-4 { background: var(--hsk4); color: #fff; }
.dict-tag.level-5 { background: var(--hsk5); color: #fff; }
.dict-tag.level-6 { background: var(--hsk6); color: #fff; }
.dict-tag.level-79 { background: var(--hsk79); color: #fff; }
/* Couleurs Fréquence */
.dict-tag.freq-1 { background: var(--freq1); color: #fff; }
.dict-tag.freq-2 { background: var(--freq2); color: #fff; }
.dict-tag.freq-3 { background: var(--freq3); color: #fff; }
.dict-tag.freq-4 { background: var(--freq4); color: #fff; }
.dict-tag.freq-5 { background: var(--freq5); color: #333; }
.dict-tag.freq-6 { background: var(--freq6); color: #fff; }
.dict-tag.freq-7 { background: var(--freq7); color: #fff; }
.dict-tag.freq-8 { background: var(--freq8); color: #fff; }
.dict-tag.freq-9 { background: var(--freq9); color: #fff; }

.dict-definitions {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.dict-def {
  padding: 14px 18px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 10px;
  font-size: 15px;
  line-height: 1.7;
  color: var(--fg);
}

.dict-def:before {
  content: "•";
  color: var(--accent);
  font-weight: bold;
  display: inline-block;
  width: 1em;
  margin-left: -1em;
}

/* ================================================= */
/* =============== MODE SUPER ZEN ================== */
/* ================================================= */
.read-page.super-zen .read-controls {
  display: none; /* Cache la barre de contrôle normale */
}

.read-page.super-zen .read-content {
  top: 0; /* Prend tout l'espace */
  bottom: 80px; /* Espace pour les contrôles super-zen en bas */
  padding: 40px;
  display: flex;
  flex-direction: column; /* Texte au-dessus de la traduction */
  justify-content: center;
  align-items: center;
  text-align: center;
}

/* Style pour le conteneur en mode super-zen */
.read-page.super-zen .read-text-container {
   flex-direction: column; /* Empile texte et trad */
   align-items: center; /* Centre horizontalement */
   justify-content: center; /* Centre verticalement */
   gap: 20px; /* Espace entre texte et trad */
   width: 100%;
   max-width: 90%; /* Limite la largeur max */
}

/* Style pour le texte chinois en mode super-zen */
.read-page.super-zen .read-text {
  font-size: 48px;
  line-height: 1.5;
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
  flex: none;
  width: auto;
  text-align: center;
}

/* Style pour la traduction en mode super-zen */
.read-page.super-zen .read-translation {
  font-size: 24px;
  line-height: 1.6;
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
  color: var(--muted);
  font-style: italic;
  flex: none;
  width: auto;
  text-align: center;
}


.super-zen-controls {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--panel);
  border-top: 1px solid var(--border);
  padding: 16px;
  display: none; /* Caché par défaut */
  align-items: center;
  justify-content: center;
  gap: 12px;
  z-index: 10001; /* Au-dessus du contenu */
  flex-wrap: wrap; /* Permet le passage à la ligne */
  height: 80px; /* Hauteur fixe pour la barre */
}

.read-page.super-zen .super-zen-controls {
  display: flex; /* Affiché seulement en mode super-zen */
}

.super-zen-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--fg);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.super-zen-btn svg {
  width: 18px;
  height: 18px;
}

.super-zen-btn:hover {
  background: var(--border);
}

.super-zen-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.super-zen-play {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  flex-shrink: 0;
}

.super-zen-play svg {
  width: 24px;
  height: 24px;
}

.super-zen-play:hover {
  filter: brightness(1.1);
}

.super-zen-progress {
  font-size: 14px;
  font-weight: 600;
  color: var(--muted);
  padding: 8px 16px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 8px;
}

/* Bouton Flip en mode Super Zen (si besoin) */
.read-page.super-zen .read-flip-btn {
    bottom: 100px; /* Remonter au-dessus des contrôles super-zen */
}


/* ================================================= */
/* ============= CONTROLES SWIPE MOBILE ============ */
/* ================================================= */

/* Conteneur principal du swiper (mobile) */
.read-controls-inner {
  display: none; /* Caché par défaut, activé sur mobile */
}

/* Indicateurs de points (mobile) */
.read-controls-dots {
  display: none; /* Caché par défaut, activé sur mobile */
}

/* Styles pour la jauge de difficulté sur mobile (dans le swiper) */
#rc-difficulty-gauge.difficulty-gauge {
    /* Sur mobile, on cache la barre/label et on pousse le texte à droite */
    background: none;
    border: none;
    padding: 0;
    margin-left: auto; /* Pousse vers la droite sur le panel 1 */
}
#rc-difficulty-gauge .difficulty-label,
#rc-difficulty-gauge .difficulty-bar {
    display: none; /* Cacher la barre et le label */
}
#rc-difficulty-gauge #readDifficultyText {
    /* Style du texte (chip) */
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 13px; /* font-weight: 700; /* height: auto;
    max-height: 28px; /* Légèrement augmenté pour la nouvelle taille */
    box-sizing: border-box;
    display: flex; /* Ajouter flex pour centrer verticalement si besoin */
    align-items: center; /* Centrer verticalement */
}

/* ================================================= */
/* ========= BOUTONS CACHER/AFFICHER MENU ========== */
/* ================================================= */

/* Ceci est la bonne définition (corrigée) */
.controls-toggle-btn {
  position: fixed;
  top: 15px;
  right: 15px;
  width: 40px;
  height: 40px;
  background: transparent; /* CORRIGÉ: Fond supprimé */
  border: none; /* CORRIGÉ: Bordure supprimée */
  color: var(--fg);
  border-radius: 10px;
  cursor: pointer;
  z-index: 10001; /* Au-dessus de tout le reste (corrigé) */
  transition: background 0.2s, color 0.2s, opacity 0.3s, transform 0.3s;
  opacity: 0.8;
  display: flex;
  align-items: center;
  justify-content: center;
}

.controls-toggle-btn:hover {
  background: transparent; /* CORRIGÉ: Fond au survol supprimé */
  color: var(--accent); /* CORRIGÉ: Changement de couleur au survol */
  opacity: 1;
}

/* Style quand les contrôles sont cachés */
.read-page.controls-hidden .read-controls {
  transform: translateY(-100%);
  box-shadow: none; /* Cacher l'ombre quand c'est hors écran */
  transition: transform 0.3s ease-out;
}

.read-page.controls-hidden #hideControlsBtn {
   opacity: 0; /* Cacher le bouton "hide" quand caché */
   pointer-events: none;
}

.read-page.controls-hidden #showControlsBtn {
  display: flex !important; /* Afficher le bouton "show" */
  opacity: 0.8;
  transform: translateY(0);
}
.read-page:not(.controls-hidden) #showControlsBtn {
   opacity: 0; /* Cacher le bouton "show" quand visible */
   transform: translateY(-20px);
   pointer-events: none;
}

/* Ajuster la position du contenu quand les contrôles sont cachés */
.read-page.controls-hidden .read-content {
  top: 15px !important; /* Ajuster si besoin pour laisser de l'espace au bouton show */
  transition: top 0.3s ease-out;
}
.read-page .read-content {
    transition: top 0.3s ease-out; /* Ajouter transition pour le retour */
}


/* ================================================= */
/* ========== MEDIA QUERY (RESPONSIVE) ============= */
/* ================================================= */

/* Tablette (Point où le wrap commence mais SANS swiper) */
/* Styles appliqués entre 901px et 1100px */
@media (min-width: 901px) and (max-width: 1100px) {
    .read-controls {
        flex-wrap: wrap; /* Permet le retour à la ligne */
        padding: 10px 12px;
        min-height: auto;
        justify-content: flex-start;
        gap: 8px; /* Espacement réduit */
    }

    /* === PRÉSERVATION LAYOUT TABLETTE === */
    .read-controls-inner,
    .read-panel {
      display: contents; /* Aplatir la structure */
    }
    .read-controls-dots {
      display: none; /* Cacher les dots */
    }
    .controls-toggle-btn {
      display: none !important; /* Cacher boutons hide/show */
    }
    /* === FIN === */

    /* Positionnement Barre Progression */
    .read-progress {
        order: 99;
        flex-basis: 100%;
        min-width: 0;
        margin: 8px 0 4px 0;
        display: block !important;
    }

    /* Positionnement Filtres/Jauge/Focus */
    .read-filter-legend {
        order: 10;
        flex-basis: auto;
        justify-content: flex-start;
        margin-top: 8px;
        margin-right: 10px;
        align-items: center;
    }
     /* Jauge sur tablette */
     #rc-difficulty-gauge.difficulty-gauge {
         order: 11;
         margin-top: 8px;
         margin-left: auto;
         flex-shrink: 0;
         /* Styles visuels de la jauge (identiques au desktop) */
         display: flex !important;
         flex-direction: column;
         gap: 4px;
         padding: 8px 12px;
         background: var(--card);
         border: 1px solid var(--border);
         border-radius: 10px;
     }
     /* Afficher label et barre */
     #rc-difficulty-gauge .difficulty-label,
     #rc-difficulty-gauge .difficulty-bar {
         display: block;
     }
     /* Style du texte DANS la jauge */
     #rc-difficulty-gauge #readDifficultyText {
         font-size: 12px; font-weight: 700; color: var(--fg) !important;
         padding: 0; border-radius: 0; height: auto; max-height: none;
         background-color: transparent; border: none; line-height: initial;
         margin: 0; order: initial;
     }

     .read-legend-focus {
         order: 12; margin-left: 8px; margin-top: 8px; align-items: center;
     }
     .read-filter-legend span { display: inline; } /* Afficher "FILTRES:" */
}

/* Mobile (Activation du Swiper) - Styles pour max-width: 900px */
@media (max-width: 900px) {

  /* === BASE POUR MOBILE === */
  .read-controls {
    position: relative; /* Pour positionner #hideControlsBtn */
    padding: 0 0 8px 0;
    gap: 0;
    justify-content: center;
    flex-wrap: wrap;
    min-height: auto;
    transition: transform 0.3s ease-out; /* Pour animation hide/show */
  }

  .game-container .stats-grid {
    display: none !important; /* Force le masquage */
  }

  #time-attack-mode .game-section {
    display: flex;         /* Activer Flexbox */
    flex-direction: column; /* Empiler verticalement */
  }

  #time-attack-mode #time-attack-translation {
    order: 1; /* Mettre la traduction en premier visuellement */
  }

  #time-attack-mode #time-attack-target-text {
    order: 2; /* Mettre le texte chinois en deuxième */
  }

  #time-attack-mode #time-attack-input {
    order: 3; /* Mettre le champ de saisie en dernier */
    margin-top: 16px; /* Rétablir un peu d'espace au-dessus si besoin */
  }

  #hideControlsBtn {
    position: absolute;
    right: 12px;
    bottom: 8px;

    width: 36px;
    height: 36px;

    background: transparent;
    border: none;
    color: var(--fg);
    opacity: 0.8;

    display: flex;
    align-items: center;
    justify-content: center;

    /* on annule ce qu'on avait ajouté avant */
    margin-left: 0;
    order: initial;
    top: auto;
    z-index: 10; /* passe au-dessus des dots si besoin */
  }
}

  /* Contenu quand caché */
   .read-page.active .read-content { top: 100px; /* Espace initial */ }
   .read-page.controls-hidden .read-content { top: 15px !important; }

  /* === ACTIVATION SWIPER === */
  .read-controls-inner {
    display: flex !important; /* Override 'contents' */
    flex-basis: 100%; order: 1;
    overflow-x: auto; scroll-snap-type: x mandatory;
    -webkit-overflow-scrolling: touch; scrollbar-width: none;
  }
  .read-controls-inner::-webkit-scrollbar { display: none; }

  /* Les 3 panneaux */
  .read-panel {
    display: flex !important; /* Override 'contents' */
    flex-wrap: wrap; gap: 6px; align-items: center;
    flex: 0 0 100%; scroll-snap-align: start; scroll-snap-stop: always;
    padding: 8px 12px; box-sizing: border-box; min-height: 40px;
  }

  /* Panneau 1: Boutons + Chip Difficulté */
  #rc-panel-1 {
      justify-content: space-evenly; /* Espacement équitable */
      padding-left: 12px;
      padding-right: 12px; /* Rendu symétrique */
      position: relative; /* Contexte pour bouton hide */
  }
  /* Panneau 2: Filtres */
  #rc-panel-2 { justify-content: center; }
  /* Panneau 3: Police */
  #rc-panel-3 { justify-content: center; }

  /* Les Dots */
  .read-controls-dots {
    display: flex !important; /* Override 'none' */
    justify-content: center; gap: 8px; flex-basis: 100%;
    order: 2; margin-top: 6px;
  }
  .read-controls-dots .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border); transition: background 0.2s; }
  .read-controls-dots .dot.active { background: var(--accent); }
  /* === FIN SWIPER === */


  /* Styles des contrôles réduits */
  .read-close { width: 36px; height: 36px; }
  .read-play-pause { width: 40px; height: 40px; }
  .read-mode-toggle, .read-zen-toggle { padding: 8px 12px; font-size: 12px; }
  .read-font-btn {
    width: 36px; /* Augmenté de 32px */
    height: 36px; /* Augmenté de 32px */
    font-size: 14px; /* Augmenté de 12px */
  }
  .read-font-size {
    font-size: 12px; /* Augmenté de 11px */
    min-width: 45px; /* Augmenté de 40px */
    /* Ajout pour centrer verticalement */
    height: 36px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  /* Style de la JAUGE (#rc-difficulty-gauge) sur MOBILE (devient un chip) */
  #rc-difficulty-gauge.difficulty-gauge {
    padding: 4px 10px; border-radius: 12px; border: 2px solid var(--border);
    background-color: transparent; display: inline-flex !important;
    align-items: center; height: 28px; box-sizing: border-box;
    flex-shrink: 0; margin: 0; order: initial; flex-direction: row; gap: 0;
  }
  /* Cacher label et barre */
   #rc-difficulty-gauge .difficulty-label,
   #rc-difficulty-gauge .difficulty-bar { display: none !important; }
  /* Style du texte DANS le chip */
   #rc-difficulty-gauge .difficulty-text,
   #readDifficultyText {
    font-size: 13px; font-weight: 700; color: var(--fg); line-height: 1;
    margin: 0; order: initial; padding: 0; border-radius: 0;
    height: auto; max-height: none; background-color: transparent; border: none;
   }

  /* Filtres DANS le panel 2 */
  .read-filter-legend { flex-basis: 100%; justify-content: center; margin: 0; order: initial; }
  .read-filter-legend > span { display: none !important; } /* Cacher "FILTRES:" */
  .read-legend-chip { padding: 4px 8px; font-size: 10px; }

  /* Bouton Focus */
  .read-legend-focus {
       padding: 4px 10px; border-radius: 12px; font-size: 10px; font-weight: 600;
       line-height: 1.4; border: 2px solid #ffffff !important; color: #ffffff !important;
       background: transparent; height: auto; max-height: 26px; box-sizing: border-box;
       display: inline-flex; align-items: center; justify-content: center;
       margin: 0; order: initial;
  }
   .read-legend-focus span { display: inline !important; }
   .read-legend-focus.active { background: #ffffff !important; color: var(--bg) !important; }
   .read-legend-focus:disabled {
      opacity: 0.4; filter: grayscale(80%); pointer-events: none;
      border-color: var(--muted) !important; color: var(--muted) !important;
      background: transparent !important;
   }

  /* Cacher la barre de progression */
  .read-progress { display: none !important; }

  /* Autres styles mobile (contenu, flip, super zen) (INCHANGÉS) */
  .read-content { padding: 20px; }
  .read-text-container.has-flip { flex-direction: column; gap: 0; }
  .flip-front, .flip-back { padding: 20px}
  .flip-container {
  min-height: 1px; /* Au moins 1px pour le contexte */
}
  .read-text-container:not(.has-flip) { flex-direction: column; }
  .read-text-container:not(.has-flip) .read-text,
  .read-text-container:not(.has-flip) .read-translation { flex: none; width: 100%; padding: 20px; min-height: 300px; }
  .read-page.super-zen .read-content { padding: 60px 20px 100px; bottom: 80px; }
  .read-page.super-zen .read-text { font-size: 36px; }
  .read-page.super-zen .read-translation { font-size: 18px; }
  .super-zen-controls { padding: 12px 8px; gap: 8px; height: 80px;}
  .super-zen-btn { padding: 8px 12px; font-size: 12px; }
  .super-zen-play { width: 44px; height: 44px; }
  
  .read-text-container.has-flip .flip-front,
  .read-text-container.has-flip .flip-back {
      display: block !important;
  }
}

/* Très petits écrans */
@media (max-width: 600px) {
    /* Styles Accueil et Jeu (INCHANGÉS) */
    .container { padding: 16px; padding-bottom: 100px; }
    /* ... (toutes les autres règles inchangées) ... */
    .shrink-text { font-size: 18px !important; line-height: 1.6 !important; }

    /* Styles Mode Lecture Mobile */
     .read-controls { min-height: auto; }
     .read-page.active .read-content { top: 110px; }

    .read-page.super-zen .read-text { font-size: 28px; }
    .read-page.super-zen .read-translation { font-size: 16px; }
	.game-container .stats-grid {
    display: none;
  }
}

/* Écrans minuscules */
@media (max-width: 420px) {
     .read-page.active .read-content { top: 120px; }
     #rc-panel-2 .read-filter-legend { justify-content: flex-start; } /* Aligner filtres à gauche */
}

/* --- Couleur Texte Jauge/Chip sur Thèmes Clairs --- */
[data-theme="light"] #readDifficultyText,
[data-theme="paper"] #readDifficultyText {
    /* La couleur est gérée par JS pour le chip mobile */
    /* La couleur desktop est forcée à var(--fg) ci-dessous */
}
/* Forcer la couleur du texte de la jauge desktop */
@media (min-width: 901px) {
    [data-theme="light"] #rc-difficulty-gauge #readDifficultyText,
    [data-theme="paper"] #rc-difficulty-gauge #readDifficultyText {
        color: var(--fg) !important;
    }
}

/* --- Autres styles --- */
/* Focus désactivé en mode Frappe */
#readFocusToggle:disabled {
  opacity: 0.5; cursor: not-allowed; filter: grayscale(50%); pointer-events: none;
}
/* (La règle @media pour :disabled est redondante mais inoffensive) */


/* ================================================= */
/* ==== RESTAURATION AFFICHAGE DESKTOP (>900px) ==== */
/* ================================================= */
@media (min-width: 901px) {

  /* 1. Rétablir le comportement de base de .read-controls */
  .read-controls {
    /* Styles pour la barre de contrôle PC */
    position: fixed; top: 0; left: 0; right: 0;
    flex-wrap: nowrap; /* EMPÊCHE le retour à la ligne */
    padding: 12px 16px; /* Padding desktop */
    min-height: 70px; /* Hauteur min desktop */
    justify-content: flex-start; /* Aligne au début */
    gap: 10px; /* Espacement desktop */
    transform: translateY(0); /* Assure position initiale */
    /* Styles visuels et positionnement */
    background: var(--panel); border-bottom: 1px solid var(--border);
    box-shadow: var(--shadow); z-index: 10000;
    overflow-x: hidden; /* Cache le débordement horizontal */
    display: flex; /* Assure flex */
    align-items: center; /* Alignement vertical */
  }

  /* --- Rétablir le layout côte à côte du contenu --- */
  .read-content {
    display: flex;
    flex-direction: row; /* Force Côte à côte */
    align-items: flex-start; /* Aligne en haut */
    justify-content: center; /* Centre le conteneur global */
    padding: 40px; /* Padding desktop */
    position: absolute; /* Positionnement sous la barre fixe */
    top: 70px; /* Hauteur de .read-controls */
    left: 0; right: 0; bottom: 0;
    overflow-y: auto; /* Scroll vertical global si besoin */
  }

  /* Cible TOUTES les variations de .read-text-container sur desktop */
  .read-text-container,
  .read-text-container.has-flip,
  .read-text-container:not(.has-flip) {
     display: flex; /* Assure flex */
     flex-direction: row;
     width: 100%;
     max-width: 1400px;
     gap: 40px; /* Espace entre les colonnes */
     align-items: flex-start; /* Aligne en haut */
     /* Annuler min-height mobile si besoin */
     min-height: auto;
  }


   .read-text-container > .read-text,
   .read-text-container > .read-translation,
   .read-text-container.has-flip .read-text, /* Spécificité pour flip */
   .read-text-container.has-flip .read-translation,
   .read-text-container:not(.has-flip) .read-text, /* Spécificité pour not-flip */
   .read-text-container:not(.has-flip) .read-translation {
      flex: 1;
      width: auto;
      min-width: 0; /* Permet de rétrécir */
      padding: 30px; /* Padding interne */
      margin-bottom: 0;
      /* Styles visuels */
      background: var(--card); border: 1px solid var(--border);
      box-shadow: var(--shadow); border-radius: 16px;
      /* Annuler min-height mobile et gérer scroll */
      min-height: auto;
      overflow-y: visible; /* Laisse .read-content gérer le scroll */
      height: auto; /* Hauteur naturelle */
   }

   .read-text-container > .read-translation,
   .read-text-container.has-flip .read-translation,
   .read-text-container:not(.has-flip) .read-translation {
       background: var(--panel); display: block;
       font-size: 0.9em; line-height: 1.8; color: var(--muted); font-style: italic;
   }

   /* Neutraliser Flip structure UNIQUEMENT si elle existe */
   .read-text-container.has-flip .flip-container,
   .read-text-container.has-flip .flip-inner,
   .read-text-container.has-flip .flip-front,
   .read-text-container.has-flip .flip-back {
       display: contents; /* Dissout la structure */
       position: relative; transform: none; backface-visibility: visible;
       width: auto; min-height: auto; /* Annuler min-height flip */
       height: auto; padding: 0; /* Annuler padding flip */
       border: none; box-shadow: none; /* Annuler styles flip */
   }


  /* 2. Faire disparaître la structure du swiper visuellement */
  .read-controls-inner,
  .read-panel {
    display: contents; /* Aplatir */
    padding: 0; min-height: auto;
    overflow: visible; flex-basis: auto; order: initial; /* Annuler styles swiper */
  }

  /* 3. Cacher les dots */
  .read-controls-dots { display: none !important; }

  /* 4. Rétablir la barre de progression */
  .read-progress {
    display: block !important;
    flex: 1 1 auto;
    order: initial; flex-basis: auto; margin: 0 10px;
    min-width: 150px; height: 8px; cursor: pointer; /* Styles visuels */
  }

  /* 5. Rétablir l'apparence COMPLÈTE de la jauge de difficulté */
  #rc-difficulty-gauge.difficulty-gauge {
      display: flex !important; flex-direction: column; gap: 4px; padding: 8px 12px;
      background: var(--card); border: 1px solid var(--border); border-radius: 10px;
      flex-shrink: 0; height: auto; max-height: none; margin-left: auto;
      order: initial; margin-top: 0; border-color: var(--border);
      align-items: initial; /* Annuler alignement chip mobile */
      box-sizing: content-box; /* Annuler box-sizing chip mobile */
  }
  #rc-difficulty-gauge .difficulty-label,
  #rc-difficulty-gauge .difficulty-bar { display: block !important; }
  #rc-difficulty-gauge #readDifficultyText {
      padding: 0; font-size: 12px; font-weight: 700; color: var(--fg) !important;
      height: auto; max-height: none; border-radius: 0; background-color: transparent;
      order: initial; margin-left: 0; margin-top: 0; line-height: initial; border: none;
  }

  /* 6. Rétablir le layout des filtres et du bouton focus */
  .read-filter-legend {
      display: flex; /* Assurer flex */
      order: initial; flex-basis: auto; justify-content: flex-start;
      margin-top: 0; margin-right: 10px; flex-wrap: nowrap;
      gap: 6px; align-items: center; min-width: 0;
  }
   .read-filter-legend > span { display: inline !important; }
   .read-legend-focus {
      display: flex; order: initial; margin-left: 10px; margin-top: 0;
      padding: 5px 10px; border-radius: 12px; font-size: 10px;
      border: 2px solid #ffffff !important; color: #ffffff !important; background: transparent;
      height: auto; line-height: initial; box-sizing: content-box; align-items: center;
      justify-content: center; gap: 6px; flex-shrink: 0; white-space: nowrap;
      max-height: none; /* Annuler max-height mobile */
   }
   .read-legend-focus span { display: inline !important; }
   .read-legend-focus.active { background: #ffffff !important; color: var(--bg) !important; }
   .read-legend-focus:disabled {
     opacity: 0.5; filter: grayscale(50%); pointer-events: none;
     border-color: #ffffff !important; color: #ffffff !important; background: transparent !important;
     /* Annuler styles disabled mobile si différents */
   }

  /* 7. Rétablir la taille des contrôles */
  .read-close { width: 44px; height: 44px; }
  .read-play-pause { width: 48px; height: 48px; }
  .read-mode-toggle, .read-zen-toggle { padding: 10px 16px; font-size: 14px; }
  .read-font-btn { width: 36px; height: 36px; font-size: 14px; }
  .read-font-size { font-size: 12px; min-width: 45px; height: 36px; display: inline-flex; align-items: center; justify-content: center; }
  .read-legend-chip { padding: 6px 12px; font-size: 11px; }

  /* 8. Cacher les boutons hide/show sur Desktop */
  .controls-toggle-btn { display: none !important; }

  /* 9. Cacher le bouton Flip */
  .read-flip-btn { display: none !important; }

}

/* 🔁 FORCE STYLE TEXTE NU EN SUPER ZEN */
.read-page.super-zen .read-text,
.read-page.super-zen .read-translation,
.read-page.super-zen .flip-front.read-text,
.read-page.super-zen .flip-back.read-translation {
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  padding: 0 !important;
  border-radius: 0 !important;
  width: auto !important;
  min-width: 0 !important;
  flex: none !important;
  text-align: center !important;
}

/* Taille et line-height spécifiques Super Zen */
.read-page.super-zen .read-text,
.read-page.super-zen .flip-front.read-text {
  font-size: 48px !important;
  line-height: 1.5 !important;
  font-family: 'Noto Sans SC', sans-serif !important;
}

.read-page.super-zen .read-translation,
.read-page.super-zen .flip-back.read-translation {
  font-size: 24px !important;
  line-height: 1.6 !important;
  font-style: italic !important;
  color: var(--muted) !important;
  font-family: 'Inter', sans-serif !important;
}

/* Empile bien chinois puis trad */
.read-page.super-zen #readTextContainer,
.read-page.super-zen .read-text-container,
.read-page.super-zen .flip-container,
.read-page.super-zen .flip-inner {
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: center !important;
  gap: 20px !important;
  max-width: 90% !important;
  margin: 0 auto !important;
}

/* Le conteneur global prend l'écran sans carte derrière */
.read-page.super-zen .read-content {
  background: transparent !important;
  box-shadow: none !important;
  border: none !important;
}
</style>
</head>
<body data-theme="dark">

<div id="homePage" class="container">
  <div class="home-header">
  </div>

  <div class="mode-toggle-container">
    <button id="modeReadBtn" class="mode-toggle-btn active">
      <svg class="mode-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
      </svg>
      <span>Mode Lecture</span>
    </button>
    <button id="modeGameBtn" class="mode-toggle-btn">
      <svg class="mode-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
      </svg>
      <span>Mode Jeu</span>
    </button>
  </div>

  <div class="tabs-container">
    <div class="tabs-nav">
      <button id="tab1Btn" class="tab-btn active">
        <span class="tab-number">1</span>
        <span>Texte & Dictionnaires</span>
      </button>
      <button id="tab2Btn" class="tab-btn">
        <span class="tab-number">2</span>
        <span>Options</span>
      </button>
    </div>

    <div id="tab1" class="tab-content active">
      <div class="card">
        <h2 class="section-title">📝 Votre texte</h2>
        <div class="input-group">
          <label>Texte chinois</label>
          <textarea id="inputZh" placeholder="Collez votre texte chinois ici...">城市的夜晚，总有一种说不出的寂静。街灯亮着，却照不进每个人的心。刘哲坐在办公室里，盯着电脑屏幕上那份还没完成的报告。窗外的霓虹在闪烁，像是无声地提醒他：又是一个加班的夜晚。他已经记不清上一次和家人吃晚饭是什么时候了。妻子发来的信息停留在手机屏幕上：“别太晚回来。”简单的五个字，却让他心里一阵酸涩。同事们一个个离开，只剩下空调的嗡嗡声和键盘的敲击声。刘哲忽然意识到，自己忙碌了这么多年，好像一直在追赶什么，却从未真正停下来想一想。他关掉电脑，走到窗边，看着远处的高楼。那些灯光看似明亮，其实和他一样，都在深夜里努力坚持着。 “也许生活不该只是工作”他轻声对自己说。那一刻，他决定明天早点回家，陪妻子一起吃一顿热乎的晚饭</textarea>
        </div>
        <div class="input-group">
          <label>Traduction française (optionnelle)</label>
          <textarea id="inputTr" placeholder="Collez la traduction ici...">La nuit de la ville a toujours une forme de silence difficile à décrire.
Les lampadaires brillent, mais n’éclairent pas le cœur de chacun.
Liu Zhe est assis dans son bureau, fixant le rapport inachevé sur l’écran de son ordinateur.
Les néons dehors clignotent, comme s’ils lui rappelaient en silence : encore une soirée de travail tardive.

Il ne se souvient plus de la dernière fois qu’il a dîné avec sa famille.
Le message envoyé par sa femme reste affiché sur son téléphone : « Ne rentre pas trop tard. »
Ces cinq mots simples lui serrent pourtant le cœur.

Ses collègues sont partis les uns après les autres, ne laissant que le bourdonnement de la climatisation et le claquement du clavier.
Liu Zhe réalise soudain qu’il a été occupé pendant tant d’années, courant après quelque chose, sans jamais vraiment s’arrêter pour réfléchir.

Il éteint l’ordinateur, s’avance vers la fenêtre et regarde les gratte-ciel au loin.
Ces lumières paraissent brillantes, mais en réalité, comme lui, elles continuent à lutter dans la nuit.

« Peut-être que la vie ne devrait pas se limiter au travail », murmure-t-il pour lui-même.
À cet instant, il décide que demain, il rentrera plus tôt pour dîner chaud avec sa femme.</textarea>
        </div>
        <div id="sentencesPreview" class="status-chip clickable"></div> </div>

      <div class="card">
        <h2 class="section-title">📚 Dictionnaires</h2>
        <div class="input-group">
          <label>Dictionnaire CC-CEDICT (.txt ou .u8)</label>
          <input type="file" id="dictFile" accept=".txt,.u8" />
          <span id="dictStatus" class="status-chip">Aucun dictionnaire chargé</span>
        </div>
        <div class="input-group">
          <label>Liste HSK/Fréquence (CSV: mot,level)</label>
          <input type="file" id="hskFile" accept=".csv" />
          <span id="hskStatus" class="status-chip">Aucune liste importée</span>
        </div>
      </div>
    </div>

    <div id="tab2" class="tab-content">
      <div id="gameOptions">
        <div class="card">
          <h2 class="section-title">🎮 Options du mode jeu</h2>
          <div class="input-group">
  <label>Mode de jeu</label>
  <div class="game-mode-grid" id="gameModeSelector">
    <button class="game-mode-btn active" data-mode="reorder-drag" title="Réorganiser les mots (Drag & Drop)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 18l-4-4-4 4M8 6l4 4 4-4"/></svg>
      <span>Réorganiser</span>
    </button>
    <button class="game-mode-btn" data-mode="free-input" title="Saisie libre (Vérification)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>
      <span>Saisie libre</span>
    </button>
    <button class="game-mode-btn" data-mode="live-typing" title="Frappe en direct (Validation live)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="12" width="18" height="8" rx="2" ry="2" /><path d="M7 12V7a5 5 0 0 1 10 0v5" /></svg>
      <span>Frappe Live</span>
    </button>
    <button class="game-mode-btn" data-mode="time-attack" title="Frappe en direct (Time Attack)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
      <span>Time Attack</span>
    </button>
    <button class="game-mode-btn" data-mode="fill-blanks-char" title="Phrases à trous (Caractères)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
      <span>Trous (Mots)</span>
    </button>
    <button class="game-mode-btn" data-mode="fill-blanks-pinyin" title="Phrases à trous (Pinyin)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 10h3M3 14h3M3 6h3m14 4h-3m3 4h-3m3-8h-3m-4 8v-2.5a1.5 1.5 0 0 1 3 0V18M10 18v-2.5a1.5 1.5 0 0 1 3 0V18"/></svg>
      <span>Trous (Pinyin)</span>
    </button>
  </div>
  <input type="hidden" id="gameMode" value="reorder-drag">
</div>
          <div class="checkbox-container" id="showTranslationCheckContainer">
            <input type="checkbox" id="showTranslationCheck" checked />
            <label for="showTranslationCheck">Afficher la traduction pendant le jeu</label>
          </div>

        </div> <div id="gameModeOptionsContainer">

          <div id="pinyinInputTypeOptions" class="card game-mode-option" style="display:none;">
            <h2 class="section-title">⌨️ Type de Saisie (Pinyin)</h2>
            <div class="input-group">
              <div class="pinyin-input-type-selector">
                <button class="pinyin-input-type-btn active" data-type="keyboard">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="12" width="18" height="8" rx="2" ry="2"></rect><path d="M7 12V7a5 5 0 0 1 10 0v5"></path></svg>
                  <span>Clavier</span>
                </button>
                <button class="pinyin-input-type-btn" data-type="mcq">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 6h8c1.1 0 2 .9 2 2v8c0 1.1-.9 2-2 2H8c-1.1 0-2-.9-2-2V8c0-1.1.9-2 2-2z"></path><path d="M10 12h4"></path><path d="M12 10v4"></path></svg>
                  <span>Choix Multiple</span>
                </button>
              </div>
              <input type="hidden" id="pinyinInputType" value="keyboard">
            </div>
          </div>
          <div id="freeInputOptions" class="card game-mode-option" style="display:none;">
            <h2 class="section-title">Options d'affichage (Saisie Libre)</h2>
            <div class="input-group">
                <div class="display-mode-selector" id="freeInputDisplaySelector">
                    <button class="display-mode-btn active" data-mode="all">Tout afficher</button>
                    <button class="display-mode-btn" data-mode="translation_only">Traduction uniquement</button>
                    <button class="display-mode-btn" data-mode="chinese_only">Chinois uniquement</button>
                </div>
                <input type="hidden" id="freeInputDisplayMode" value="all">
            </div>
          </div>
          
          <div id="timeAttackOptions" class="card game-mode-option" style="display:none;">
            <h2 class="section-title">⏱️ Options Time Attack</h2>
            <div class="input-group">
              <label>Objectif (caractères par minute)</label>
              <div class="slider-container">
                <input type="range" id="cpmAttackTarget" min="5" max="100" value="30" step="5" class="slider"/>
                <span id="cpmAttackTargetValue" class="slider-value">30 car/min</span>
              </div>
            </div>
          </div>
          
          <div id="fillBlanksOptions" class="card game-mode-option" style="display:none;">
            <h2 class="section-title">🧩 Options Phrases à trous</h2>
            <div class="input-group">
              <label>Niveaux à masquer</label>
              <div class="category-selector" id="gameCategorySelector">
                <button class="category-btn active" data-category="hsk">
                  <span class="category-icon">📚</span>
                  <span class="category-label">Niveaux HSK</span>
                </button>
                <button class="category-btn" data-category="freq">
                  <span class="category-icon">📊</span>
                  <span class="category-label">Fréquence</span>
                </button>
              </div>
            </div>

            <div class="input-group">
              <div class="hsk-selector-grid" id="gameHskSelector">
                <button class="hsk-selector-btn active" data-level="1">HSK 1</button>
                <button class="hsk-selector-btn active" data-level="2">HSK 2</button>
                <button class="hsk-selector-btn" data-level="3">HSK 3</button>
                <button class="hsk-selector-btn" data-level="4">HSK 4</button>
                <button class="hsk-selector-btn" data-level="5">HSK 5</button>
                <button class="hsk-selector-btn" data-level="6">HSK 6</button>
                <button class="hsk-selector-btn" data-level="7">HSK 7-9</button>
              </div>

              <div class="hsk-selector-grid" id="gameFreqSelector" style="display: none;">
                <button class="hsk-selector-btn active" data-level="1">0-1k</button>
                <button class="hsk-selector-btn active" data-level="2">1-2k</button>
                <button class="hsk-selector-btn" data-level="3">2-3k</button>
                <button class="hsk-selector-btn" data-level="4">3-4k</button>
                <button class="hsk-selector-btn" data-level="5">4-5k</button>
                <button class="hsk-selector-btn" data-level="6">5-7k</button>
                <button class="hsk-selector-btn" data-level="7">7-10k</button>
                <button class="hsk-selector-btn" data-level="8">10-15k</button>
                <button class="hsk-selector-btn" data-level="9">15-40k</button>
              </div>
			  
			  </div> <div class="checkbox-container" id="showPinyinHintCheckContainer">
        <input type="checkbox" id="showPinyinHintCheck" checked />
        <label for="showPinyinHintCheck">Afficher le sinogramme (indice pinyin)</label>
			              </div>
						            </div>
          
        </div> </div> <div id="readOptions" style="display:none;">
		
		<div class="card">
          <h2 class="section-title">Mode d'affichage</h2>
          <div class="input-group">
            <div class="display-mode-selector" id="readDisplayModeSelector">
              <button class="display-mode-btn active" data-mode="instant">Instantané</button>
              <button class="display-mode-btn" data-mode="type">Frappe</button>
              <button class="display-mode-btn" data-mode="superzen">Superzen</button>
            </div>
            <input type="hidden" id="readDisplayModeSetting" value="instant">
          </div>
        </div>
		
        <div class="card">
          <h2 class="section-title">📖 Options de lecture</h2>
          
          <div class="input-group">
            <label>Type de catégorie</label>
            <div class="category-selector" id="readCategorySelector">
              <button class="category-btn active" data-category="hsk">
                <span class="category-icon">📚</span>
                <span class="category-label">Niveaux HSK</span>
              </button>
              <button class="category-btn" data-category="freq">
                <span class="category-icon">📊</span>
                <span class="category-label">Fréquence</span>
              </button>
            </div>
          </div>

          <div class="input-group">
            <label id="levelSelectorLabel">Niveaux HSK à surligner</label>
            <div class="hsk-selector-grid" id="hskSelector">
              <button class="hsk-selector-btn active" data-level="1">HSK 1</button>
              <button class="hsk-selector-btn active" data-level="2">HSK 2</button>
              <button class="hsk-selector-btn active" data-level="3">HSK 3</button>
              <button class="hsk-selector-btn" data-level="4">HSK 4</button>
              <button class="hsk-selector-btn" data-level="5">HSK 5</button>
              <button class="hsk-selector-btn" data-level="6">HSK 6</button>
              <button class="hsk-selector-btn" data-level="7">HSK 7-9</button>
            </div>

            <div class="hsk-selector-grid" id="freqSelector" style="display: none;">
              <button class="hsk-selector-btn active" data-level="1">0-1k</button>
              <button class="hsk-selector-btn active" data-level="2">1-2k</button>
              <button class="hsk-selector-btn active" data-level="3">2-3k</button>
              <button class="hsk-selector-btn" data-level="4">3-4k</button>
              <button class="hsk-selector-btn" data-level="5">4-5k</button>
              <button class="hsk-selector-btn" data-level="6">5-7k</button>
              <button class="hsk-selector-btn" data-level="7">7-10k</button>
              <button class="hsk-selector-btn" data-level="8">10-15k</button>
              <button class="hsk-selector-btn" data-level="9">15-40k</button>
            </div>
          </div>

          <div class="input-group" style="display: none;">
            <label>Mode d'affichage</label>
            <select id="displayMode">
              <option value="instant">Tout afficher immédiatement</option>
              <option value="type">Révéler caractère par caractère</option>
            </select>
          </div>

          <div class="input-group">
            <label>Taille du texte chinois</label>
            <select id="fontSize">
              <option value="20">Très petit</option>
              <option value="26">Petit</option>
              <option value="34" selected>Moyen</option>
              <option value="42">Grand</option>
              <option value="52">Très grand</option>
            </select>
          </div>

          <div class="input-group">
            <label>Vitesse de révélation</label>
            <div class="slider-container">
              <input type="range" id="cpm" min="30" max="600" value="150" step="10" class="slider"/>
              <span id="cpmValue" class="slider-value">150 car/min</span>
            </div>
          </div>
        </div>

        <div class="card">
          <h2 class="section-title">🎨 Thème</h2>
          <div class="input-group">
            <label>Thème de couleur</label>
            <div class="theme-switcher">
              <button class="theme-btn theme-dark active" data-theme="dark"></button>
              <button class="theme-btn theme-light" data-theme="light"></button>
              <button class="theme-btn theme-paper" data-theme="paper"></button>
            </div>
          </div>
        </div>
      </div> </div> </div> 

  <div class="floating-cta">
    <button id="launchBtn" class="btn-launch">
      <svg class="launch-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
      </svg>
      <span id="launchText">Lancer le jeu</span>
    </button>
  </div>
</div>

<div id="gamePage" class="game-page">
  
  <div class="game-container">
    
    <div id="translationHint" class="translation-hint"></div>

    <div class="game-main-content">
      
      <div id="reorder-drag-mode" class="game-mode-ui" style="display:none;">
        <div class="game-section">
          <h3 class="game-section-title">Mots disponibles</h3>
          <div id="availableWords" class="words-zone"></div>
        </div>
        <div class="game-section">
          <h3 class="game-section-title">Votre phrase</h3>
          <div id="userSentence" class="words-zone drop-zone"></div>
        </div>
      </div>

      <div id="free-input-mode" class="game-mode-ui" style="display:none">
        <div class="game-section">
          <div id="free-input-target-text" class="typing-target-text" style="font-size: 24px; color: var(--muted); margin-bottom: 16px;"></div>
          <h3 class="game-section-title">Tapez la phrase</h3>
          <textarea id="freeInput" class="free-textarea" placeholder="Tapez la phrase ici... (Entrée pour valider)"></textarea>
        </div>
      </div>
      
      <div id="live-typing-mode" class="game-mode-ui" style="display:none">
        <div class="game-section">
          <div id="typing-target-text" class="typing-target-text"></div> <input type="text" id="typing-input" class="typing-input" aria-hidden="true" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        </div>
      </div>

      <div id="time-attack-mode" class="game-mode-ui" style="display:none">
        <div class="game-section">
          <div id="time-attack-target-text" class="typing-target-text"></div> <div id="time-attack-translation" class="translation-hint" style="margin-top: 16px;"></div>
          <input type="text" id="time-attack-input" class="typing-input" aria-hidden="true" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
        </div>
      </div>
      
      <div id="fill-blanks-char-mode" class="game-mode-ui" style="display:none">
         <div class="game-section">
           <h3 class="game-section-title">Complétez la phrase (Caractères)</h3>
           <div id="blanks-display-text-char" class="blanks-display-text"></div>
           <input type="text" id="blanks-input-char" class="blanks-input" placeholder="Tapez le mot manquant... (Entrée pour valider)" />
         </div>
      </div>
      <div id="fill-blanks-pinyin-mode" class="game-mode-ui" style="display:none">
         <div class="game-section">
           <h3 class="game-section-title">Complétez la phrase (Pinyin)</h3>
           <div id="blanks-display-text-pinyin" class="blanks-display-text"></div>
           <input type="text" id="blanks-input-pinyin" class="blanks-input" placeholder="Tapez le pinyin manquant... (Entrée pour valider)" />
		       <div id="pinyin-mcq-options" class="pinyin-mcq-container" style="display: none;">
           </div>
         </div>
      </div>
      </div> <div id="gameResult" class="game-result"></div>

  </div> <div id="gameFooterFixed">
      <div class="game-actions">
        <button id="hintBtn" class="btn-game btn-hint">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
          <span>Indice</span>
        </button>
        <button id="validateBtn" class="btn-game btn-validate">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>
          <span>Valider</span>
        </button>
        <button id="restartBtn" class="btn-game btn-restart">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
          <span>Recommencer</span>
        </button>
      </div>

      <div class="stats-grid">
        <div class="stat-box"><div class="stat-label">Fautes</div><div class="stat-value" id="statErrors">0</div></div>
        <div class="stat-box"><div class="stat-label">Précision</div><div class="stat-value" id="statAccuracy">0%</div></div>
        <div class="stat-box"><div class="stat-label">Caractères</div><div class="stat-value" id="statChars">0/0</div></div>
        <div class="stat-box"><div class="stat-label">Temps / Cible</div><div class="stat-value" id="statTime">0s</div></div>
      </div>

      <div class="game-nav">
        <button id="prevSentenceBtn" class="btn-nav">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"></polyline></svg>
          <span>Précédent</span>
        </button>
        <span id="sentenceCounter" class="sentence-counter">0 / 0</span>
        <button id="nextSentenceBtn" class="btn-nav">
          <span>Suivant</span>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </button>
        <button id="quitGameBtn" class="btn-quit">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
      </div>
  </div> </div>

<div id="pinyinTonePopup">
</div>

<div id="readPage" class="read-page">
  <div class="read-controls">

    <div class="read-controls-inner" id="readControlsInner">

      <div class="read-panel" id="rc-panel-1">
        <button id="readCloseBtn" class="read-close">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>

        <button id="readPlayPause" class="read-play-pause">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
        </button>

        <button id="readModeToggle" class="read-mode-toggle">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="9 11 12 14 22 4"></polyline>
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
          </svg>
          <span>Frappe</span>
        </button>

        <button id="readZenToggle" class="read-zen-toggle">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M12 6v6l4 2"></path>
          </svg>
          <span>Super Zen</span>
        </button>

        <div class="difficulty-gauge" id="rc-difficulty-gauge">
          <div class="difficulty-label">Difficulté</div>
          <div class="difficulty-bar">
            <div class="difficulty-fill" id="readDifficultyFill"></div>
          </div>
          <div class="difficulty-text" id="readDifficultyText">—</div>
        </div>

      </div> <div class="read-panel" id="rc-panel-2">
        <div class="read-filter-legend" id="readFilterLegend">
          <span>FILTRES:</span>
          <button class="read-legend-chip read-legend-focus" id="readFocusToggle">
            <span>Focus</span>
          </button>
        </div>
      </div> <div class="read-panel" id="rc-panel-3">
        <div class="read-font-controls">
          <button id="readFontDown" class="read-font-btn">A-</button>
          <span id="readFontSize" class="read-font-size">34px</span>
          <button id="readFontUp" class="read-font-btn">A+</button>
        </div>
      </div> </div> <div class="read-controls-dots" id="readControlsDots">
      <span class="dot active" data-index="0"></span>
      <span class="dot" data-index="1"></span>
      <span class="dot" data-index="2"></span>
    </div>
    <div class="read-progress" id="readProgress">
      <div class="read-progress-bar" id="readProgressBar"></div>
    </div>

    <button class="controls-toggle-btn" id="hideControlsBtn">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>
    </button>

  </div> <button class="controls-toggle-btn" id="showControlsBtn" style="display: none;">
     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
  </button>

  <div class="read-content">
    <div class="read-text-container" id="readTextContainer">
      <div class="read-text" id="readText"></div>
      <div class="read-translation" id="readTranslation"></div>
    </div>
  </div>

  <button id="readFlipBtn" class="read-flip-btn">
     <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="23 4 23 10 17 10"></polyline>
      <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
    </svg>
  </button>

  <div class="super-zen-controls">
      <button id="szBtnQuit" class="super-zen-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
        <polyline points="16 17 21 12 16 7"></polyline>
        <line x1="21" y1="12" x2="9" y2="12"></line>
      </svg>
      <span>Quitter</span>
    </button>

    <button id="szBtnType" class="super-zen-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9 11 12 14 22 4"></polyline>
        <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
      </svg>
      <span>Frappe</span>
    </button>

    <button id="szBtnPrev" class="super-zen-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
      <span>Préc.</span>
    </button>

    <button id="szBtnPlay" class="super-zen-play">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
    </button>

    <button id="szBtnNext" class="super-zen-btn">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
      <span>Suiv.</span>
    </button>

    <span class="super-zen-progress" id="szProgress">1/10</span>
  </div>
</div> 

<div id="dictModal" class="dict-modal">
  <div class="dict-modal-content">
    <button id="closeDictModal" class="dict-modal-close">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width: 18px; height: 18px;">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>
    <div class="dict-char" id="dictChar"></div>
    <div class="dict-pinyin" id="dictPinyin"></div>
    <div class="dict-definitions" id="dictDefinitions"></div>
  </div>
</div>

<div id="sentencesPreviewModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3 class="modal-title">Aperçu des phrases détectées</h3>
      <button class="modal-close" id="closeSentencesPreviewModal">✕</button>
    </div>
    <div class="modal-body" id="sentencesPreviewModalBody">
      </div>
  </div>
</div>


<script>
'use strict';

// =====================================================
// VARIABLES GLOBALES
// =====================================================
let appMode = 'game';
let dict = { entries: new Map(), wordSet: new Set(), maxLen: 1 };
let levelMap = new Map();

// Game state
let sentences = [];
let translations = [];
let currentSentenceIndex = 0;
let currentGameMode = 'reorder-drag';
let showTranslation = true;
let originalSentence = '';
let currentSentenceTokens = [];
let hintsRevealed = 0;
let gameDisplayMode = 'all';
let gameTimerInterval = null;
let gameStartTime = 0;
let currentBlankIndex = 0;
let fillBlanksData = [];
let pinyinInputBuffer = '';
let pinyinInputType = 'keyboard';

// Read state
let readCategory = 'hsk';
let readSelectedLevels = new Set([1, 2, 3]);
let readDisplayMode = 'instant';
let readFontSize = 34;
let readCPM = 150;
let readIsPlaying = false;
let readCurrentIndex = 0; // Index du caractère chinois courant
let readTranslationCurrentIndex = 0; // Index CIBLE du caractère de traduction courant
let readTimer = null;
let readChars = []; // Array des <span> chinois
let readTranslationChars = []; // Array des <span> de traduction
let readSuperZen = false;
let readSuperZenType = false; // Mode frappe DANS super zen
let isFlipped = false; // Pour le mode mobile flip
let readSentences = []; // Phrases chinoises pour lecture
let readTranslations = []; // Traductions pour lecture
let readFocusMode = false;
let readPauseTimeout = null;
let readSentenceBoundaries = [];
// NOUVEAU: Plus besoin de readSentenceBoundaries, readCurrentSentenceIndex, readSentenceStartTime

let readCurrentSentence = 0; // Gardé pour Super Zen (index de la phrase affichée)


// =====================================================
// UTILITY FUNCTIONS
// =====================================================
function normalizeChineseText(text) {
    if (!text) return '';
    text = text.replace(/[\u200B-\u200D\uFEFF]/g, '');
    text = text.replace(/\r\n?/g, '\n');
    text = text.replace(/\n+/g, ' ');
    const punct = "，。！？；：,.!?;:\"《》『』「」\"\"''（）﹙﹚︹︺【】()";
    text = text.replace(new RegExp(`\\s+([${punct}])`, 'gu'), '$1');
    text = text.replace(new RegExp(`([${punct}])\\s+`, 'gu'), '$1');
    return text.trim();
}

function splitSentences(text) {
    if (!text) return [];
    const parts = text.split(/\s*\/\/\s*/g);
    const result = [];
    for (const part of parts) {
        const s = part.split(/(?<=[。！？])\s*/g).filter(Boolean);
        result.push(...s);
    }
    return result.filter(s => s.trim().length > 0);
}

function parseCedict(raw) {
    const entries = new Map();
    const wordSet = new Set();
    let maxLen = 1;

    for (const line of raw.split(/\r?\n/)) {
        const L = line.trim();
        if (!L || L.startsWith('#')) continue;

        const m = L.match(/^(\S+)\s+(\S+)\s+\[([^\]]+)\]\s+\/(.+)\/$/);
        if (!m) continue;

        const simp = m[2];
        const pinyin = m[3];
        const defs = m[4].split('/').filter(Boolean);

        if (!entries.has(simp)) {
            entries.set(simp, { simp, pinyin, defs });
        }

        wordSet.add(simp);
        if (simp.length > maxLen) maxLen = simp.length;
    }

    return { entries, wordSet, maxLen };
}

function csvToLevelMap(raw) {
    const m = new Map();
    const lines = raw.split(/\r?\n/);
    if (!lines.length) return m;

    let delim = ',';
    if (lines[0].includes(';') && !lines[0].includes(',')) delim = ';';

    for (let i = 1; i < lines.length; i++) {
        const l = (lines[i] || '').trim();
        if (!l) continue;

        const parts = l.split(delim);
        if (parts.length < 2) continue;

        const w = (parts[0] || '').trim().replace(/\s+/g, '');
        const val = (parts[1] || '').trim();
        if (!w || !val) continue;

        const rec = m.get(w) || {};

        if (/^\d+$/.test(val)) {
            const lvl = Math.min(7, Math.max(1, Number(val)));
            rec.hsk = Math.max(rec.hsk || 0, lvl);
        } else if (/^7\s*-\s*9$/.test(val) || val.includes('sept')) {
            rec.hsk = Math.max(rec.hsk || 0, 7);
        } else if (/^\d+\s*-\s*\d+$/.test(val)) {
            const [a, b] = val.split('-').map(x => Number(x.trim()));
            let freq;
            if (a < 1000 && b <= 1000) freq = 1;
            else if (a < 2000 && b <= 2000) freq = 2;
            else if (a < 3000 && b <= 3000) freq = 3;
            else if (a < 4000 && b <= 4000) freq = 4;
            else if (a < 5000 && b <= 5000) freq = 5;
            else if (a < 7000 && b <= 7000) freq = 6;
            else if (a < 10000 && b <= 10000) freq = 7;
            else if (a < 15000 && b <= 15000) freq = 8;
            else freq = 9;
            rec.freq = Math.max(rec.freq || 0, freq);
        } else {
            continue;
        }

        m.set(w, rec);
    }
    console.log('📊 CSV chargé:', m.size, 'mots');
    return m;
}

function segmentText(text, wordSet, maxLen) {
    const tokens = [];
    let i = 0;
    const punct = new Set("，。！？；：,.!?;:\"《》『』「」\"\"''（）﹙﹚︹︺【】()");

    while (i < text.length) {
        const char = text[i];

        if (punct.has(char) || /\s/.test(char)) {
            tokens.push({ text: char, type: 'punc' });
            i++;
            continue;
        }

        let found = false;
        for (let len = Math.min(maxLen, text.length - i); len >= 1; len--) {
            const candidate = text.substring(i, i + len);
            if (wordSet.has(candidate)) {
                tokens.push({ text: candidate, type: 'word' });
                i += len;
                found = true;
                break;
            }
        }

        if (!found) {
            tokens.push({ text: char, type: 'word' });
            i++;
        }
    }

    return tokens;
}

function getLevel(word, category) {
    const d = levelMap.get(word);
    if (!d) return 0;
    return category === 'hsk' ? (d.hsk || 0) : (d.freq || 0);
}

function levelClassFor(word, category) {
    const lvl = getLevel(word, category);
    if (lvl === 0) return '';

    if (category === 'hsk') {
        if (lvl <= 6) return `hsk${lvl}`;
        return 'hsk79';
    } else {
        return `freq${lvl}`;
    }
}

function getDifficultyGradientColor(value, maxLevel) {
  // Assurer que maxLevel est au moins 1 pour éviter division par zéro
  const effectiveMaxLevel = Math.max(1, maxLevel);
  // Normaliser la valeur entre 0 et 1 (en partant de 1 comme base)
  const t = Math.max(0, Math.min(1, (value - 1) / (effectiveMaxLevel - 1)));

  // Vert → bleu → orange → rose → violet
  const stops = [
    [0.00, [8,210,89]],   // vert clair
    [0.25, [34,159,255]], // bleu
    [0.50, [255,180,60]], // jaune-orangé
    [0.75, [255,71,194]], // rose
    [1.00, [160,8,109]]   // violet foncé
  ];

  let i = 0;
  // Trouver le segment de couleur correct
  while (i < stops.length - 2 && t > stops[i + 1][0]) { // stops.length - 2 car on compare avec i+1
      i++;
  }

  const [t1, c1] = stops[i];
  const [t2, c2] = stops[i + 1];

  // Calculer le facteur d'interpolation (éviter division par zéro)
  const factor = (t2 - t1 === 0) ? 0 : Math.max(0, Math.min(1, (t - t1) / (t2 - t1)));

  // Interpoler les composantes RGB
  const r = Math.round(c1[0] + (c2[0] - c1[0]) * factor);
  const g = Math.round(c1[1] + (c2[1] - c1[1]) * factor);
  const b = Math.round(c1[2] + (c2[2] - c1[2]) * factor);

  return `rgb(${r},${g},${b})`;
}

// =====================================================
// UTILITY FUNCTIONS (REPLACE THIS ONE - V3 Difficulty)
// =====================================================

// =====================================================
// UTILITY FUNCTIONS (REPLACE THIS ONE - V5 Difficulty Tuning - Repeated Unknowns)
// =====================================================

// =====================================================
// UTILITY FUNCTIONS (REPLACE THIS ONE - V4 Difficulty Tuning)
// =====================================================

function calculateDifficulty(tokenSents, category) {
  const effectiveCategory = category || readCategory || 'hsk';
  const maxLevel = (effectiveCategory === 'hsk') ? 7.0 : 9.0;
  const hskMaxLevelForBonus = 7.0;

  // --- Constantes de Tuning (Ajustées) ---
  const WEIGHT_LEX_AVG = 0.45; // Plus de poids à la moyenne
  const WEIGHT_HARD_TAIL = 0.55; // Moins de poids au hard tail
  const UNKNOWN_IMPACT_FACTOR = 2.0; // Impact des inconnus légèrement réduit
  const LENGTH_MODERATION_FACTOR = 15.0;
  const BONUS_HSK4_ONLY = 0.15; // NOUVEAU: Petit bonus si HSK 4 est le max détecté
  const BONUS_HSK5 = 0.3;  // Bonus HSK 5 réduit
  const BONUS_HSK6 = 0.5;  // Bonus HSK 6 réduit
  const BONUS_HSK7PLUS = 0.7; // Bonus HSK 7+ réduit
  const GRAMMAR_WEIGHT = 0.05;
  const AVG_SENTENCE_LEN_TARGET = 15; // Gardé pour référence, utilisé plus bas
  const SENTENCE_LEN_ADJUST_FACTOR = 0.02;
  const MAX_SENTENCE_LEN_ADJUST = 0.3;

  // --- 1. Extraction & Analyse Initiale ---
  if (!tokenSents || tokenSents.length === 0) return { scorePct: 0, label: '—', color: 'var(--muted)', level: 1 };
  const allTokens = tokenSents.flat();
  const wordTokens = allTokens.filter(t => t.type === 'word' && !/\s/.test(t.text));
  const wordCount = wordTokens.length;
  if (wordCount === 0) return { scorePct: 0, label: '—', color: 'var(--muted)', level: 1 };

  const freqMap = new Map();
  wordTokens.forEach(t => { freqMap.set(t.text, (freqMap.get(t.text) || 0) + 1); });

  const knownWordLevels = [];
  let unknownCount = 0;
  let hasHSK4 = false, hasHSK5 = false, hasHSK6 = false, hasHSK7plus = false; // Détecter HSK 4 aussi

  for (const [word, f] of freqMap.entries()) {
    const levelData = levelMap.get(word);
    const lvlCurrentCat = levelData?.[effectiveCategory] || 0;
    const lvlHsk = levelData?.hsk || 0;

    if (lvlCurrentCat > 0) {
      knownWordLevels.push({ level: lvlCurrentCat, freq: f });
    } else {
      unknownCount++;
    }

    // Détecter présence de mots HSK 4+
    if (lvlHsk >= 4 && lvlHsk < 5) hasHSK4 = true;
    if (lvlHsk >= 5 && lvlHsk < 6) hasHSK5 = true;
    if (lvlHsk >= 6 && lvlHsk < 7) hasHSK6 = true;
    if (lvlHsk >= 7) hasHSK7plus = true;
  }

  const knownTypesCount = knownWordLevels.length;
  const uniqueWordTypesCount = freqMap.size;
  const unknownRatio = uniqueWordTypesCount > 0 ? unknownCount / uniqueWordTypesCount : 0;

  // --- 2. Score de Base (Mots Connus) ---
  let scoreBaseKnown = 1.0;
  let lexAvgKnown = 1.0;
  let hardTailKnownAvg = 1.0;

  if (knownTypesCount > 0) {
    let weightedSumKnown = 0;
    let totalWeightKnown = 0;
    knownWordLevels.forEach(item => {
      const weight = Math.log(1 + item.freq);
      weightedSumKnown += item.level * weight;
      totalWeightKnown += weight;
    });
    lexAvgKnown = totalWeightKnown > 0 ? weightedSumKnown / totalWeightKnown : 1.0;

    const knownLevelsOnly = knownWordLevels.map(item => item.level).sort((a, b) => b - a);
    const tailCountKnown = Math.min(knownTypesCount, Math.max(1, Math.floor(knownTypesCount * 0.15)));
    hardTailKnownAvg = tailCountKnown > 0
        ? knownLevelsOnly.slice(0, tailCountKnown).reduce((a, b) => a + b, 0) / tailCountKnown
        : lexAvgKnown;

    // Nouvelle combinaison pour scoreBaseKnown
    scoreBaseKnown = (WEIGHT_LEX_AVG * lexAvgKnown) + (WEIGHT_HARD_TAIL * hardTailKnownAvg);
  } else {
      scoreBaseKnown = 1.5; // Si aucun mot connu
  }

  // --- 3. Impact des Mots Inconnus ---
  const lengthFactor = Math.tanh(wordCount / LENGTH_MODERATION_FACTOR);
  // Utiliser une échelle un peu plus douce pour l'impact des inconnus
  const unknownScaling = (0.8 + (maxLevel - scoreBaseKnown)) / (0.8 + maxLevel); // Varie moins vite
  const unknownImpact = unknownRatio * lengthFactor * UNKNOWN_IMPACT_FACTOR * unknownScaling;
  let currentScore = scoreBaseKnown + unknownImpact;

  // --- 4. Bonus Mots Difficiles (HSK 4+) - Hiérarchique ---
  // Appliquer SEULEMENT le bonus du niveau le plus élevé trouvé
  if (hasHSK7plus) {
      currentScore += BONUS_HSK7PLUS;
  } else if (hasHSK6) {
      currentScore += BONUS_HSK6;
  } else if (hasHSK5) {
      currentScore += BONUS_HSK5;
  } else if (hasHSK4) { // Appliqué seulement si 4 est le max
      currentScore += BONUS_HSK4_ONLY;
  }
  // Note: Si le texte ne contient que HSK 1-3, aucun bonus n'est ajouté ici.

  // --- 5. Ajustements Mineurs (Grammaire & Longueur Phrase) ---
  const gram = analyzeGrammarComplexity(tokenSents); // Appeler la sous-fonction
  const connScore = Math.min(gram.connectorsPerSent / 1.5, 1);
  const lenScore = Math.min(Math.max(0, (gram.avgSentLen - 10)) / 20, 1);
  const baBeiScore = Math.min((gram.baRate + gram.beiRate) / 0.5, 1);
  const grammarAdjustment = (0.4*connScore + 0.3*lenScore + 0.2*baBeiScore) * GRAMMAR_WEIGHT * maxLevel;
  currentScore += grammarAdjustment;

  // Ajustement longueur phrase
  const avgSentLenConst = AVG_SENTENCE_LEN_TARGET; // Assigner à une var locale pour utilisation
  let sentenceLengthAdjustment = (gram.avgSentLen - avgSentLenConst) * SENTENCE_LEN_ADJUST_FACTOR;
  sentenceLengthAdjustment = Math.max(-MAX_SENTENCE_LEN_ADJUST, Math.min(MAX_SENTENCE_LEN_ADJUST, sentenceLengthAdjustment));
  currentScore += sentenceLengthAdjustment;


  // --- 6. Plafonnement et Formatage ---
  const finalScore = Math.max(1.0, Math.min(maxLevel + 0.5, currentScore)); // Borner (permet un léger dépassement interne)

  const scorePct = Math.round(((finalScore - 1) / (maxLevel - 1)) * 100);
  let displayLabel = '';
  let displayScoreForColor = finalScore; // Score utilisé pour la couleur

  if (effectiveCategory === 'hsk') {
    // Brider l'affichage à maxLevel (7.0), mais utiliser le score potentiellement > 7 pour la couleur
    displayLabel = `HSK ${Math.min(maxLevel, finalScore).toFixed(1)}`;
    displayScoreForColor = Math.min(maxLevel, finalScore); // Utiliser le score bridé pour la couleur HSK
  } else { // 'freq'
     const freqMapScale = [500, 1000, 2000, 3000, 4000, 5000, 7000, 10000, 15000, 20000];
     const freqIndex = Math.min(freqMapScale.length - 1, Math.max(0, Math.round(finalScore) - 1));
     let freqValue = freqMapScale[freqIndex];
     freqValue = Math.round(freqValue / 100) * 100;
     displayLabel = `~${freqValue}`;
     // Pour la couleur freq, on peut utiliser l'échelle 1-9
     displayScoreForColor = Math.min(maxLevel, finalScore);
  }

  const color = getDifficultyGradientColor(displayScoreForColor, maxLevel); // Utiliser le score (potentiellement bridé) pour la couleur

  // Log détaillé
  console.log(`Difficulty V4 Breakdown: BaseKnown=${scoreBaseKnown.toFixed(2)} (LexAvg:${lexAvgKnown.toFixed(2)}, Tail:${hardTailKnownAvg.toFixed(2)}), UnknownImpact=${unknownImpact.toFixed(2)} (Ratio:${unknownRatio.toFixed(2)}, LenFactor:${lengthFactor.toFixed(2)}), HSKBonus=${(hasHSK7plus?BONUS_HSK7PLUS:(hasHSK6?BONUS_HSK6:(hasHSK5?BONUS_HSK5:(hasHSK4?BONUS_HSK4_ONLY:0)))).toFixed(2)}, GramAdj=${grammarAdjustment.toFixed(2)}, SentLenAdj=${sentenceLengthAdjustment.toFixed(2)} -> Final=${finalScore.toFixed(2)} -> Display=${displayLabel}`);

  return {
    scorePct: Math.max(0, Math.min(100, scorePct)),
    label: displayLabel,
    color: color,
    level: finalScore,
  };


  // === Sous-fonction grammaire simplifiée (inchangée) ===
  function analyzeGrammarComplexity(tokenSents){
    // ... (code identique à la version précédente) ...
     const connectors = new Set(['因为','所以','虽然','但是','而且','于是','然而','不过','即使','尽管','同时','不仅','还','无论','只要','否则','才','就','却','因此','此外','另外','反而']);
    const patterns = [['虽然','但是'], ['尽管','还'], ['因为','所以'], ['不仅','而且'], ['即使','也'], ['无论','都'], ['只要','就'],['只有','才'], ['不是','就是']];
    let totalConns=0, totalBa=0, totalBei=0, totalWordTokens=0, comp3=0, patt=0;
    const sCount = tokenSents.length || 1;

    for(const sent of tokenSents){
      const sentenceWordTokens = sent.filter(t => t.type === 'word' && !/\s/.test(t.text));
      totalWordTokens += sentenceWordTokens.length;
      const words = sentenceWordTokens.map(t=>t.text);

      for(const w of words){
        if(connectors.has(w)) totalConns++;
        if(w==='把') totalBa++;
        if(w==='被') totalBei++;
        if(w.length>=3) comp3++;
      }
      for(const [a,b] of patterns){
        if(words.includes(a) && words.includes(b)) patt++;
      }
    }

    return {
      connectorsPerSent: totalConns / sCount,
      baRate: totalBa / sCount,
      beiRate: totalBei / sCount,
      avgSentLen: totalWordTokens / sCount,
      compound3Rate: comp3 / Math.max(1, totalWordTokens),
      patternScore: patt / sCount
    };
  }
} // Fin de calculateDifficulty

function numericToDiacriticPinyin(pinyin) {
    const toneMarks = { a:['ā','á','ǎ','à','a'], e:['ē','é','ě','è','e'], i:['ī','í','ǐ','ì','i'], o:['ō','ó','ǒ','ò','o'], u:['ū','ú','ǔ','ù','u'], ü:['ǖ','ǘ','ǚ','ǜ','ü'], v:['ǖ','ǘ','ǚ','ǜ','ü'] };
    const priority = ['a', 'o', 'e', 'i', 'u', 'ü', 'v'];

    return pinyin.replace(/([a-züv:]+)([1-5])/gi, (match, syllable, toneNum) => {
        const toneIndex = parseInt(toneNum) - 1;
        let vowelFound = false;

        for (const vowel of priority) {
            if (syllable.includes(vowel)) {
                const marks = toneMarks[vowel];
                if (marks) {
                    syllable = syllable.replace(vowel, marks[toneIndex]);
                    vowelFound = true;
                    break;
                }
            }
        }

        if (!vowelFound) {
             for (let i = syllable.length - 1; i >= 0; i--) {
                 const char = syllable[i].toLowerCase();
                 const marks = toneMarks[char];
                 if (marks) {
                    syllable = syllable.substring(0, i) + marks[toneIndex] + syllable.substring(i + 1);
                    break;
                 }
             }
        }

        syllable = syllable.replace('v', 'ü');

        return syllable;
    });
}

function normalizeForComparison(text) {
    const punctRegex = /[，。！？；：,.!?;:"《》『』「」""''（）﹙﹚︹︺【】()]/g;
    return text.replace(/\s+/g, '').replace(punctRegex, '');
}

function updateSentencesPreview() {
  const zhText = document.getElementById('inputZh').value.trim();
  const trText = document.getElementById('inputTr').value.trim();
  const preview = document.getElementById('sentencesPreview');

  if (!zhText) {
    preview.textContent = '';
    preview.classList.remove('clickable');
    preview.removeEventListener('click', handlePreviewClick);
    return;
  }

  const normalizedZh = normalizeChineseText(zhText);
  const zhSentences = splitSentences(normalizedZh);

  let trSentences = [];
  if (trText) {
    trSentences = trText.split(/\s*\/\/\s*/).flatMap(part => {
      return part.split(/(?<=[.!?])\s+/g);
    }).filter(Boolean).map(s => s.trim());
  }

  preview.textContent = `${zhSentences.length} phrase(s) détectée(s)` +
    (trSentences.length > 0 ? ` • ${trSentences.length} traduction(s)` : '');

  preview.classList.add('clickable');
  preview.removeEventListener('click', handlePreviewClick);
  preview.addEventListener('click', handlePreviewClick);
}

function handlePreviewClick() {
    const zhText = document.getElementById('inputZh').value.trim();
    const trText = document.getElementById('inputTr').value.trim();
    const normalizedZh = normalizeChineseText(zhText);
    const zhSentences = splitSentences(normalizedZh);
    let trSentences = [];
    if (trText) {
        trSentences = trText.split(/\s*\/\/\s*/).flatMap(part => {
        return part.split(/(?<=[.!?])\s+/g);
        }).filter(Boolean).map(s => s.trim());
    }
    showSentencesPreviewModal(zhSentences, trSentences);
}


function switchMode(mode) {
    appMode = mode;

    document.querySelectorAll('.mode-toggle-btn').forEach(btn => btn.classList.remove('active'));

    if (mode === 'game') {
        document.getElementById('modeGameBtn').classList.add('active');
        document.getElementById('gameOptions').style.display = 'block';
        document.getElementById('readOptions').style.display = 'none';
        document.getElementById('launchText').textContent = 'Lancer le jeu';
    } else {
        document.getElementById('modeReadBtn').classList.add('active');
        document.getElementById('gameOptions').style.display = 'none';
        document.getElementById('readOptions').style.display = 'block';
        document.getElementById('launchText').textContent = 'Lancer la lecture'; // <-- C'est cette ligne qui était incorrecte
    }
}

function switchTab(tabNumber) {
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    document.getElementById(`tab${tabNumber}Btn`).classList.add('active');
    document.getElementById(`tab${tabNumber}`).classList.add('active');
}

// =====================================================
// GAME MODE FUNCTIONS
// =====================================================
function startGame() {
  const zhText = document.getElementById('inputZh').value.trim();
  if (!zhText) {
    alert('⚠️ Veuillez entrer un texte chinois.');
    return;
  }
  if (!dict || dict.wordSet.size === 0) {
      alert('⚠️ Veuillez charger un dictionnaire CC-CEDICT.');
      return;
  }
  if (!levelMap || levelMap.size === 0) {
      alert('⚠️ Veuillez charger une liste HSK/Fréquence.');
  }

  const normalizedText = normalizeChineseText(zhText);
  sentences = splitSentences(normalizedText);

  const trText = document.getElementById('inputTr').value.trim();
  if (trText) {
    translations = trText.split(/\s*\/\/\s*/).flatMap(part => {
      return part.split(/(?<=[.!?])\s+/g);
    }).filter(Boolean).map(s => s.trim());
  } else {
    translations = [];
  }

  currentGameMode = document.getElementById('gameMode').value;

// Définit les options d'affichage en fonction du mode
if (currentGameMode === 'free-input') {
    gameDisplayMode = document.getElementById('freeInputDisplayMode').value;
    showTranslation = false; // Désactive l'ancienne variable pour ce mode
} else {
    showTranslation = document.getElementById('showTranslationCheck').checked;
    gameDisplayMode = 'all'; // Réinitialise pour les autres modes
}

currentSentenceIndex = 0;

  document.getElementById('homePage').style.display = 'none';
  document.getElementById('gamePage').classList.add('active');

  loadSentence();
}

/**
 * Ajuste la taille de la police des éléments de jeu en fonction de la longueur de la phrase.
 */
function adjustFontSizeForSentenceLength() {
    const sentence = originalSentence || '';
    const length = sentence.length;

    // Éléments à redimensionner
    const translationHint = document.getElementById('translationHint');
    const typingTarget = document.getElementById('typing-target-text');
    const timeAttackTarget = document.getElementById('time-attack-target-text');
    const freeInputTarget = document.getElementById('free-input-target-text');
    
// Tailles de police de base (prises du CSS)
    const baseTokenSize = 24; // .word-token
    const baseTokenPadding = 12; // .word-token padding vertical
    const baseHintSize = 16; /* <-- Taille mise à jour */
    const baseTypingSize = 28;
	
    // Paramètres de réduction
    const minLength = 35;  // Longueur (nb de caractères) à partir de laquelle la réduction commence
    const maxLength = 90;  // Longueur pour laquelle la réduction est maximale
    const minFactor = 0.65; // Facteur de réduction max (65% de la taille originale)

    let reductionFactor = 1.0; // 1.0 = 100% (pas de réduction)

    if (length > minLength) {
        // Calcule le ratio de réduction
        const ratio = Math.min(1, (length - minLength) / (maxLength - minLength));
        reductionFactor = 1.0 - (ratio * (1.0 - minFactor));
    }

    // *** MODIFICATION : Mettre tout ce bloc en commentaire ***
    /*
    // Appliquer aux tokens du mode Drag & Drop (s'ils existent)
    const tokens = document.querySelectorAll('#availableWords .word-token, #userSentence .word-token');
    tokens.forEach(token => {
        token.style.fontSize = `${baseTokenSize * reductionFactor}px`;
        // Réduire aussi le padding pour que les tokens prennent moins de place
        token.style.padding = `${baseTokenPadding * reductionFactor}px ${baseTokenPadding * 1.6 * reductionFactor}px`;
    });
    */
    // *** FIN DE LA MODIFICATION ***


    // Appliquer à la traduction
    if (translationHint) {
        translationHint.style.fontSize = `${baseHintSize * reductionFactor}px`;
    }
    
    // Appliquer aux autres modes "Frappe"
    if (typingTarget) {
        typingTarget.style.fontSize = `${(baseTypingSize * 0.85) * reductionFactor}px`;
    }
}

function loadSentence() {
  // === AJOUT : Réinitialiser les tailles de police des conteneurs ===
  const elementsToReset = [
      document.getElementById('translationHint'),
      document.getElementById('typing-target-text'),
      document.getElementById('time-attack-target-text'),
      document.getElementById('free-input-target-text')
  ];
  elementsToReset.forEach(el => {
      if (el) {
          el.style.fontSize = ''; // Réinitialise à la valeur CSS par défaut
      }
  });
  // La réinitialisation des tokens se fera dans createWordToken
  // === FIN AJOUT ===

  originalSentence = sentences[currentSentenceIndex];
  hintsRevealed = 0;
  currentSentenceTokens = segmentText(originalSentence, dict.wordSet, dict.maxLen);

  const resultDiv = document.getElementById('gameResult');
  const gameActions = document.querySelector('.game-actions');
  if (resultDiv && gameActions) {
    gameActions.parentNode.insertBefore(resultDiv, gameActions);
  }

  document.getElementById('sentenceCounter').textContent =
    `${currentSentenceIndex + 1} / ${sentences.length}`;

const translationHint = document.getElementById('translationHint');
const freeInputTarget = document.getElementById('free-input-target-text');

// Réinitialiser les affichages
if(translationHint) translationHint.style.display = 'none';
if(freeInputTarget) freeInputTarget.style.display = 'none';

  document.getElementById('gameResult').style.display = 'none';

  document.querySelectorAll('.game-mode-ui').forEach(el => el.style.display = 'none');

  const gameActionsEl = document.querySelector('.game-actions');
  const hintBtn = document.getElementById('hintBtn');
  const validateBtn = document.getElementById('validateBtn');
  const restartBtn = document.getElementById('restartBtn');

  if(hintBtn) hintBtn.style.display = 'none';
  if(validateBtn) validateBtn.style.display = 'none';
  if(restartBtn) restartBtn.style.display = 'none';

  if (currentGameMode === 'time-attack') {
      if(restartBtn) restartBtn.style.display = 'inline-flex';
      if(gameActionsEl) gameActionsEl.style.display = 'flex';

  } else if (currentGameMode === 'live-typing') {
      if(gameActionsEl) gameActionsEl.style.display = 'none';

  } else {
      if(hintBtn) hintBtn.style.display = 'inline-flex';
      if(validateBtn) validateBtn.style.display = 'inline-flex';
      if(gameActionsEl) gameActionsEl.style.display = 'flex';
  }

  const modeUI = document.getElementById(`${currentGameMode}-mode`);
  if (modeUI) {
      if (currentGameMode === 'reorder-drag' || currentGameMode === 'live-typing' || currentGameMode === 'time-attack' || currentGameMode.startsWith('fill-blanks')) {
          modeUI.style.display = 'flex';
      } else {
          modeUI.style.display = 'block';
      }
  } else {
    console.error(`UI pour mode ${currentGameMode} non trouvée!`);
    const fallbackUI = document.getElementById('free-input-mode') || document.getElementById('reorder-drag-mode');
     if(fallbackUI) fallbackUI.style.display = 'block';
  }

  if (currentGameMode === 'free-input' && modeUI) {
  modeUI.style.display = 'block';
}

  switch (currentGameMode) {
    case 'reorder-drag':
      initReorderMode();
      break;
case 'free-input':
  initFreeMode();
  // Logique d'affichage spécifique pour Saisie Libre
  switch (gameDisplayMode) {
    case 'all':
      if (translations[currentSentenceIndex]) {
        translationHint.textContent = translations[currentSentenceIndex];
        translationHint.style.display = 'block';
      }
      freeInputTarget.textContent = originalSentence;
      freeInputTarget.style.display = 'block';
      break;
    case 'translation_only':
      if (translations[currentSentenceIndex]) {
        translationHint.textContent = translations[currentSentenceIndex];
        translationHint.style.display = 'block';
      }
      // freeInputTarget reste 'none'
      break;
    case 'chinese_only':
      // translationHint reste 'none'
      freeInputTarget.textContent = originalSentence;
      freeInputTarget.style.display = 'block';
      break;
  }
  break;
    case 'live-typing':
      initLiveTypingMode();
      break;
    case 'time-attack':
       initLiveTypingMode(true);
      break;
    case 'fill-blanks-char':
      initFillBlanksMode(false);
      break;
    case 'fill-blanks-pinyin':
      initFillBlanksMode(true);
      break;
  }

  document.getElementById('prevSentenceBtn').disabled = currentSentenceIndex === 0;
  document.getElementById('nextSentenceBtn').disabled = currentSentenceIndex === sentences.length - 1;

resetLiveStats(); // Réinitialise les valeurs affichées

  const statsGrid = document.querySelector('.stats-grid');
  if (statsGrid) { // Vérifier si l'élément existe
    if (currentGameMode === 'live-typing' || currentGameMode === 'time-attack') {
      statsGrid.style.display = 'grid'; // Afficher pour les modes frappe
    } else {
      statsGrid.style.display = 'none'; // Cacher pour tous les autres modes
    }
  } else {
      console.error("Stats grid element not found!"); // Message d'erreur si l'élément n'est pas trouvé
  }

  checkAndResizeFonts();

  const inputElement = document.querySelector(`#${currentGameMode}-mode input, #${currentGameMode}-mode textarea`);
  if (inputElement) {
      setTimeout(() => inputElement.focus(), 50);
  }


  adjustFontSizeForSentenceLength();
if (currentGameMode !== 'free-input' && currentGameMode !== 'time-attack' && showTranslation && translations[currentSentenceIndex]) {
    translationHint.textContent = translations[currentSentenceIndex];
    translationHint.style.display = 'block';
  }

  startGameTimer();
}

function initReorderMode() {
  const words = currentSentenceTokens.filter(t => (t.type === 'word' || t.type === 'punc') && !/\s/.test(t.text)).map(t => t.text);
  const shuffled = [...words].sort(() => Math.random() - 0.5);

  const availableWords = document.getElementById('availableWords');
  const userSentence = document.getElementById('userSentence');

  availableWords.innerHTML = '';
  userSentence.innerHTML = '';

  shuffled.forEach(word => {
    const token = createWordToken(word);
    availableWords.appendChild(token);
  });

  setupDragAndDrop();
  
  // === AJOUT : Appeler l'ajustement ICI ===
  // Cela garantit que la police est redimensionnée dès que les tokens sont créés.
  adjustFontSizeForSentenceLength();
  // === FIN AJOUT ===
}

function createWordToken(word) {
    const token = document.createElement('div');
    token.className = 'word-token';
    token.textContent = word;
    token.draggable = true;
    // === AJOUT : Réinitialiser le style ici ===
    token.style.fontSize = ''; // Utilise la taille CSS par défaut
    token.style.padding = ''; // Utilise le padding CSS par défaut
    // === FIN AJOUT ===
    return token;
 }

function setupDragAndDrop() {
    const containers = [document.getElementById('availableWords'), document.getElementById('userSentence')];
    let draggedElement = null;
    let placeholder = document.createElement('div');
    placeholder.className = 'drop-placeholder';

    let touchMovePlaceholder = null;
    let startX = 0;
    let startY = 0;

    document.querySelectorAll('.word-token').forEach(token => {
        token.removeEventListener('dragstart', handleDragStart);
        token.removeEventListener('dragend', handleDragEnd);
        token.removeEventListener('touchstart', handleTouchStart);
        token.removeEventListener('touchmove', handleTouchMove);
        token.removeEventListener('touchend', handleTouchEnd);
        token.removeEventListener('click', handleTokenClick);

        token.addEventListener('dragstart', handleDragStart);
        token.addEventListener('dragend', handleDragEnd);
        token.addEventListener('touchstart', handleTouchStart, { passive: false });
        token.addEventListener('touchmove', handleTouchMove, { passive: false });
        token.addEventListener('touchend', handleTouchEnd);
        token.addEventListener('click', handleTokenClick);
    });

    containers.forEach(container => {
        container.removeEventListener('dragover', handleDragOver);
        container.removeEventListener('dragleave', handleDragLeave);
        container.removeEventListener('drop', handleDrop);

        container.addEventListener('dragover', handleDragOver);
        container.addEventListener('dragleave', handleDragLeave);
        container.addEventListener('drop', handleDrop);
    });

    function handleTokenClick(e) {
        if (!e.target.classList.contains('word-token')) return;
        const token = e.target;
        const currentZone = token.parentNode;
        const targetZoneId = currentZone.id === 'availableWords' ? 'userSentence' : 'availableWords';
        const targetZone = document.getElementById(targetZoneId);
        if (targetZone) {
            targetZone.appendChild(token);
        }
    }

    function handleDragStart(e) {
        draggedElement = this;
        e.dataTransfer.effectAllowed = 'move';
        setTimeout(() => this.classList.add('dragging'), 0);
    }

    function handleDragEnd(e) {
        this.classList.remove('dragging');
        if (placeholder.parentNode) {
            placeholder.parentNode.removeChild(placeholder);
        }
        draggedElement = null;
    }

    function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        const container = this;
        // *** MODIFIÉ : Ajout de e.clientY ***
        const afterElement = getDragAfterElement(container, e.clientX, e.clientY);

        if (afterElement == null) {
            container.appendChild(placeholder);
        } else {
            container.insertBefore(placeholder, afterElement);
        }
        placeholder.classList.add('drag-over');
    }

    function handleDragLeave(e) {
         placeholder.classList.remove('drag-over');
         if (e.relatedTarget && this.contains(e.relatedTarget)) {
            return;
         }
         if (placeholder.parentNode) {
            placeholder.parentNode.removeChild(placeholder);
         }
    }

    function handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();

        if (draggedElement) {
            if (placeholder.parentNode) {
                 placeholder.parentNode.insertBefore(draggedElement, placeholder);
                 placeholder.parentNode.removeChild(placeholder);
            } else {
                this.appendChild(draggedElement);
            }
            draggedElement.classList.remove('dragging');
        }
    }

    function handleTouchStart(e) {
        if (e.touches.length > 1) return;

        draggedElement = this;
        draggedElement.classList.add('dragging');

        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;

        touchMovePlaceholder = placeholder.cloneNode(true);
        touchMovePlaceholder.style.width = `${draggedElement.offsetWidth}px`;
        touchMovePlaceholder.style.height = `${draggedElement.offsetHeight}px`;

        draggedElement.style.position = 'fixed';
        draggedElement.style.zIndex = '10005';
        draggedElement.style.left = `${touch.clientX - draggedElement.offsetWidth / 2}px`;
        draggedElement.style.top = `${touch.clientY - draggedElement.offsetHeight / 2}px`;
    }

    function handleTouchMove(e) {
        if (!draggedElement || e.touches.length > 1) return;
        e.preventDefault();

        const touch = e.touches[0];

        draggedElement.style.left = `${touch.clientX - draggedElement.offsetWidth / 2}px`;
        draggedElement.style.top = `${touch.clientY - draggedElement.offsetHeight / 2}px`;

        draggedElement.style.display = 'none';
        let elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
        draggedElement.style.display = '';

        let dropZone = null;
        if (elementBelow) {
             dropZone = elementBelow.closest('.words-zone');
        }

        if (dropZone) {
            // *** MODIFIÉ : Ajout de touch.clientY ***
            const afterElement = getDragAfterElement(dropZone, touch.clientX, touch.clientY);
            if (afterElement) {
                dropZone.insertBefore(touchMovePlaceholder, afterElement);
            } else {
                dropZone.appendChild(touchMovePlaceholder);
            }
        } else if (touchMovePlaceholder.parentNode) {
             touchMovePlaceholder.parentNode.removeChild(touchMovePlaceholder);
        }
    }

    function handleTouchEnd(e) {
        if (!draggedElement) return;

        if (touchMovePlaceholder && touchMovePlaceholder.parentNode) {
            touchMovePlaceholder.parentNode.insertBefore(draggedElement, touchMovePlaceholder);
            touchMovePlaceholder.parentNode.removeChild(touchMovePlaceholder);
        }

        draggedElement.classList.remove('dragging');
        draggedElement.style.position = '';
        draggedElement.style.zIndex = '';
        draggedElement.style.left = '';
        draggedElement.style.top = '';

        draggedElement = null;
        touchMovePlaceholder = null;
    }

    // *** FONCTION ENTIÈREMENT REMPLACÉE ***
    function getDragAfterElement(container, x, y) {
        const draggableElements = [...container.querySelectorAll('.word-token:not(.dragging)')];

        let closestElement = null;
        let minDistance = Number.POSITIVE_INFINITY;

        // Trouver l'élément le plus proche en 2D
        for (const child of draggableElements) {
            const box = child.getBoundingClientRect();
            const centerX = box.left + box.width / 2;
            const centerY = box.top + box.height / 2;
            
            // Calculer la distance euclidienne
            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

            if (distance < minDistance) {
                minDistance = distance;
                closestElement = child;
            }
        }

        if (closestElement === null) {
            return null; // Le conteneur est vide
        } else {
            const box = closestElement.getBoundingClientRect();
            // Décider s'il faut insérer avant ou après l'élément le plus proche
            // en fonction de la position X du curseur par rapport au centre X de l'élément
            if (x < box.left + box.width / 2) {
                return closestElement; // Insérer AVANT l'élément le plus proche
            } else {
                return closestElement.nextElementSibling; // Insérer APRÈS (c'est-à-dire avant son frère suivant)
            }
        }
    }
}


function initFreeMode() {
  const freeInput = document.getElementById('freeInput');
  freeInput.value = '';

  freeInput.onkeydown = null;
  freeInput.onkeydown = (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          validateAnswer();
      }
  };
}

function initLiveTypingMode(isTimeAttack = false) {
    const targetText = originalSentence.replace(/[,\s]/g, '');
    const targetElId = isTimeAttack ? 'time-attack-target-text' : 'typing-target-text';
    const inputElId = isTimeAttack ? 'time-attack-input' : 'typing-input';
    const translationElId = isTimeAttack ? 'time-attack-translation' : null;

    const targetEl = document.getElementById(targetElId);
    const inputEl = document.getElementById(inputElId);

    if (!targetEl || !inputEl) {
        console.error("Missing elements for live typing mode:", targetElId, inputElId);
        return;
    }

    inputEl.disabled = false;

    targetEl.innerHTML = '';
    inputEl.value = '';
    inputEl.maxLength = targetText.length;
    inputEl.style.borderColor = '';

    targetText.split('').forEach((char, index) => {
        const span = document.createElement('span');
        span.textContent = char;
        if (index === 0) span.className = 'char-current';
        targetEl.appendChild(span);
    });

    if (isTimeAttack && translationElId) {
         const translationEl = document.getElementById(translationElId);
         if (translationEl) {
             if (translations[currentSentenceIndex]) {
                translationEl.textContent = translations[currentSentenceIndex];
                translationEl.style.display = 'block';
             } else {
                 translationEl.style.display = 'none';
             }
         }
    } else if (translationElId) {
        const translationEl = document.getElementById(translationElId);
        if(translationEl) translationEl.style.display = 'none';
    }

    document.getElementById('statChars').textContent = `0/${targetText.length}`;

    if (isTimeAttack) {
        const targetCPM = parseInt(document.getElementById('cpmAttackTarget').value, 10);
        const targetTime = Math.ceil((targetText.length / targetCPM) * 60);
        document.getElementById('statTime').textContent = `0s / ${targetTime}s`;
    }

     targetEl.onclick = () => inputEl.focus();
     if(translationElId) {
         const translationEl = document.getElementById(translationElId);
         if (translationEl) translationEl.onclick = () => inputEl.focus();
     }

    let isComposing = false;

    inputEl.oninput = () => {
        if (!isComposing) {
            handleLiveTyping(targetText, targetElId, inputElId, isTimeAttack);
        }
    };

    inputEl.removeEventListener('compositionstart', handleCompositionStart);
    inputEl.removeEventListener('compositionend', handleCompositionEnd);

    function handleCompositionStart() {
        isComposing = true;
    }

    function handleCompositionEnd() {
        isComposing = false;
        handleLiveTyping(targetText, targetElId, inputElId, isTimeAttack);
    }

    inputEl.addEventListener('compositionstart', handleCompositionStart);
    inputEl.addEventListener('compositionend', handleCompositionEnd);

    inputEl.onkeydown = null;
    inputEl.onkeydown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();

            if (isComposing) return;
			
			if (inputEl) inputEl.blur();

            const typedText = inputEl.value;
            const targetSpans = targetEl.querySelectorAll('span');
            let errors = 0;

            targetSpans.forEach((span, index) => {
                if (index < typedText.length && typedText[index] !== targetSpans[index].textContent) {
                    errors++;
                }
            });

            if (typedText.length !== targetText.length) {
                 showResult(false, 'Phrase non terminée.');
                 setTimeout(() => { document.getElementById('gameResult').style.display = 'none'; }, 2000);
                 return;
            }

            if (errors === 0) {
                if (isTimeAttack) {
                    stopGameTimer();
                }
                showResult(true, 'Correct !');
                inputEl.blur();
                setTimeout(() => {
                    if (currentSentenceIndex < sentences.length - 1) {
                        goToSentence(1);
                    } else {
                        showGameResults();
                    }
                }, 1500);
            } else {
                 showResult(false, `Incorrect (${errors} erreur(s)).`);
                 setTimeout(() => { document.getElementById('gameResult').style.display = 'none'; }, 2000);
            }
        }
    };
}

function handleLiveTyping(targetText, targetElId, inputElId, isTimeAttack = false) {
    const inputEl = document.getElementById(inputElId);
    const targetEl = document.getElementById(targetElId);
     if (!inputEl || !targetEl) return;
    const targetSpans = targetEl.querySelectorAll('span');
    const typedText = inputEl.value;
    let errors = 0;
    let correctChars = 0;

    targetSpans.forEach((span, index) => {
        const typedChar = typedText[index];
        const targetChar = span.textContent;

        if (typedChar == null) {
            span.className = (index === typedText.length) ? 'char-current' : '';
        } else if (typedChar === targetChar) {
            span.className = 'char-correct';
            correctChars++;
        } else {
            span.className = 'char-incorrect';
            errors++;
        }
    });

    const accuracy = typedText.length > 0 ? Math.max(0, ((correctChars) / typedText.length) * 100) : 0;
    document.getElementById('statErrors').textContent = errors;
    document.getElementById('statAccuracy').textContent = `${accuracy.toFixed(0)}%`;
    document.getElementById('statChars').textContent = `${typedText.length}/${targetText.length}`;

    if (typedText.length === targetText.length) {
         if (errors === 0) {
            inputEl.style.borderColor = 'var(--correct)';
        } else {
            inputEl.style.borderColor = 'var(--incorrect)';
        }
    } else {
         inputEl.style.borderColor = 'var(--border)';
         if (document.activeElement === inputEl) {
             inputEl.style.borderColor = 'var(--accent)';
         }
    }
}

function initFillBlanksMode(isPinyin = false) {
  const displayElId = isPinyin ? 'blanks-display-text-pinyin' : 'blanks-display-text-char';
  const inputElId = isPinyin ? 'blanks-input-pinyin' : 'blanks-input-char';
  const displayEl = document.getElementById(displayElId);
  const inputEl = document.getElementById(inputElId);
  const mcqContainer = document.getElementById('pinyin-mcq-options'); // Nouveau

  const showPinyinHint = document.getElementById('showPinyinHintCheck').checked;
  // --- NOUVEAU: Lire le type de saisie ---
  pinyinInputType = isPinyin ? document.getElementById('pinyinInputType').value : 'keyboard';

   if (!displayEl || (!inputEl && pinyinInputType === 'keyboard') || (!mcqContainer && pinyinInputType === 'mcq')) {
        console.error("Missing elements for fill blanks mode:", displayElId, inputElId, mcqContainer);
        return;
    }

  displayEl.innerHTML = '';
  if (inputEl) inputEl.value = '';
  if (mcqContainer) mcqContainer.innerHTML = ''; // Vider les options MCQ
  currentBlankIndex = 0;
  fillBlanksData = [];

  // --- Afficher/Cacher les contrôles ---
  if (isPinyin) {
    if (pinyinInputType === 'keyboard') {
      if(inputEl) inputEl.style.display = 'block';
      if(mcqContainer) mcqContainer.style.display = 'none';
    } else { // mcq
      if(inputEl) inputEl.style.display = 'none';
      if(mcqContainer) mcqContainer.style.display = 'flex'; // Utiliser flex pour l'affichage
    }
  } else {
      // Pour le mode caractère, toujours afficher l'input
      if(inputEl) inputEl.style.display = 'block';
      if(mcqContainer) mcqContainer.style.display = 'none';
  }

  const gameCategory = document.querySelector('#gameCategorySelector .category-btn.active')?.dataset.category || 'hsk';
  const selectorId = gameCategory === 'hsk' ? '#gameHskSelector' : '#gameFreqSelector';
  const levelsToHide = new Set();
  document.querySelectorAll(`${selectorId} .hsk-selector-btn.active`).forEach(btn => {
      levelsToHide.add(parseInt(btn.dataset.level));
  });

  let blankCounter = 0;
  if (!currentSentenceTokens || currentSentenceTokens.length === 0) {
       displayEl.textContent = "(Aucun texte à afficher)";
       return;
  }

  currentSentenceTokens.forEach(token => {
      if (token.type === 'word') {
          const level = getLevel(token.text, gameCategory);
          if (level > 0 && levelsToHide.has(level)) {
              const blank = document.createElement('span');
              blank.className = 'blank-space';

              // --- Logique d'affichage de l'indice (inchangée) ---
              if (isPinyin && showPinyinHint) {
                  // --- MODIFIÉ: Envelopper chaque caractère dans un span pour le ciblage MCQ ---
                  blank.innerHTML = ''; // Vider d'abord
                  token.text.split('').forEach((char, charIdx) => {
                      const charSpan = document.createElement('span');
                      charSpan.textContent = char;
                      charSpan.dataset.charIndex = charIdx; // Stocker l'index du caractère
                      blank.appendChild(charSpan);
                  });
                  blank.classList.add('blank-with-hint');
              } else {
                  blank.textContent = '_'.repeat(token.text.length);
              }
              // --- Fin de la modif interne pour l'indice ---

              blank.dataset.index = blankCounter; // Index du mot blanc
              blank.dataset.word = token.text;    // Mot chinois correct
              // --- NOUVEAU: Logique Pinyin améliorée ---
              let pinyins = [];
              const wordEntry = dict.entries.get(token.text); // (e.g., get '屏幕')

              if (wordEntry) {
                  // On a trouvé le mot ! Utiliser son pinyin.
                  const pinyinParts = wordEntry.pinyin.split(' '); // (e.g., ['ping2', 'mu4'])
                  pinyins = pinyinParts.map(p => p ? numericToDiacriticPinyin(p).toLowerCase() : '');
              } else {
                  // Mot non trouvé (ex: nom propre), fallback vers caractère par caractère
                  pinyins = token.text.split('').map(char => {
                      const entry = dict.entries.get(char);
                      // Prend la première prononciation (fallback)
                      const pinyinRaw = entry ? entry.pinyin.split(' ')[0] : '';
                      return pinyinRaw ? numericToDiacriticPinyin(pinyinRaw).toLowerCase() : '';
                  });
              }
              
              // Vérifier que le nombre de pinyins correspond au nombre de caractères
              if (pinyins.length !== token.text.length) {
                   console.warn(`Incohérence Pinyin/Caractère pour "${token.text}". Pinyins: ${pinyins.join(',')}. Attendu: ${token.text.length}. Fallback.`);
                   // Fallback (ancien comportement) si la paires pinyin/char ne correspond pas
                   pinyins = token.text.split('').map(char => {
                      const entry = dict.entries.get(char);
                      const pinyinRaw = entry ? entry.pinyin.split(' ')[0] : '';
                      return pinyinRaw ? numericToDiacriticPinyin(pinyinRaw).toLowerCase() : '';
                   });
              }
              
              const pinyinsStr = pinyins.join(',');
              // --- Fin de la nouvelle logique ---

              blank.dataset.index = blankCounter; // Index du mot blanc
              blank.dataset.word = token.text;    // Mot chinois correct
              blank.dataset.pinyins = pinyinsStr; // <--- Utiliser pinyinsStr


              blank.onclick = () => focusBlank(blankCounter);
              displayEl.appendChild(blank);

              fillBlanksData.push({
                  element: blank,
                  originalWord: token.text,
                  isPinyin: isPinyin,
                  pinyinAnswers: pinyins, // <--- Utiliser le tableau pinyins
                  status: 'pending',
                  currentCharIndex: 0, // Pour le mode MCQ
                  selectedPinyins: [] // Pour stocker les sélections MCQ
              });
              blankCounter++;
          } else {
              displayEl.appendChild(document.createTextNode(token.text));
          }
      } else {
          displayEl.appendChild(document.createTextNode(token.text));
      }
      displayEl.appendChild(document.createTextNode(' ')); // Espace après chaque token
  });

  // Ajuster l'espacement final (supprimer le dernier espace ajouté)
  if (displayEl.lastChild && displayEl.lastChild.nodeType === Node.TEXT_NODE && displayEl.lastChild.textContent.endsWith(' ')) {
      displayEl.lastChild.textContent = displayEl.lastChild.textContent.slice(0, -1);
  }


  focusBlank(0); // Met le focus sur le premier trou

  // --- Enlever/Ajouter le listener clavier ---
  if (inputEl) {
      inputEl.onkeydown = null; // Enlever l'ancien listener
      if (isPinyin && pinyinInputType === 'keyboard') {
          // Remettre le listener SEULEMENT si mode clavier Pinyin
          inputEl.onkeydown = (e) => {
              if (e.key === 'Enter') {
                  e.preventDefault();
                  validateBlank(true); // Valider pour le mode clavier
              } else if (window.innerWidth > 600) { // Condition écran large inchangée
                  handlePinyinInput(e);
              }
          };
      } else if (!isPinyin) {
          // Remettre le listener pour le mode caractère
           inputEl.onkeydown = (e) => {
               if (e.key === 'Enter') {
                  e.preventDefault();
                  validateBlank(false); // Valider pour le mode caractère
              }
           }
      }
  } 
} 

function focusBlank(index) {
    if (index < 0 || index >= fillBlanksData.length) return;

    // --- Enlever le focus visuel de l'ancien blank ---
    if (fillBlanksData[currentBlankIndex] && fillBlanksData[currentBlankIndex].element) {
        fillBlanksData[currentBlankIndex].element.classList.remove('current-blank');
        // Enlever la surbrillance du caractère actif précédent
        const prevActiveChar = fillBlanksData[currentBlankIndex].element.querySelector('.active-char-hint');
        if (prevActiveChar) prevActiveChar.classList.remove('active-char-hint');
    }

    currentBlankIndex = index;
    const currentData = fillBlanksData[currentBlankIndex];

    if (!currentData || !currentData.element) return;

    // --- Gérer la réinitialisation si on clique sur un mot déjà rempli ---
    if (currentData.status !== 'pending') {
        currentData.status = 'pending';
        currentData.currentCharIndex = 0; // Réinitialiser l'index caractère
        currentData.selectedPinyins = []; // Vider les sélections

        // Réafficher l'indice ou les underscores
        const showPinyinHint = document.getElementById('showPinyinHintCheck').checked;
        if (currentData.isPinyin && showPinyinHint) {
            // Recréer les spans caractères pour l'indice
            currentData.element.innerHTML = ''; // Vider
            currentData.originalWord.split('').forEach((char, charIdx) => {
                const charSpan = document.createElement('span');
                charSpan.textContent = char;
                charSpan.dataset.charIndex = charIdx;
                currentData.element.appendChild(charSpan);
            });
            currentData.element.classList.add('blank-with-hint');
        } else {
            currentData.element.textContent = '_'.repeat(currentData.originalWord.length);
        }
        currentData.element.classList.remove('filled-blank-correct', 'filled-blank-incorrect');
        currentData.element.classList.remove('blank-with-hint'); // Assurer que ce style est enlevé si showHint est off
         if (currentData.isPinyin && showPinyinHint) { // Le remettre si showHint est on
             currentData.element.classList.add('blank-with-hint');
         }
    }

    // --- Appliquer le focus visuel sur le mot ---
    currentData.element.classList.add('current-blank');

    // --- Gérer la saisie (Clavier vs MCQ) ---
    if (currentData.isPinyin && pinyinInputType === 'keyboard') {
        const inputEl = document.getElementById('blanks-input-pinyin');
        if (inputEl) {
             setTimeout(() => { // Timeout pour assurer le focus
                 inputEl.focus();
                 inputEl.value = '';
             }, 0);
        }
    } else if (currentData.isPinyin && pinyinInputType === 'mcq') {
        // --- Mode MCQ ---
        currentData.currentCharIndex = 0; // Toujours commencer au premier caractère quand on focus un mot
        currentData.selectedPinyins = []; // Vider les sélections précédentes pour ce mot
        generateAndDisplayPinyinOptions(); // Génère les options pour le premier caractère
    } else { // Mode caractère
        const inputEl = document.getElementById('blanks-input-char');
        if (inputEl) {
            setTimeout(() => {
                 inputEl.focus();
                 inputEl.value = '';
             }, 0);
        }
    }
}

function validateBlank(isPinyin) {
    if (currentBlankIndex >= fillBlanksData.length) return;

    const currentData = fillBlanksData[currentBlankIndex];
    if (!currentData || !currentData.element) return;

    // --- 1. Récupération des inputs ---
    const inputElId = isPinyin ? 'blanks-input-pinyin' : 'blanks-input-char';
    const inputEl = document.getElementById(inputElId);
    if (!inputEl) return;
	
	if (inputEl) inputEl.blur();

    const userAnswer = inputEl.value.trim();
    let isCorrect = false;

    if (isPinyin) {
        // --- Mode Pinyin (Pinyin avec tons attendu) ---
        
        // 1a. Construire la chaîne Pinyin correcte attendue (avec tons diacritiques)
        // Les pinyins dans currentData.pinyinAnswers sont déjà en diacritiques (e.g., nǐ, hǎo)
        const correctPinyinDiacritic = currentData.pinyinAnswers.join('');
        
        // 1b. Normaliser les deux chaînes pour une comparaison (retirer espaces et mettre en minuscule)
        const userNoSpace = userAnswer.toLowerCase().replace(/\s+/g, '');
        const correctNoSpace = correctPinyinDiacritic.toLowerCase().replace(/\s+/g, '');
        
        // 1c. Comparaison
        isCorrect = userNoSpace === correctNoSpace;

        // Si la comparaison directe échoue, tentons une comparaison alternative
        // au cas où l'utilisateur aurait saisi le caractère Hanzi.
        if (!isCorrect) {
             const hanziAnswer = currentData.originalWord;
             isCorrect = userAnswer === hanziAnswer;
        }

    } else {
        // --- Mode Caractères (Hanzi attendu) ---
        const correctAnswer = currentData.originalWord;
        isCorrect = userAnswer === correctAnswer;
    }
    
    // --- 2. Mise à jour de l'UI et progression ---

    // Retirer le focus visuel, même si c'est incorrect
    currentData.element.classList.remove('current-blank'); 

    if (isCorrect) {
        currentData.element.textContent = currentData.originalWord;
        currentData.element.classList.add('filled-blank-correct');
        currentData.status = 'correct';
        
        // Vider le champ d'entrée
        inputEl.value = '';

        // Trouver le prochain trou non rempli
        let nextIndex = currentBlankIndex + 1;
        while(nextIndex < fillBlanksData.length && fillBlanksData[nextIndex].status !== 'pending') {
            nextIndex++;
        }
        
        if (nextIndex < fillBlanksData.length) {
            focusBlank(nextIndex);
        } else {
            // Fin de la phrase
            inputEl.blur();
            showResult(true, "Phrase complétée !");
            setTimeout(() => {
              if (currentSentenceIndex < sentences.length - 1) {
                goToSentence(1);
              } else {
                showGameResults();
              }
            }, 1500);
        }
    } else {
        // --- Réponse incorrecte ---
        showResult(false, isPinyin ? "Pinyin incorrect. Essayez encore !" : "Mot incorrect. Essayez encore !");
        
        // Afficher le résultat temporairement
        setTimeout(() => {
            const resultDiv = document.getElementById('gameResult');
            if (resultDiv) resultDiv.style.display = 'none';
        }, 2000);

        // Réinitialiser le trou pour la prochaine tentative
        focusBlank(currentBlankIndex); 
        inputEl.value = ''; // Vider le champ
    }
}

function handlePinyinInput(event) {
    const inputEl = event.target;
    const vowelRegex = /[aeiouüv]/i;
    const key = event.key;
    const isPopupVisible = document.getElementById('pinyinTonePopup').style.display === 'block';

    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Backspace', 'Delete', 'Enter', 'Tab', 'Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Escape'].includes(key)) {
        hidePinyinTonePopup();
        pinyinInputBuffer = '';
        return;
    }

    if (isPopupVisible && (['1','2','3','4','5','&','é','"','\'','('].includes(key) || key === ' ')) {
        event.preventDefault();
        let tone = 0;
        switch(key) {
            case '1': case '&': tone = 1; break;
            case '2': case 'é': tone = 2; break;
            case '3': case '"': tone = 3; break;
            case '4': case '\'': tone = 4; break;
            case '5': case '(': tone = 5; break;
            case ' ': tone = 5; break;
        }

        const pinyinWithTone = applyToneToVowel(pinyinInputBuffer, tone);
        insertAtCursor(inputEl, pinyinWithTone);
        hidePinyinTonePopup();
        pinyinInputBuffer = '';
    }
    else if (!isPopupVisible && vowelRegex.test(key) && !event.ctrlKey && !event.altKey && !event.metaKey && key.length === 1) {
        pinyinInputBuffer = key;
        showPinyinTonePopup(inputEl, key);
        event.preventDefault();
    }
    else if (isPopupVisible && key.length === 1) {
         insertAtCursor(inputEl, pinyinInputBuffer);
         hidePinyinTonePopup();
         pinyinInputBuffer = '';
    }
     else if (key.length > 1) {
         event.preventDefault();
     }
}

// =====================================================
// NOUVELLES FONCTIONS POUR PINYIN MCQ
// =====================================================

function generateAndDisplayPinyinOptions() {
    const mcqContainer = document.getElementById('pinyin-mcq-options');
    if (!mcqContainer || pinyinInputType !== 'mcq') return;

    mcqContainer.innerHTML = ''; // Vider les anciennes options
    const currentData = fillBlanksData[currentBlankIndex];
    if (!currentData || currentData.status !== 'pending') return;

    const word = currentData.originalWord;
    const charIndex = currentData.currentCharIndex;

    if (charIndex >= word.length) {
        console.warn("Tentative de générer des options au-delà de la fin du mot.");
        return;
    }

    const character = word[charIndex];
    const correctPinyinWithTone = currentData.pinyinAnswers[charIndex];

    if (!correctPinyinWithTone) {
        console.error(`Pinyin introuvable pour le caractère '${character}' du mot '${word}'`);
        mcqContainer.textContent = "Erreur Pinyin";
        return;
    }

    // Génère les options DANS L'ORDRE 1, 2, 3, 4, 5
    const options = generatePinyinVariations(correctPinyinWithTone);

    // --- CETTE LIGNE EST SUPPRIMÉE ---
    // options.sort(() => Math.random() - 0.5); // <-- SUPPRIMER CETTE LIGNE DE MÉLANGE

    // Affiche les options dans l'ordre reçu
    options.forEach(pinyin => {
        const btn = document.createElement('button');
        btn.className = 'pinyin-option-btn';
        btn.textContent = pinyin;
        btn.onclick = () => handlePinyinOptionClick(pinyin);
        mcqContainer.appendChild(btn);
    });

    // Mettre en évidence le caractère actif dans l'indice
    highlightActiveHintChar(currentData.element, charIndex);
}

function highlightActiveHintChar(blankElement, charIndex) {
    // Enlever la surbrillance précédente dans ce mot
    blankElement.querySelectorAll('.active-char-hint').forEach(span => span.classList.remove('active-char-hint'));

    // Trouver et surligner le nouveau caractère actif (s'il existe)
    const charSpan = blankElement.querySelector(`span[data-char-index="${charIndex}"]`);
    if (charSpan) {
        charSpan.classList.add('active-char-hint');
    }
}

function generatePinyinVariations(correctPinyinWithTone) {
    // 1. Validation de l'entrée (inchangée)
    if (!correctPinyinWithTone || correctPinyinWithTone.trim() === '') {
        console.error("generatePinyinVariations a reçu un pinyin vide ou invalide:", correctPinyinWithTone);
        return ['?', '?', '?', '?', '?'];
    }
    correctPinyinWithTone = correctPinyinWithTone.toLowerCase();

    // 2. Extraire la syllabe de base (inchangée)
    let basePinyin = '';
    const baseVowels = {
        'āáǎà': 'a', 'ēéěè': 'e', 'īíǐì': 'i', 'ōóǒò': 'o', 'ūúǔù': 'u', 'ǖǘǚǜü': 'v'
    };
    let foundVowelWithTone = false;
    for (let i = 0; i < correctPinyinWithTone.length; i++) {
        let char = correctPinyinWithTone[i];
        let baseVowelFound = false;
        for (const accentedChars in baseVowels) {
            if (accentedChars.includes(char)) {
                basePinyin += baseVowels[accentedChars];
                baseVowelFound = true;
                foundVowelWithTone = true;
                break;
            }
        }
        if (!baseVowelFound) {
            basePinyin += char;
        }
    }
    basePinyin = basePinyin.replace(/v/g, 'ü');
    if (!foundVowelWithTone) {
        basePinyin = correctPinyinWithTone.replace(/[1-5]/g, '');
    }
    const vowelRegex = /[aeiouü]/i;
    if (!basePinyin || !vowelRegex.test(basePinyin)) {
         console.warn("N'a pas pu déterminer une base pinyin valide pour:", correctPinyinWithTone, "-> Base dérivée:", basePinyin);
          if (!vowelRegex.test(basePinyin)) {
             // Si la base est invalide, on ne peut pas générer les tons dans l'ordre
             // Retournons 5 fois le pinyin original (ou des '?') pour éviter une erreur
             const fallbackOption = correctPinyinWithTone || '?';
             return [fallbackOption, fallbackOption, fallbackOption, fallbackOption, fallbackOption];
          }
    }

    // --- MODIFICATION ICI ---
    // 3. Générer les 5 variations de tons DANS L'ORDRE [1, 2, 3, 4, 5]
    const result = [];
    const tones = [1, 2, 3, 4, 5]; // Ordre fixe

    tones.forEach(toneNum => {
        // Re-remplacer ü par v pour numericToDiacriticPinyin
        const pinyinNum = basePinyin.replace(/ü/g, 'v') + toneNum;
        result.push(numericToDiacriticPinyin(pinyinNum).toLowerCase());
    });
    // --- FIN DE LA MODIFICATION ---

    // 4. Pas besoin de Set, de compléter ou de mélanger
    // console.log("Options générées pour", correctPinyinWithTone, ":", result); // Pour débogage
    return result; // Retourne directement le tableau ordonné
}

function handlePinyinOptionClick(selectedPinyin) {
    const currentData = fillBlanksData[currentBlankIndex];
    if (!currentData || currentData.status !== 'pending') return;

    const charIndex = currentData.currentCharIndex;

    // 1. Enregistrer le choix et avancer
    currentData.selectedPinyins[charIndex] = selectedPinyin;
    currentData.currentCharIndex++;

    // 2. Vérifier si le MOT est terminé
    if (currentData.currentCharIndex >= currentData.originalWord.length) {
        // --- MOT COMPLET ---
        // 2a. Valider le mot
        let isWordCorrect = true;
        for (let i = 0; i < currentData.originalWord.length; i++) {
            if (currentData.selectedPinyins[i] !== currentData.pinyinAnswers[i]) {
                isWordCorrect = false;
                break;
            }
        }

        // 2b. Gérer la réponse
        if (isWordCorrect) {
            // --- MOT CORRECT ---
            currentData.status = 'correct';
            currentData.element.classList.remove('current-blank');
            currentData.element.classList.add('filled-blank-correct');
            currentData.element.innerHTML = currentData.originalWord; // Afficher le mot chinois
            currentData.element.classList.remove('blank-with-hint');

            // 2c. Trouver le prochain mot
            let nextBlankIndex = currentBlankIndex + 1;
            while (nextBlankIndex < fillBlanksData.length && fillBlanksData[nextBlankIndex].status !== 'pending') {
                nextBlankIndex++;
            }

            if (nextBlankIndex < fillBlanksData.length) {
                focusBlank(nextBlankIndex); // Passer au mot suivant
            } else {
                // --- PHRASE COMPLÈTE ---
                document.getElementById('pinyin-mcq-options').innerHTML = ''; // Vider les options
                const allWordsCorrect = fillBlanksData.every(data => data.status === 'correct');
                showResult(allWordsCorrect, allWordsCorrect ? "Phrase complétée !" : "Phrase complétée (avec des erreurs).");
                
                setTimeout(() => {
                    if (currentSentenceIndex < sentences.length - 1) {
                        goToSentence(1);
                    } else {
                        showGameResults(); // Fin du jeu
                    }
                }, 2000);
            }
        } else {
            // --- MOT INCORRECT ---
            currentData.status = 'incorrect'; // Statut temporaire
            currentData.element.classList.remove('current-blank');
            currentData.element.classList.add('filled-blank-incorrect'); // Appliquer le style rouge (modifié)
            
            // Afficher le mot chinois (incorrect) pour voir l'erreur
            currentData.element.innerHTML = currentData.originalWord;
            currentData.element.classList.remove('blank-with-hint');

            // Vider les options QCM pour montrer l'erreur
            document.getElementById('pinyin-mcq-options').innerHTML = ''; 

            // 2d. Réinitialiser le mot après un délai
            setTimeout(() => {
                currentData.element.classList.remove('filled-blank-incorrect'); // Retirer le rouge
                
                // Ré-afficher l'indice (les caractères chinois)
                const showPinyinHint = document.getElementById('showPinyinHintCheck').checked;
                if (showPinyinHint) {
                    currentData.element.innerHTML = ''; // Vider
                    currentData.originalWord.split('').forEach((char, charIdx) => {
                        const charSpan = document.createElement('span');
                        charSpan.textContent = char;
                        charSpan.dataset.charIndex = charIdx;
                        currentData.element.appendChild(charSpan);
                    });
                    currentData.element.classList.add('blank-with-hint');
                } else {
                    currentData.element.textContent = '_'.repeat(currentData.originalWord.length);
                }

                currentData.element.classList.add('current-blank'); // Remettre en focus
                currentData.status = 'pending'; // Prêt pour nouvel essai
                currentData.currentCharIndex = 0; // Recommencer au 1er caractère
                currentData.selectedPinyins = []; // Vider les sélections
                
                // Regénérer les options pour le 1er caractère
                generateAndDisplayPinyinOptions(); 
            }, 1500); // 1.5s pour voir l'erreur
        }
    } else {
        // --- PASSER AU CARACTÈRE SUIVANT DU MÊME MOT ---
        // Pas de validation, on affiche juste les options suivantes
        generateAndDisplayPinyinOptions();
    }
}


function showPinyinTonePopup(inputElement, vowel) {
    const popup = document.getElementById('pinyinTonePopup');
     if (!popup) return;

    const rect = inputElement.getBoundingClientRect();
    popup.style.top = `${rect.bottom + window.scrollY + 5}px`;
    popup.style.left = `${rect.left + window.scrollX}px`;

    const toneMarks = { a:['ā','á','ǎ','à','a'], e:['ē','é','ě','è','e'], i:['ī','í','ǐ','ì','i'], o:['ō','ó','ǒ','ò','o'], u:['ū','ú','ǔ','ù','u'], ü:['ǖ','ǘ','ǚ','ǜ','ü'], v:['ǖ','ǘ','ǚ','ǜ','ü'] };
    const baseVowel = vowel.toLowerCase();
    const marks = toneMarks[baseVowel];

    if(marks) {
        popup.innerHTML = `
            <span class="tone-option" data-tone="1">${marks[0]}<kbd>&</kbd></span>
            <span class="tone-option" data-tone="2">${marks[1]}<kbd>é</kbd></span>
            <span class="tone-option" data-tone="3">${marks[2]}<kbd>"</kbd></span>
            <span class="tone-option" data-tone="4">${marks[3]}<kbd>'</kbd></span>
            <span class="tone-option" data-tone="5">${marks[4]}<kbd>(</kbd></span>
            <span class="tone-option" data-tone="0">${marks[4]}<kbd>Space</kbd></span>
        `;
        popup.querySelectorAll('.tone-option').forEach(option => {
             option.onclick = null;
             option.onclick = () => {
                const tone = parseInt(option.dataset.tone);
                const pinyinWithTone = applyToneToVowel(pinyinInputBuffer, tone === 0 ? 5 : tone);
                 insertAtCursor(inputElement, pinyinWithTone);
                 hidePinyinTonePopup();
                 pinyinInputBuffer = '';
            };
        });
         popup.style.display = 'block';
    } else {
        insertAtCursor(inputElement, vowel);
        hidePinyinTonePopup();
        pinyinInputBuffer = '';
    }
}

function hidePinyinTonePopup() {
    const popup = document.getElementById('pinyinTonePopup');
    if (popup) popup.style.display = 'none';
}

function applyToneToVowel(vowel, toneNum) {
    const toneMarks = { a:['ā','á','ǎ','à','a'], e:['ē','é','ě','è','e'], i:['ī','í','ǐ','ì','i'], o:['ō','ó','ǒ','ò','o'], u:['ū','ú','ǔ','ù','u'], ü:['ǖ','ǘ','ǚ','ǜ','ü'], v:['ǖ','ǘ','ǚ','ǜ','ü'] };
    const baseVowel = vowel.toLowerCase();
    const marks = toneMarks[baseVowel];
    if (marks && toneNum >= 1 && toneNum <= 5) {
        return marks[toneNum - 1];
    }
    return vowel;
}

function insertAtCursor(inputElement, text) {
  const start = inputElement.selectionStart;
  const end = inputElement.selectionEnd;
  const originalValue = inputElement.value;
  inputElement.value = originalValue.substring(0, start) + text + originalValue.substring(end);
  inputElement.selectionStart = inputElement.selectionEnd = start + text.length;
   inputElement.dispatchEvent(new Event('input', { bubbles: true }));
   inputElement.focus();
}

function validateAnswer() {
  const resultDiv = document.getElementById('gameResult');
  let isCorrect = false;
  let allBlanksFilled = false;
  let activeInput = null; // Declare activeInput here for broader scope if needed, though not strictly necessary with const below

  switch (currentGameMode) {
    case 'reorder-drag':
      const userSentence = document.getElementById('userSentence');
      const userWords = Array.from(userSentence.querySelectorAll('.word-token'))
        .map(token => token.textContent);
      const userAnswer = userWords.join('');
      isCorrect = normalizeForComparison(userAnswer) === normalizeForComparison(originalSentence);
      break;

    case 'free-input':
      // DÉCLARATION CORRECTE avec 'const'
      const freeInputElement = document.getElementById('freeInput'); 
      // Vérifier si l'élément existe avant de l'utiliser
      if (freeInputElement) {
          const userAnswerFree = freeInputElement.value.trim();
          freeInputElement.blur(); // <-- CLAVIER FERMÉ
          isCorrect = normalizeForComparison(userAnswerFree) === normalizeForComparison(originalSentence);
      } else {
          console.error("Input element #freeInput not found!");
          isCorrect = false; // Marquer comme incorrect si l'input n'est pas trouvé
      }
      break;

    case 'fill-blanks-char':
    case 'fill-blanks-pinyin':
      const isPinyin = currentGameMode === 'fill-blanks-pinyin';
      const inputElId = isPinyin ? 'blanks-input-pinyin' : 'blanks-input-char';
      const inputEl = document.getElementById(inputElId);
      
      // Validate the current blank if there's input
      if(inputEl && inputEl.value.trim() !== "") {
          validateBlank(isPinyin); // This function now handles .blur() internally
      }
      
      // Check if all blanks are filled *after* potential validation
      allBlanksFilled = fillBlanksData.every(data => data.status === 'correct' || data.status === 'incorrect');
      isCorrect = fillBlanksData.every(data => data.status === 'correct');

      // If not all blanks are filled yet, we don't proceed to show final result or navigate
      if (!allBlanksFilled) {
           // We might still want to show a temporary result from validateBlank,
           // but the overall sentence result isn't ready.
           // The return here prevents showResult below from being called prematurely.
           return; 
      }
      // If all blanks *are* filled, isCorrect holds the final sentence correctness,
      // and we proceed to showResult below.
      break;

    case 'live-typing':
    case 'time-attack':
      // Validation for these modes is handled within their specific keydown listeners (initLiveTypingMode)
      // This function shouldn't be called directly for them via the validate button.
      return; 

  } // End switch

  // Show the result (unless handled internally like in fill-blanks before completion)
  showResult(isCorrect, isCorrect ? '✅ Correct !' : '❌ Incorrect. Essayez encore !');

  // Handle navigation or retry based on correctness
  if (isCorrect && !currentGameMode.startsWith('fill-blanks')) {
    // Correct answer for reorder or free-input: move to next or finish
    setTimeout(() => {
      if (currentSentenceIndex < sentences.length - 1) {
        goToSentence(1);
      } else {
        showGameResults();
      }
    }, 2000);
  } else if (!isCorrect && currentGameMode === 'reorder-drag') {
    // Incorrect reorder: reset the current sentence
    setTimeout(() => {
      initReorderMode(); // Reset words
      if(resultDiv) resultDiv.style.display = 'none'; // Hide result message
    }, 3000);
  } else if (!isCorrect && currentGameMode === 'free-input') {
    // Incorrect free-input: just hide the message, keep user input
    setTimeout(() => {
      if(resultDiv) resultDiv.style.display = 'none'; // Hide result message
      // Optionally re-focus the input:
      // const freeInputForFocus = document.getElementById('freeInput');
      // if (freeInputForFocus) freeInputForFocus.focus();
    }, 3000);
  } else if (isCorrect && currentGameMode.startsWith('fill-blanks')) {
    // Correct fill-blanks (all filled): Auto-next is handled within validateBlank's last step
    // No action needed here.
  } else if (!isCorrect && currentGameMode.startsWith('fill-blanks')) {
    // Incorrect fill-blanks (all filled but some wrong): Focus first error
    setTimeout(() => {
      if(resultDiv) resultDiv.style.display = 'none'; // Hide result message
      const firstErrorIndex = fillBlanksData.findIndex(d => d.status === 'incorrect');
      if(firstErrorIndex !== -1) {
          focusBlank(firstErrorIndex); // Re-focus the first incorrect blank
      }
    }, 3000);
  }
}

function showGameResults() {
    stopGameTimer();
    alert("Jeu terminé ! Scores et stats à afficher ici.");
}

function showResult(success, message) {
    const resultDiv = document.getElementById('gameResult');
    if(!resultDiv) return;


    resultDiv.className = success ? 'game-result success' : 'game-result error';
    resultDiv.textContent = message;
    resultDiv.style.display = 'block';
}

function giveHint() {
    if (currentGameMode === 'reorder-drag') {

        const availableWords = document.getElementById('availableWords');
        const userSentence = document.getElementById('userSentence');

        // *** MODIFICATION 1: Utiliser currentSentenceTokens et inclure la ponctuation (sauf espaces) ***
        const wordsAndPunc = currentSentenceTokens
            .filter(t => (t.type === 'word' || t.type === 'punc') && !/\s/.test(t.text))
            .map(t => t.text);

        const userTokens = Array.from(userSentence.querySelectorAll('.word-token'));
        const userWords = userTokens.map(t => t.textContent);

        let needsReset = false;

        if (userWords.length !== hintsRevealed) {
            needsReset = true;
        } else {
            for (let i = 0; i < hintsRevealed; i++) {
                // *** MODIFICATION 2: Comparer avec wordsAndPunc ***
                if (userWords[i] !== wordsAndPunc[i]) {
                    needsReset = true;
                    break;
                }
            }
        }

        if (needsReset) {
            userTokens.forEach(token => {
                availableWords.appendChild(token);
            });
            hintsRevealed = 0;
        }

        // *** MODIFICATION 3: Comparer avec wordsAndPunc.length ***
        if (hintsRevealed >= wordsAndPunc.length) return;

        const availableTokens = Array.from(availableWords.querySelectorAll('.word-token'));
        // *** MODIFICATION 4: Obtenir le prochain token (mot ou ponctuation) ***
        const nextToken = wordsAndPunc[hintsRevealed];

        // *** MODIFICATION 5: Trouver le token (y compris ponctuation) ***
        // Recherche simple, peut échouer si le même token est présent plusieurs fois (ex: "de de")
        // Une logique plus robuste impliquerait de compter les tokens déjà utilisés.
        // Pour ce cas, nous utilisons find qui prend le *premier* disponible.
        const token = availableTokens.find(t => t.textContent === nextToken);

        if (token) {
            token.classList.add('hint-revealed');
            userSentence.appendChild(token);
            hintsRevealed++;

            setTimeout(() => {
            token.classList.remove('hint-revealed');
            }, 1000);
        }

    } else if (currentGameMode === 'free-input') {
        // *** MODIFICATION 6: Utiliser currentSentenceTokens et inclure la ponctuation (sauf espaces) ***
        const wordsAndPunc = currentSentenceTokens
            .filter(t => (t.type === 'word' || t.type === 'punc') && !/\s/.test(t.text))
            .map(t => t.text);

        // *** MODIFICATION 7: Comparer avec wordsAndPunc.length ***
        if (hintsRevealed >= wordsAndPunc.length) return;

        const freeInput = document.getElementById('freeInput');

        // *** MODIFICATION 8: Logique d'indice simplifiée et correcte (sans espaces) ***
        // On reconstruit simplement la phrase correcte jusqu'à l'indice 'hintsRevealed'
        hintsRevealed++; // Révéler le prochain token
        const correctTextSoFar = wordsAndPunc.slice(0, hintsRevealed).join(''); // Join sans espaces
        freeInput.value = correctTextSoFar;

        freeInput.focus();
        freeInput.selectionStart = freeInput.selectionEnd = freeInput.value.length;

    } else if (currentGameMode === 'fill-blanks-char' || currentGameMode === 'fill-blanks-pinyin') {
        if (currentBlankIndex < fillBlanksData.length) {
            const currentData = fillBlanksData[currentBlankIndex];
            if(currentData.status === 'pending') {
                const inputElId = currentGameMode === 'fill-blanks-pinyin' ? 'blanks-input-pinyin' : 'blanks-input-char';
                document.getElementById(inputElId).value = currentGameMode === 'fill-blanks-pinyin' ? currentData.pinyinAnswer : currentData.originalWord;
                 validateBlank(currentGameMode === 'fill-blanks-pinyin');
            }
        }
    }
}

function goToSentence(direction) {
    const newIndex = currentSentenceIndex + direction;
    if (newIndex < 0 || newIndex >= sentences.length) {
        return;
    }
    currentSentenceIndex = newIndex;
    loadSentence();
}

function quitGame() {
    document.getElementById('gamePage').classList.remove('active');
    document.getElementById('homePage').style.display = 'block';
    stopGameTimer();
}

function startGameTimer() {
    console.log("DEBUG: Attempting to start timer for mode:", currentGameMode); // Log 1
    stopGameTimer(); // Clear any previous timer

    const timerDisplay = document.getElementById('gameTimer');
    const statTimeDisplay = document.getElementById('statTime');

    if (!timerDisplay) {
        console.error("DEBUG: Timer display element #gameTimer not found!"); // Log Error
        return; // Exit if the main display is missing
    }

    if (currentGameMode === 'time-attack') {
        console.log("DEBUG: Setting up Time Attack countdown..."); // Log 2a
        // --- Existing Time Attack Countdown Logic ---
        const targetCPM = parseInt(document.getElementById('cpmAttackTarget').value, 10);
        const targetText = originalSentence.replace(/[,\s]/g, '');
        let targetSeconds = Math.ceil((targetText.length / targetCPM) * 60);
        if (targetSeconds < 5) targetSeconds = 5; // Minimum time

        let remainingSeconds = targetSeconds;
        console.log("DEBUG: Target seconds:", targetSeconds); // Log 3a

        const updateCountdownUI = () => {
            const minutes = Math.floor(remainingSeconds / 60).toString().padStart(2, '0');
            const seconds = (remainingSeconds % 60).toString().padStart(2, '0');
            const timeString = `${minutes}:${seconds}`;
            // console.log("DEBUG Time Attack Tick:", timeString); // Optionnel: Log every second
            timerDisplay.textContent = timeString;
            if (statTimeDisplay) statTimeDisplay.textContent = timeString;
        };

        updateCountdownUI(); // Initial display

        gameTimerInterval = setInterval(() => {
            console.log("DEBUG: Time Attack Interval Fired. Remaining:", remainingSeconds -1); // Log 4a
            remainingSeconds--;
            updateCountdownUI();

            if (remainingSeconds <= 0) {
                 console.log("DEBUG: Time Attack finished."); // Log 5a
                stopGameTimer();
                showResult(false, "Temps écoulé ! Perdu.");
                const inputEl = document.getElementById('time-attack-input');
                if (inputEl) inputEl.disabled = true;
            }
        }, 1000);
         console.log("DEBUG: Time Attack interval set with ID:", gameTimerInterval); // Log 6a

    } else {
        console.log("DEBUG: Setting up standard chronometer..."); // Log 2b
        // --- Standard Chronometer Logic for other modes ---
        gameStartTime = Date.now();

        if (statTimeDisplay) statTimeDisplay.textContent = '0s'; // Clear stats timer display

        const updateChronoUI = () => {
             const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
             const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
             const seconds = (elapsed % 60).toString().padStart(2, '0');
             const timeString = `${minutes}:${seconds}`;
             // console.log("DEBUG Chrono Tick:", timeString); // Optionnel: Log every second
             timerDisplay.textContent = timeString;
        };

        updateChronoUI(); // Initial display (00:00)

        gameTimerInterval = setInterval(() => {
            console.log("DEBUG: Chrono Interval Fired."); // Log 4b
            updateChronoUI();
        }, 1000);
        console.log("DEBUG: Chrono interval set with ID:", gameTimerInterval); // Log 6b
    }
}

function stopGameTimer() {
    if (gameTimerInterval) {
        clearInterval(gameTimerInterval);
        gameTimerInterval = null;
    }
}

function checkAndResizeFonts() {
  if (window.innerWidth > 600) return;

  const elementsToResize = [
    document.getElementById('translationHint'),
    document.getElementById('blanks-display-text-char'),
    document.getElementById('blanks-display-text-pinyin'),
    document.getElementById('typing-target-text'),
    document.getElementById('time-attack-target-text'),
    document.getElementById('free-input-target-text')
  ];

  const translationThreshold = 90;
  const gameTextThreshold = 130;

  elementsToResize.forEach(el => {
    if (!el) return;
    el.classList.remove('shrink-text');
    const height = el.offsetHeight;
    let threshold = (el.id === 'translationHint') ? translationThreshold : gameTextThreshold;
    if (height > threshold) {
      el.classList.add('shrink-text');
    }
  });
}

function resetLiveStats() {
    document.getElementById('statErrors').textContent = '0';
    document.getElementById('statAccuracy').textContent = '0%';
    document.getElementById('statChars').textContent = '0/0';
    document.getElementById('statTime').textContent = '0s';
}

function updateGameOptionsUI() {
    const selectedMode = document.getElementById('gameMode').value;

    // Cacher toutes les options de mode spécifiques
    document.querySelectorAll('.game-mode-option').forEach(el => el.style.display = 'none');

    // Gérer la visibilité de l'ancienne case à cocher traduction
    const translationCheckContainer = document.getElementById('showTranslationCheckContainer');
    if (translationCheckContainer) {
        translationCheckContainer.style.display = (selectedMode === 'free-input') ? 'none' : 'block';
    }

    // Afficher les options spécifiques au mode sélectionné
    switch (selectedMode) {
        case 'free-input':
            const freeInputOpts = document.getElementById('freeInputOptions');
            if (freeInputOpts) freeInputOpts.style.display = 'block';
            break;
        case 'time-attack':
            const timeAttackOpts = document.getElementById('timeAttackOptions');
            if (timeAttackOpts) timeAttackOpts.style.display = 'block';
            break;
        case 'fill-blanks-char':
            // Pour les caractères, afficher seulement les options de niveaux/indice
            const fillBlanksOptsChar = document.getElementById('fillBlanksOptions');
            if (fillBlanksOptsChar) fillBlanksOptsChar.style.display = 'block';
            break;
        case 'fill-blanks-pinyin':
            // Pour le pinyin, afficher la nouvelle section ET l'ancienne
            const pinyinTypeOpts = document.getElementById('pinyinInputTypeOptions');
            const fillBlanksOptsPinyin = document.getElementById('fillBlanksOptions');
            if (pinyinTypeOpts) pinyinTypeOpts.style.display = 'block';
            if (fillBlanksOptsPinyin) fillBlanksOptsPinyin.style.display = 'block';
            break;
        // Ajoutez d'autres cas si nécessaire pour d'autres modes
    }
}

// =====================================================
// READ MODE FUNCTIONS
// =====================================================
function detectSentenceBoundaries() {
  readSentenceBoundaries = []; // Réinitialiser

  // En mode Super Zen, une seule "phrase" (le contenu affiché)
  if (readSuperZen) {
    readSentenceBoundaries.push({
      chineseStart: 0,
      chineseEnd: readChars.length,
      translationStart: 0,
      translationEnd: readTranslationChars.length,
      chineseLength: readChars.length,
      translationLength: readTranslationChars.length,
    });
    console.log('📝 Phrase Super Zen détectée:', readSentenceBoundaries);
    return;
  }

  // --- Détection normale ---
  const chinesePunct = new Set(['。', '！', '？']);
  const translationPunct = new Set(['.', '!', '?']); // Ponctuations de fin de phrase en français

  let currentChineseStart = 0;
  let currentTranslationStart = 0;
  let sentenceIndex = 0;

  // Parcourir les caractères chinois pour trouver les fins de phrases
  for (let i = 0; i < readChars.length; i++) {
    const char = readChars[i];
    const text = char.textContent;

    // Si c'est une ponctuation de fin OU si c'est le tout dernier caractère chinois
    if (chinesePunct.has(text) || i === readChars.length - 1) {
      const chineseEnd = i + 1; // Inclure la ponctuation ou le dernier caractère
      const chineseLength = chineseEnd - currentChineseStart;

      // Trouver la fin de phrase correspondante dans la traduction
      // On cherche la ponctuation de fin après la position proportionnelle
      let translationEnd = currentTranslationStart; // Valeur par défaut
      let translationLength = 0;
      if (readTranslationChars.length > 0) {
           // Position approximative attendue dans la traduction
           const expectedRatio = chineseEnd / readChars.length;
           const expectedTranslationPos = Math.floor(expectedRatio * readTranslationChars.length);

           // Chercher la prochaine ponctuation de fin *après* la position attendue (ou la fin si pas trouvée)
           let foundPunct = false;
           for(let j = Math.max(currentTranslationStart, expectedTranslationPos - 5); j < readTranslationChars.length; j++) { // Cherche un peu avant aussi
               if(translationPunct.has(readTranslationChars[j].textContent)) {
                   translationEnd = j + 1;
                   foundPunct = true;
                   break;
               }
           }
           // Si pas de ponctuation trouvée avant la fin, ou si c'est la dernière phrase chinoise
           if (!foundPunct || sentenceIndex === splitSentences(document.getElementById('inputZh').value).length -1) {
                translationEnd = readTranslationChars.length; // Prendre tout ce qui reste
           }
           // Éviter que translationEnd soit avant translationStart (cas étranges)
           translationEnd = Math.max(translationEnd, currentTranslationStart);
           translationLength = translationEnd - currentTranslationStart;
      }


      readSentenceBoundaries.push({
        chineseStart: currentChineseStart,
        chineseEnd: chineseEnd,
        translationStart: currentTranslationStart,
        translationEnd: translationEnd,
        chineseLength: chineseLength,
        translationLength: translationLength,
      });

      // Mettre à jour les points de départ pour la prochaine phrase
      currentChineseStart = chineseEnd;
      currentTranslationStart = translationEnd;
      sentenceIndex++;

       // Si on a consommé toute la traduction, on arrête
       if(currentTranslationStart >= readTranslationChars.length) break;
    }
  }

  // S'il ne reste aucun caractère chinois mais qu'il reste de la traduction (rare),
  // créer une dernière "phrase" pour la traduction restante.
    if(currentChineseStart >= readChars.length && currentTranslationStart < readTranslationChars.length) {
        readSentenceBoundaries.push({
            chineseStart: currentChineseStart,
            chineseEnd: readChars.length,
            translationStart: currentTranslationStart,
            translationEnd: readTranslationChars.length,
            chineseLength: 0,
            translationLength: readTranslationChars.length - currentTranslationStart
        });
    }

  console.log('📝 Phrases détectées:', readSentenceBoundaries.length, readSentenceBoundaries);
}

function startReadMode() {
  // === CORRECTIF: S'assurer que readPage n'est pas dans gamePage ===
  const readPageEl = document.getElementById('readPage');
  if (readPageEl && readPageEl.parentElement.id === 'gamePage') {
    document.body.appendChild(readPageEl);
    console.log('🔧 Correctif: readPage repositionné hors de gamePage');
  }
  
  console.log('=== DÉBUT startReadMode ===');
  
  // === 1. VALIDATIONS INITIALES ===
  const zhText = document.getElementById('inputZh').value.trim();
  console.log('Texte chinois:', zhText ? zhText.substring(0, 50) + '...' : 'VIDE');
  
  if (!zhText) {
    alert('⚠️ Veuillez entrer un texte chinois.');
    return;
  }
  
  console.log('Dict chargé:', dict && dict.wordSet ? dict.wordSet.size + ' mots' : 'NON');
  console.log('LevelMap chargé:', levelMap ? levelMap.size + ' mots' : 'NON');
  
  if (!dict || dict.wordSet.size === 0) {
    alert('⚠️ Veuillez charger un dictionnaire CC-CEDICT.');
    return;
  }
  if (!levelMap || levelMap.size === 0) {
    alert('⚠️ Veuillez charger une liste HSK/Fréquence.');
  }

  // === 2. RÉCUPÉRATION DES PARAMÈTRES (AVANT LE RENDU) ===
  console.log('Récupération des paramètres...');
  
  // Mode d'affichage
  readDisplayMode = document.getElementById('displayMode').value;
  console.log('Mode affichage:', readDisplayMode);
  
  // Taille de police
  readFontSize = parseInt(document.getElementById('fontSize').value);
  console.log('Taille police:', readFontSize);
  
  // Vitesse (CPM)
  readCPM = parseInt(document.getElementById('cpm').value);
  console.log('CPM:', readCPM);
  
  // Catégorie (HSK ou Fréquence)
  const activeCategory = document.querySelector('#readCategorySelector .category-btn.active');
  readCategory = activeCategory ? activeCategory.getAttribute('data-category') : 'hsk';
  console.log('Catégorie:', readCategory);
  
  // Niveaux sélectionnés
  readSelectedLevels = new Set();
  const selector = readCategory === 'hsk' ? '#hskSelector' : '#freqSelector';
  document.querySelectorAll(`${selector} .hsk-selector-btn.active`).forEach(btn => {
    readSelectedLevels.add(Number(btn.getAttribute('data-level')));
  });
  console.log('Niveaux sélectionnés:', Array.from(readSelectedLevels));

  // === 3. TRAITEMENT DU TEXTE ===
  console.log('Traitement du texte...');
  const normalizedText = normalizeChineseText(zhText);
  readSentences = splitSentences(normalizedText);
  console.log('Phrases détectées:', readSentences.length);

  // Traitement de la traduction
  const trText = document.getElementById('inputTr').value.trim();
  if (trText) {
    readTranslations = trText.split(/\s*\/\/\s*/).flatMap(part => {
      return part.split(/(?<=[.!?])\s+/g);
    }).filter(Boolean).map(s => s.trim());
  } else {
    readTranslations = [];
  }
  console.log('Traductions:', readTranslations.length);

  // === 4. TRANSITION VERS LA PAGE DE LECTURE ===
  console.log('Transition vers page lecture...');
  document.getElementById('homePage').style.display = 'none';
  document.getElementById('readPage').classList.add('active');
  
  // Afficher la taille de police dans l'UI
  document.getElementById('readFontSize').textContent = readFontSize + 'px';

  // === 5. RÉINITIALISATION DES ÉTATS ===
  console.log('Réinitialisation des états...');
  readCurrentSentence = 0;
  readSuperZen = false;
  readSuperZenType = false;
  readFocusMode = false;
  isFlipped = false;
  
  // Retirer la classe 'active' du bouton Focus
  const focusBtn = document.getElementById('readFocusToggle');
  if (focusBtn) focusBtn.classList.remove('active');
  
  // Retirer la classe 'super-zen' de la page
  const page = document.getElementById('readPage');
  page.classList.remove('super-zen');

  // === 6. RENDU DU CONTENU (MAINTENANT LES VARIABLES SONT PRÊTES) ===
  console.log('Appel de renderReadText()...');
  try {
    renderReadText(); // Crée readChars et readTranslationChars
    console.log('renderReadText() OK - Chars:', readChars.length);
  } catch (error) {
    console.error('ERREUR dans renderReadText():', error);
    alert('Erreur lors du rendu du texte : ' + error.message);
    return;
  }
  
  // === 7. DÉTECTION DES PHRASES ET CONFIGURATION ===
  console.log('Configuration de l\'interface...');
  try {
    detectSentenceBoundaries(); // Nécessite que readChars existe
    createReadFilters(); // Crée les chips de filtre HSK/Freq
    updateReadDifficulty(); // Calcule et affiche la difficulté
    updateReadModeButton(); // Met à jour le bouton "Instant/Frappe"
    updateFocusButtonState(); // Active/désactive le bouton Focus
    console.log('Configuration OK');
  } catch (error) {
    console.error('ERREUR dans la configuration:', error);
  }

  // === 8. GESTION DU BOUTON FLIP (MOBILE) ===
  const isMobile = window.matchMedia('(max-width: 900px)').matches;
  const flipBtn = document.getElementById('readFlipBtn');
  const container = document.getElementById('readTextContainer');
  
  if (flipBtn && container) {
    if (isMobile && readTranslations.length > 0 && container.classList.contains('has-flip')) {
      flipBtn.style.display = 'flex';
	  setTimeout(adjustFlipHeight, 100);
    } else {
      flipBtn.style.display = 'none';
    }
  }

  // === 9. LANCEMENT DE L'ANIMATION (SI MODE FRAPPE) ===
  if (readDisplayMode === 'type') {
    console.log('Lancement animation frappe...');
    startTypeAnimation();
  } else {
    console.log('Mode instantané - pas d\'animation');
    stopTypeAnimation();
  }
  
  console.log('=== FIN startReadMode ===');
}

function createReadFilters() {
  const legend = document.getElementById('readFilterLegend');
  const existingChips = legend.querySelectorAll('.read-legend-chip:not(.read-legend-focus)');
  existingChips.forEach(chip => chip.remove());

  const focusBtn = document.getElementById('readFocusToggle');

  if (readCategory === 'hsk') {
    for (let i = 1; i <= 7; i++) {
      const chip = document.createElement('button');
      chip.className = `read-legend-chip level-${i === 7 ? '79' : i}`;
      chip.setAttribute('data-level', i);
      chip.textContent = i === 7 ? 'HSK 7-9' : `HSK ${i}`;
      if (readSelectedLevels.has(i)) {
        chip.classList.add('active');
      }
      chip.addEventListener('click', () => toggleReadFilter(i));

      if (focusBtn) {
        legend.insertBefore(chip, focusBtn);
      } else {
        legend.appendChild(chip);
      }
    }
  } else {
    const freqLabels = ['0-1k', '1-2k', '2-3k', '3-4k', '4-5k', '5-7k', '7-10k', '10-15k', '15-40k'];
    for (let i = 1; i <= 9; i++) {
      const chip = document.createElement('button');
      chip.className = `read-legend-chip freq-${i}`;
      chip.setAttribute('data-level', i);
      chip.textContent = freqLabels[i - 1];
      if (readSelectedLevels.has(i)) {
        chip.classList.add('active');
      }
      chip.addEventListener('click', () => toggleReadFilter(i));

      if (focusBtn) {
        legend.insertBefore(chip, focusBtn);
      } else {
        legend.appendChild(chip);
      }
    }
  }
}

function toggleReadFilter(level) {
  if (readSelectedLevels.has(level)) {
    readSelectedLevels.delete(level);
  } else {
    readSelectedLevels.add(level);
  }

  const chip = document.querySelector(`.read-legend-chip[data-level="${level}"]`);
  if (chip) {
    chip.classList.toggle('active');
  }

  applyReadColors();
}

function applyReadColors() {
  const chars = document.querySelectorAll('.read-char');
  const filteredWords = new Set();
  let lastVisibleWord = null;

  // Supprimer d'abord tous les espaces focus existants
  document.querySelectorAll('.focus-space').forEach(space => space.remove());

  chars.forEach(char => {
    const word = char.getAttribute('data-word');

    // Réinitialiser les classes de couleur
    char.className = 'read-char'; // Garde la classe de base

    if (!word) { // Gérer la ponctuation et les espaces
      if (readFocusMode) {
        char.style.display = 'none';
        char.style.visibility = 'hidden';
      } else {
        char.style.display = 'inline';
        char.style.visibility = 'visible';
      }
      return;
    }

    // C'est un caractère de mot
    const lvl = getLevel(word, readCategory);
    const shouldHighlight = lvl > 0 && readSelectedLevels.has(lvl);

    if (readFocusMode) {
      if (shouldHighlight) {
        char.style.display = 'inline';
        char.style.visibility = 'visible';
        char.classList.add(levelClassFor(word, readCategory));
        filteredWords.add(word);

        // Ajouter un espace après le mot COMPLET s'il est différent du précédent
        const nextChar = char.nextElementSibling;
        const isLastCharOfWord = !nextChar || nextChar.getAttribute('data-word') !== word;

        if (isLastCharOfWord && word !== lastVisibleWord) {
           lastVisibleWord = word; // Mettre à jour après avoir traité le dernier caractère
           // Insérer l'espace APRES le caractère courant
           const space = document.createElement('span');
           space.textContent = ' ';
           space.className = 'read-char focus-space'; // Marquer l'espace
           space.style.display = 'inline';
           space.style.visibility = 'visible';
           char.parentNode.insertBefore(space, char.nextSibling);
        } else if (!isLastCharOfWord) {
             // Si on est au milieu d'un mot, s'assurer que lastVisibleWord est bien le mot courant
             lastVisibleWord = word;
        }

      } else {
        char.style.display = 'none';
        char.style.visibility = 'hidden';
      }
    } else { // Mode normal (pas Focus)
      char.style.display = 'inline';
      char.style.visibility = 'visible';
      lastVisibleWord = null; // Réinitialiser pour le mode normal

      if (shouldHighlight) {
        char.classList.add(levelClassFor(word, readCategory));
      }
    }
  });

  if (readFocusMode && filteredWords.size > 0) {
    const wordsList = Array.from(filteredWords).join(' ');
    navigator.clipboard.writeText(wordsList).then(() => {
      console.log('📋 Copié:', filteredWords.size, 'mots.');
    }).catch(err => {
      console.log('⚠️ Erreur de copie:', err);
    });
  }
}

function updateReadDifficulty() {
  // console.log("Updating difficulty..."); 

  // Get elements first
  const gaugeContainer = document.getElementById('rc-difficulty-gauge'); // Container (jauge desktop ET chip mobile)
  const textEl = document.getElementById('readDifficultyText'); // Texte difficulté (commun)
  const desktopFill = document.getElementById('readDifficultyFill'); // Remplissage barre desktop
  const desktopLabel = gaugeContainer ? gaugeContainer.querySelector('.difficulty-label') : null; // Label desktop

  // --- Handle case with no sentences ---
  if (!readSentences || readSentences.length === 0) {
      if (textEl) { textEl.textContent = '—'; textEl.style.color = 'var(--muted)'; }
      if (gaugeContainer) { gaugeContainer.style.borderColor = 'var(--muted)'; } // Bordure chip mobile
      if (desktopFill) { desktopFill.style.width = `0%`; desktopFill.style.background = 'var(--muted)';}
      return;
  }

  // --- Prepare tokenSents ---
  const tokenSents = readSentences.map(s =>
      segmentText(s, dict.wordSet, dict.maxLen)
      .filter(t => t.type === 'word' || t.type === 'punc')
  );

  // --- Handle case with no tokens ---
  if (!tokenSents || tokenSents.length === 0 || tokenSents.flat().length === 0) {
       if (textEl) { textEl.textContent = '—'; textEl.style.color = 'var(--muted)'; }
       if (gaugeContainer) { gaugeContainer.style.borderColor = 'var(--muted)'; } // Bordure chip mobile
       if (desktopFill) { desktopFill.style.width = `0%`; desktopFill.style.background = 'var(--muted)';}
      return;
  }

  // --- Appeler calculateDifficulty ---
  const diff = calculateDifficulty(tokenSents, readCategory);
  // console.log("Calculated diff object:", diff); 

  // --- Afficher le résultat ---
  if (diff && gaugeContainer && textEl) { 

    // --- Mettre à jour le texte (commun) ---
    textEl.textContent = diff.label;

    // --- Déterminer si on est en affichage mobile (chip) ou desktop (gauge) ---
    // On vérifie si le label de la jauge est visible (il est caché sur mobile)
    const isMobileChip = desktopLabel && window.getComputedStyle(desktopLabel).display === 'none';

    if (isMobileChip) {
        // --- Mettre à jour le CHIP MOBILE ---
        textEl.style.color = diff.color; // Couleur dynamique pour le texte du chip
        gaugeContainer.style.borderColor = diff.color; // Couleur dynamique pour la bordure du chip
    } else {
        // --- Mettre à jour la JAUGE DESKTOP ---
        textEl.style.color = 'var(--fg)'; // Couleur standard pour le texte de la jauge
        gaugeContainer.style.borderColor = 'var(--border)'; // Bordure standard pour la jauge
        if (desktopFill) { // Mettre à jour le remplissage
            desktopFill.style.width = `${diff.scorePct}%`;
            desktopFill.style.background = diff.color;
        }
    }

  } else {
      // --- Gérer l'erreur d'affichage ---
      console.error("updateReadDifficulty: Could not update display.", {diff, gaugeContainer, textEl, desktopFill});
       // Reset Mobile Chip & Desktop Text on error
       if(textEl) { textEl.textContent = 'Erreur'; textEl.style.color = 'var(--muted)'; }
       if(gaugeContainer) gaugeContainer.style.borderColor = 'var(--muted)'; 
       // Reset Desktop Gauge fill on error
       if (desktopFill) { desktopFill.style.width = `0%`; desktopFill.style.background = 'var(--muted)';}
  }
}

function renderReadText() {
  const container = document.getElementById('readTextContainer');
  let readTextEl = document.getElementById('readText');
  let readTranslationEl = document.getElementById('readTranslation');
  const isMobile = window.matchMedia('(max-width: 900px)').matches;

  readChars = [];
  readTranslationChars = []; // Clear arrays
  container.classList.remove('has-flip'); // Reset flip class

  // === VÉRIFICATION : S'assurer que readSentences existe ===
  if (!readSentences || readSentences.length === 0) {
    console.error("renderReadText: readSentences est vide ou non défini !");
    container.innerHTML = '<div class="read-text">Erreur : Aucune phrase à afficher</div>';
    return;
  }

  // === VÉRIFICATION : S'assurer que dict existe ===
  if (!dict || !dict.wordSet || dict.wordSet.size === 0) {
    console.error("renderReadText: Dictionnaire non chargé !");
    container.innerHTML = '<div class="read-text">Erreur : Dictionnaire non chargé</div>';
    return;
  }

  // --- Reconstruction conditionnelle de l'HTML ---
  if (readSuperZen) {
    container.innerHTML = `
      <div class="read-text" id="readText"></div>
      <div class="read-translation" id="readTranslation"></div>
    `;
    readTextEl = document.getElementById('readText');
    readTranslationEl = document.getElementById('readTranslation');
    container.className = 'read-text-container';
    
    const sentence = readSentences[readCurrentSentence] || '';
    const tokens = segmentText(sentence, dict.wordSet, dict.maxLen);
    tokens.forEach(token => appendToken(token, readTextEl, readChars));
    
    if (readTranslations[readCurrentSentence]) {
        readTranslationEl.textContent = readTranslations[readCurrentSentence];
        readTranslationEl.style.display = 'block';
    } else {
        readTranslationEl.style.display = 'none';
    }
    
    const szProgress = document.getElementById('szProgress');
    if(szProgress) szProgress.textContent = `${readCurrentSentence + 1}/${readSentences.length}`;

  } else if (isMobile && readTranslations.length > 0) {
    container.innerHTML = `
      <div class="flip-container" id="flipContainer">
        <div class="flip-inner">
          <div class="flip-front read-text" id="readText"></div>
          <div class="flip-back read-translation" id="readTranslation"></div>
        </div>
      </div>
    `;
    readTextEl = document.getElementById('readText');
    readTranslationEl = document.getElementById('readTranslation');
    const flipContainer = document.getElementById('flipContainer');
    container.className = 'read-text-container has-flip';
    if(isFlipped && flipContainer) flipContainer.classList.add('flipped');
    
    readSentences.forEach((sentence, idx) => {
        const tokens = segmentText(sentence, dict.wordSet, dict.maxLen);
        tokens.forEach(token => appendToken(token, readTextEl, readChars));
        if (idx < readSentences.length - 1) appendToken({ text: ' ', type: 'punc' }, readTextEl, readChars);
    });
    
    readTranslations.forEach((tr) => {
        const p = document.createElement('p'); 
        p.textContent = tr; 
        p.style.marginBottom = '12px';
        readTranslationEl.appendChild(p);
    });

  } else { // Desktop or Mobile without translation
    container.innerHTML = `
      <div class="read-text" id="readText"></div>
      <div class="read-translation" id="readTranslation"></div>
    `;
    readTextEl = document.getElementById('readText');
    readTranslationEl = document.getElementById('readTranslation');
    container.className = 'read-text-container';
    
    readSentences.forEach((sentence, idx) => {
      const tokens = segmentText(sentence, dict.wordSet, dict.maxLen);
      tokens.forEach(token => appendToken(token, readTextEl, readChars));
      if (idx < readSentences.length - 1) appendToken({ text: ' ', type: 'punc' }, readTextEl, readChars);
    });
    
    if (readTranslations.length > 0) {
        readTranslations.forEach((tr) => {
            const p = document.createElement('p'); 
            p.textContent = tr; 
            p.style.marginBottom = '12px';
            readTranslationEl.appendChild(p);
        });
        readTranslationEl.style.display = 'block';
    } else {
        readTranslationEl.style.display = 'none';
    }
  }

  // --- Application de la taille de police ---
  if (readTextEl) readTextEl.style.fontSize = readFontSize + 'px';
  if (readTranslationEl) readTranslationEl.style.fontSize = (readFontSize * 0.8) + 'px';

  // --- Préparation pour la frappe SEULEMENT si nécessaire ---
  if (readDisplayMode === 'type' || readSuperZenType) {
      prepareTranslationForTyping();
      readChars.forEach(char => char.style.visibility = 'hidden');
      readTranslationChars.forEach(char => char.style.visibility = 'hidden');
      readCurrentIndex = 0;
      readTranslationCurrentIndex = 0;
  } else {
      readChars.forEach(char => char.style.visibility = 'visible');
      if(readTranslationEl) {
           readTranslationEl.style.visibility = 'visible';
           Array.from(readTranslationEl.querySelectorAll('span')).forEach(span => span.style.visibility = 'visible');
      }
  }

  applyReadColors(); // Appliquer les couleurs HSK/Freq toujours à la fin
}


function updateFocusButtonState() {
    const focusBtn = document.getElementById('readFocusToggle');
    if (focusBtn) {
        // Désactiver si PAS en mode SuperZen ET SI en mode Frappe
        focusBtn.disabled = (!readSuperZen && readDisplayMode === 'type');

        // Optionnel : Retirer la classe 'active' si désactivé
        if (focusBtn.disabled) {
            focusBtn.classList.remove('active');
            // S'assurer que readFocusMode est false si le bouton est désactivé
            // readFocusMode = false; // Décommenter si le focus doit être forcé off
        }
    }
}

// Helper pour renderReadText
// Helper pour renderReadText: Ajoute un token (mot ou ponctuation) au DOM
function appendToken(token, parentElement, charArray) {
  // --- Vérifications initiales ---
  if (!token || !parentElement || !charArray) {
    console.error("Erreur dans appendToken: Argument manquant.", { token, parentElement, charArray });
    return; // Ne rien faire si les arguments sont invalides
  }

  const word = token.text; // Le texte du token (peut être un mot, un caractère, ou de la ponctuation)

  // --- Cas 1: Ponctuation ou Espace ---
  if (token.type === 'punc' || /\s/.test(word)) {
    const span = document.createElement('span');
    span.textContent = word;
    span.className = 'read-char'; // Classe de base pour tous les spans
    // Note: Pas d'écouteur de clic sur la ponctuation/espaces
    parentElement.appendChild(span);
    charArray.push(span); // Ajouter au tableau global des caractères chinois
  }
  // --- Cas 2: Mot Chinois ---
  else if (token.type === 'word' && word.length > 0) {
    // Sécurité : vérifier que readCategory est défini avant de l'utiliser
    const category = readCategory || 'hsk'; // Utilise 'hsk' par défaut si indéfini
    const lvl = getLevel(word, category); // Récupère le niveau HSK/Freq du mot complet

    // Itérer sur chaque caractère du mot pour créer un span individuel
    for (let i = 0; i < word.length; i++) {
      const char = word[i]; // Caractère individuel
      const span = document.createElement('span');
      span.textContent = char;
      span.className = 'read-char'; // Classe de base
      span.setAttribute('data-word', word); // Stocke le mot complet sur chaque caractère

      // Ajouter la classe de couleur HSK/Freq si applicable
      // Sécurité : vérifier que readSelectedLevels existe
      if (lvl > 0 && readSelectedLevels && readSelectedLevels.has(lvl)) {
        const levelClassName = levelClassFor(word, category); // Obtient la classe (e.g., 'hsk1', 'freq3')
        if (levelClassName) {
          span.classList.add(levelClassName);
        }
      }

      // --- AJOUTER L'ÉCOUTEUR DE CLIC ICI ---
      // C'est cette ligne qui permet d'ouvrir le modal
      span.addEventListener('click', () => {
        console.log(`Clic détecté sur '${char}' du mot '${word}'`); // Log pour débogage
        openDictModal(word); // Appelle la fonction pour ouvrir le modal avec le mot complet
      });

      // Ajouter le span au parent et au tableau global
      parentElement.appendChild(span);
      charArray.push(span);
    }
  } else {
    // Cas imprévu (e.g., token.type inconnu ou mot vide)
    console.warn("appendToken: Type de token inconnu ou mot vide ignoré:", token);
  }
}


function openDictModal(word) {
  console.log('🔍 openDictModal appelée avec:', word);
  console.log('📦 État du modal:', document.getElementById('dictModal'));
  console.log('Fonction openDictModal appelée avec le mot:', word); // Log pour vérifier l'appel

  // --- 1. Récupération des éléments du Modal ---
  const modal = document.getElementById('dictModal');
  const content = modal ? modal.querySelector('.dict-modal-content') : null;
  const charEl = document.getElementById('dictChar');
  const pinyinEl = document.getElementById('dictPinyin');
  const defsEl = document.getElementById('dictDefinitions');
  const closeBtn = document.getElementById('closeDictModal'); // Récupérer le bouton fermer

  console.log('Éléments du modal trouvés:', { modal, content, charEl, pinyinEl, defsEl }); // Log pour vérifier les éléments

  // Vérification essentielle : si les éléments n'existent pas, on ne peut pas continuer.
  if (!modal || !content || !charEl || !pinyinEl || !defsEl) {
    console.error("Erreur critique: Un ou plusieurs éléments du modal sont manquants dans le HTML ! Vérifiez les IDs: dictModal, dictChar, dictPinyin, dictDefinitions.");
    return; // Arrêter la fonction ici
  }

  // --- 2. Recherche de l'entrée dans le dictionnaire ---
  const entry = dict.entries.get(word);
  console.log('Entrée trouvée dans le dictionnaire:', entry); // Log pour vérifier l'entrée

  // --- 3. Remplissage des informations de base (Caractère, Pinyin, Définitions) ---
  charEl.textContent = word; // Toujours afficher le mot cliqué

  if (!entry) {
    // Cas où le mot n'est pas trouvé dans le dictionnaire
    pinyinEl.textContent = '—'; // Indicateur pour "non trouvé"
    defsEl.innerHTML = '<div class="dict-def">Aucune définition trouvée</div>'; // Message clair
  } else {
    // Cas où le mot est trouvé
    pinyinEl.textContent = numericToDiacriticPinyin(entry.pinyin); // Convertir et afficher le pinyin

    // Vider les anciennes définitions et ajouter les nouvelles
    defsEl.innerHTML = ''; // Important pour ne pas cumuler les définitions
    if (entry.defs && entry.defs.length > 0) {
      entry.defs.forEach(def => {
        const defDiv = document.createElement('div');
        defDiv.className = 'dict-def';
        defDiv.textContent = def;
        defsEl.appendChild(defDiv);
      });
    } else {
      // Si l'entrée existe mais n'a pas de définition
      defsEl.innerHTML = '<div class="dict-def">Aucune définition disponible pour ce mot.</div>';
    }
  }

  // --- 4. Gestion des Tags (HSK / Fréquence) ---
  // Supprimer l'ancien conteneur de tags s'il existe pour éviter les doublons
  const existingTagsContainer = content.querySelector('.dict-tags-container');
  if (existingTagsContainer) {
    existingTagsContainer.remove();
  }

  // Récupération des niveaux (même si l'entrée dictionnaire est absente)
  const hskLevel = getLevel(word, 'hsk');
  const freqLevel = getLevel(word, 'freq');
  const freqLabels = ['0-1k', '1-2k', '2-3k', '3-4k', '4-5k', '5-7k', '7-10k', '10-15k', '15-40k'];

  // Créer le conteneur de tags seulement si au moins un niveau est trouvé
  if (hskLevel > 0 || freqLevel > 0) {
    const tagsContainer = document.createElement('div');
    tagsContainer.className = 'dict-tags-container';

    // Ajouter le tag HSK s'il existe
    if (hskLevel > 0) {
      const hskTag = document.createElement('span');
      const hskClassSuffix = hskLevel === 7 ? '79' : hskLevel; // Gérer le cas HSK 7-9
      const hskText = hskLevel === 7 ? 'HSK 7-9' : `HSK ${hskLevel}`;
      hskTag.className = `dict-tag level-${hskClassSuffix}`;
      hskTag.textContent = hskText;
      tagsContainer.appendChild(hskTag);
    }

    // Ajouter le tag Fréquence s'il existe et est valide
    if (freqLevel > 0 && freqLevel <= freqLabels.length) {
      const freqTag = document.createElement('span');
      freqTag.className = `dict-tag freq-${freqLevel}`;
      freqTag.textContent = freqLabels[freqLevel - 1]; // Index 0 pour niveau 1
      tagsContainer.appendChild(freqTag);
    }

    // Insérer le conteneur de tags juste après l'élément Pinyin
    // `pinyinEl.after(tagsContainer)` est une méthode moderne et plus simple
    pinyinEl.after(tagsContainer);
  }

  // --- 5. Afficher le Modal ---
  console.log('Tentative d\'affichage du modal (ajout classe active)'); // Log avant affichage
  modal.classList.add('active');

  // Optionnel: Ajouter un focus sur le bouton fermer pour l'accessibilité
  if (closeBtn) {
    // Mettre le focus après un très court délai pour s'assurer que le modal est visible
    setTimeout(() => closeBtn.focus(), 50);
  }
}

function closeModal(modalId) { // Fonction closeModal générique conservée
    const modal = document.getElementById(modalId);
    if(modal) modal.classList.remove('active');
}


// *** NOUVELLE LOGIQUE DE REVEAL ***
// Garder une référence au timer pour la traduction
let readTranslationTimer = null;

// Fonction pour démarrer/redémarrer les animations
function startTypeAnimation() {
  stopTypeAnimation(); // Arrête tout timer précédent

  readCurrentIndex = 0;
  readTranslationCurrentIndex = 0;
  readIsPlaying = true;

  // Mettre à jour l'icône Play/Pause... (comme avant)
  const btn = document.getElementById('readPlayPause');
  if (btn) btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';
  const szBtn = document.getElementById('szBtnPlay');
  if (szBtn && readSuperZen) szBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';

  // --- Préparer les textes ---
  readChars.forEach(char => char.style.visibility = 'hidden');
  prepareTranslationForTyping(); // Assure que readTranslationChars est prêt et caché

  // Réinitialiser la barre de progression
  const progressBar = document.getElementById('readProgressBar');
  if(progressBar) progressBar.style.width = '0%';

  // S'assurer que les boundaries sont détectées
  detectSentenceBoundaries(); // Essentiel pour cette logique

  // --- Lancer les animations ---
  const chineseCharDelay = (readChars.length > 0 && readCPM > 0) ? (60000 / readCPM) : Infinity;
  const minDelay = 10; // Délai minimum absolu

  if (readChars.length > 0 && chineseCharDelay !== Infinity) {
      scheduleNextChineseChar(Math.max(minDelay, chineseCharDelay));
  } else {
      checkAnimationEnd();
  }

  // Lancer la traduction - elle calculera son premier délai à l'intérieur
  if (readTranslationChars.length > 0) {
      scheduleNextTranslationChar();
  } else {
       checkAnimationEnd();
  }
}

// --- Fonction pour arrêter toutes les animations ---
function stopTypeAnimation() {
  readIsPlaying = false;

  if (readTimer) { clearTimeout(readTimer); readTimer = null; }
  if (readTranslationTimer) { clearTimeout(readTranslationTimer); readTranslationTimer = null; }
  if (readPauseTimeout) { clearTimeout(readPauseTimeout); readPauseTimeout = null; }

  // Mettre à jour l'icône Play/Pause... (comme avant)
  const btn = document.getElementById('readPlayPause');
  if (btn) btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
  const szBtn = document.getElementById('szBtnPlay');
  if (szBtn && readSuperZen) szBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
}



// Fonction récursive pour l'animation chinoise
function scheduleNextChineseChar(delay) {
    if (!readIsPlaying || readCurrentIndex >= readChars.length) {
        checkAnimationEnd();
        return;
    }
    const char = readChars[readCurrentIndex];
    if (char) char.style.visibility = 'visible';
    readCurrentIndex++;
    const progress = (readCurrentIndex / readChars.length) * 100;
    const progressBar = document.getElementById('readProgressBar');
    if (progressBar) progressBar.style.width = `${progress}%`;
    if(readTimer) clearTimeout(readTimer); // Sécurité
    readTimer = setTimeout(() => scheduleNextChineseChar(delay), delay);
}

// --- Fonction récursive pour l'animation de traduction (MODIFIED - calcule délai DYNAMIQUEMENT) ---
function scheduleNextTranslationChar() {
    if (!readIsPlaying || readTranslationCurrentIndex >= readTranslationChars.length || readSentenceBoundaries.length === 0) {
        checkAnimationEnd();
        return;
    }

    // 1. Trouver la phrase (boundary) correspondant à l'index de traduction ACTUEL
    let currentSentenceData = null;
    let boundaryIndex = -1;
    for(let i = 0; i < readSentenceBoundaries.length; i++) {
        // La boundary est valide si l'index de traduction est DANS ses limites de traduction
        if (readTranslationCurrentIndex >= readSentenceBoundaries[i].translationStart &&
            readTranslationCurrentIndex < readSentenceBoundaries[i].translationEnd)
        {
             currentSentenceData = readSentenceBoundaries[i];
             boundaryIndex = i;
             break;
        }
    }
    // Cas spécial: si l'index de traduction a dépassé la fin, mais qu'il en reste (peut arriver si boundaries imparfaites)
    // On prend la dernière boundary comme référence pour le délai.
     if (!currentSentenceData && readTranslationCurrentIndex < readTranslationChars.length && readSentenceBoundaries.length > 0) {
         currentSentenceData = readSentenceBoundaries[readSentenceBoundaries.length - 1];
         boundaryIndex = readSentenceBoundaries.length - 1;
         console.warn("Translation index out of bounds, using last sentence data.");
     }

    // 2. Calculer le délai basé sur la durée de la phrase chinoise correspondante
    let translationCharDelay = 60000 / readCPM; // Délai par défaut
    const minDelay = 10; // Délai minimum

    if (currentSentenceData) {
        const chineseCharDelay = (readCPM > 0) ? (60000 / readCPM) : 500; // Délai par caractère chinois
        // Durée totale de la phrase chinoise (ms)
        const chineseSentenceDuration = currentSentenceData.chineseLength * chineseCharDelay;

        // Calculer le délai par caractère de traduction pour CETTE phrase
        if (currentSentenceData.translationLength > 0 && chineseSentenceDuration > 0) {
            translationCharDelay = chineseSentenceDuration / currentSentenceData.translationLength;
        } else if (currentSentenceData.translationLength > 0 && chineseSentenceDuration <= 0) {
            // Si phrase chinoise vide/instantanée, utiliser vitesse de base
            translationCharDelay = chineseCharDelay;
        } else {
            // Pas de traduction pour cette phrase, délai infini (ne devrait pas arriver ici si check initial ok)
             translationCharDelay = Infinity;
        }
    } else {
        // Pas trouvé de boundary valide -> utiliser délai par défaut
        console.warn("Could not find sentence boundary for translation index:", readTranslationCurrentIndex);
        translationCharDelay = 60000 / readCPM;
    }

    // Assurer un délai minimum
    translationCharDelay = Math.max(minDelay, translationCharDelay);

    // 3. Révéler et Planifier (si délai valide)
    if (translationCharDelay !== Infinity) {
        const trChar = readTranslationChars[readTranslationCurrentIndex];
        if (trChar) trChar.style.visibility = 'visible';
        readTranslationCurrentIndex++;

        // Planifier le prochain avec le délai calculé pour cette phrase
        if(readTranslationTimer) clearTimeout(readTranslationTimer); // Clear previous
        readTranslationTimer = setTimeout(scheduleNextTranslationChar, translationCharDelay);
    } else {
        // Délai infini (pas de trad pour cette phrase?), attendre simplement la fin du chinois
        checkAnimationEnd(); // Vérifier si le chinois est fini
        // Ne pas replanifier ce timer s'il n'y a rien à faire
    }
}


// --- Fonction pour vérifier si les deux animations sont terminées ---
function checkAnimationEnd() {
    if (!readIsPlaying && !document.getElementById('readPage').classList.contains('active')) return;

    const chineseDone = readCurrentIndex >= readChars.length;
    const translationDone = readTranslationCurrentIndex >= readTranslationChars.length;

    if (chineseDone && translationDone && readIsPlaying) {
        console.log("Animations terminées (Per Sentence Fixed Delay) !");
        stopTypeAnimation(); // Met l'état à false et met à jour l'UI

        if (readSuperZen && readSuperZenType && readCurrentSentence < readSentences.length - 1) {
             if (readPauseTimeout) clearTimeout(readPauseTimeout);
             readPauseTimeout = setTimeout(() => {
                  if(readSuperZen && readSuperZenType && readIsPlaying === false) {
                    superZenNext();
                  }
             }, 1500); // Pause
        }
    }
}


// Assurez-vous que togglePlayPause utilise bien start/stop (Unchanged from correct previous version)
function togglePlayPause() {
  if (readIsPlaying) {
    // PAUSING
    console.log("Pausing animation...");
    stopTypeAnimation(); // Met l'état à false et nettoie les timers
  } else {
    // RESUMING (Only if in a typing mode)
    if (readDisplayMode === 'type' || readSuperZenType) {
      console.log("Resuming animation...");
      readIsPlaying = true; // Set state to playing

      // --- Update button icons ---
      const btn = document.getElementById('readPlayPause');
      if (btn) btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';
      const szBtn = document.getElementById('szBtnPlay');
      if (szBtn && readSuperZen) szBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';

      // --- Re-schedule the next character reveal WITHOUT resetting indices ---
      // Recalculate delays based on current state (important for translation)
      const chineseCharDelay = (readChars.length > 0 && readCPM > 0) ? (60000 / readCPM) : Infinity;
      const minDelay = 10;

      // Re-schedule Chinese character if not finished
      if (readCurrentIndex < readChars.length && chineseCharDelay !== Infinity) {
          if(readTimer) clearTimeout(readTimer); // Clear just in case
          readTimer = setTimeout(() => scheduleNextChineseChar(Math.max(minDelay, chineseCharDelay)), Math.max(minDelay, chineseCharDelay)); // Use delay for first resume tick too
      } else {
           checkAnimationEnd(); // Check if finished
      }

      // Re-schedule Translation character if not finished
      if (readTranslationCurrentIndex < readTranslationChars.length) {
          if(readTranslationTimer) clearTimeout(readTranslationTimer); // Clear just in case
          // Schedule normally, it will calculate its own delay based on current Chinese index
          readTranslationTimer = setTimeout(scheduleNextTranslationChar, 50); // Start check shortly after resume
      } else {
          checkAnimationEnd(); // Check if finished
      }
    }
    // If not in typing mode, clicking play does nothing (button should be disabled anyway)
  }
}

function prepareTranslationForTyping() {
  readTranslationChars = []; // Vider l'array
  readTranslationCurrentIndex = 0; // Réinitialiser l'index

  let translationContainer;

  if (readSuperZen) {
    translationContainer = document.getElementById('readTranslation');
  } else {
    const flipBack = document.querySelector('.flip-back#readTranslation');
    translationContainer = flipBack || document.getElementById('readTranslation');
  }

  if (!translationContainer) {
      console.warn("Translation container not found for typing preparation.");
      return;
  }

  const clone = translationContainer.cloneNode(true);
  translationContainer.innerHTML = '';

  function processNode(node) {
      if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          for (let i = 0; i < text.length; i++) {
              const span = document.createElement('span');
              span.textContent = text[i];
              span.style.visibility = 'hidden';
              translationContainer.appendChild(span);
              readTranslationChars.push(span);
          }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
          const isParagraph = node.tagName === 'P';
          Array.from(node.childNodes).forEach(processNode);
          if (isParagraph && node !== clone.lastElementChild) {
              const spaceSpan = document.createElement('span');
              spaceSpan.textContent = ' ';
              spaceSpan.style.visibility = 'hidden';
              translationContainer.appendChild(spaceSpan);
              readTranslationChars.push(spaceSpan);
          }
      }
  }
  Array.from(clone.childNodes).forEach(processNode);
   // console.log("Prepared translation chars:", readTranslationChars.length); // Keep for debug if needed
}


function toggleReadMode() {
  stopTypeAnimation(); // Always stop animation when toggling

  const playPauseBtn = document.getElementById('readPlayPause');

  if (readDisplayMode === 'instant') {
    // Switching TO 'type'
    readDisplayMode = 'type';
    startTypeAnimation(); // Start animation (will enable button via updateReadModeButton)
  } else {
    // Switching FROM 'type' TO 'instant'
    readDisplayMode = 'instant';
    // Make sure all text is visible
    readChars.forEach(char => char.style.visibility = 'visible');
    // Ensure translation text (not spans) is visible if prepared
    const translationEl = document.querySelector('#readTranslation, .flip-back#readTranslation');
    if (translationEl) {
        // Option 1: Just show existing spans (simpler)
         readTranslationChars.forEach(char => char.style.visibility = 'visible');
        // Option 2: Re-render original text (cleaner but might cause flicker)
        // renderReadText(); // Re-rendering handles visibility based on new mode
    }
    const progressBar = document.getElementById('readProgressBar');
    if(progressBar) progressBar.style.width = '100%';
    // Disable play button explicitly here as updateReadModeButton runs right after
    if(playPauseBtn) playPauseBtn.disabled = true;
  }
  updateReadModeButton(); // Update visual state of toggle button and play button
  updateFocusButtonState();
}

function updateReadModeButton() {
  const btn = document.getElementById('readModeToggle');
  if (btn) {
    const span = btn.querySelector('span');
    if (readDisplayMode === 'instant') {
      span.textContent = 'Instant';
      btn.classList.remove('active'); // Remove active class in instant mode
    } else { // 'type' mode
      span.textContent = 'Frappe';
      btn.classList.add('active'); // Add active class in type mode
    }
  }
  // Also update the main play/pause button state based on the mode
  const playPauseBtn = document.getElementById('readPlayPause');
  if(playPauseBtn) {
      // Disable if mode is 'instant'
      playPauseBtn.disabled = (readDisplayMode === 'instant');
  }
}

function toggleSuperZen() {
  const page = document.getElementById('readPage');
  const mainPlayPauseBtn = document.getElementById('readPlayPause');
  const szPlayBtn = document.getElementById('szBtnPlay');

  readSuperZen = !readSuperZen;
  stopTypeAnimation(); // Stop any ongoing animation

  if (readSuperZen) {
    // Entering Super Zen
    page.classList.add('super-zen');
    readCurrentSentence = 0;
    readSuperZenType = false; // Start in non-typing mode
    const typeBtn = document.getElementById('szBtnType');
    if(typeBtn) typeBtn.classList.remove('active');

    // Disable main play button as it's not used here
    if(mainPlayPauseBtn) mainPlayPauseBtn.disabled = true;
    // Disable SZ play button initially (since not in type mode)
    if(szPlayBtn) szPlayBtn.disabled = true;

    renderReadText(); // Renders the single sentence
    // Ensure text is visible in initial SZ non-typing mode
    readChars.forEach(char => char.style.visibility = 'visible');
    readTranslationChars.forEach(char => char.style.visibility = 'visible');

  } else {
    // Exiting Super Zen
    page.classList.remove('super-zen');
    readSuperZenType = false;
    isFlipped = false; // Reset flip

    // Re-enable main play button ONLY if the main mode is 'type'
    if(mainPlayPauseBtn) {
        mainPlayPauseBtn.disabled = (readDisplayMode === 'instant');
    }

    renderReadText(); // Re-render full text for normal mode

    // Restart main animation if applicable
    if (readDisplayMode === 'type') {
      startTypeAnimation();
    } else {
      // Ensure everything is visible in instant mode
      readChars.forEach(char => char.style.visibility = 'visible');
      // Ensure translation is visible (might have been spans before)
      const translationEl = document.querySelector('#readTranslation, .flip-back#readTranslation');
       if (translationEl) {
           Array.from(translationEl.querySelectorAll('span')).forEach(span => span.style.visibility = 'visible');
       }
    }
  }
  
  updateFocusButtonState();

  // Update flip button visibility
  const flipBtn = document.getElementById('readFlipBtn');
  const container = document.getElementById('readTextContainer');
  const isMobile = window.matchMedia('(max-width: 900px)').matches;
  if(flipBtn && container){
      flipBtn.style.display = (isMobile && !readSuperZen && readTranslations.length > 0 && container.classList.contains('has-flip')) ? 'flex' : 'none';
  }
}


function toggleSuperZenType() {
  const btn = document.getElementById('szBtnType');
  const szPlayBtn = document.getElementById('szBtnPlay');
  if (!btn || !szPlayBtn) return;

  readSuperZenType = !readSuperZenType;

  if (readSuperZenType) {
    // Entering SZ Typing
    btn.classList.add('active');
    szPlayBtn.disabled = false; // Enable SZ play button
    // Render might be needed if switching from non-SZ type mode,
    // but startTypeAnimation includes prepare/hide steps anyway.
    // renderReadText(); // Optional, depends if content needs refreshing
    startTypeAnimation(); // Start animation for the current sentence
  } else {
    // Exiting SZ Typing
    btn.classList.remove('active');
    stopTypeAnimation();
    szPlayBtn.disabled = true; // Disable SZ play button
    // Make sure all text for the current sentence is visible
    readChars.forEach(char => char.style.visibility = 'visible');
    readTranslationChars.forEach(char => char.style.visibility = 'visible');
  }
}

function superZenNext() {
  if (readCurrentSentence < readSentences.length - 1) {
    stopTypeAnimation(); // Arrête l'anim en cours
    readCurrentSentence++;
    renderReadText(); // Affiche la nouvelle phrase
    if (readSuperZenType) {
      startTypeAnimation(); // Redémarre l'anim si on est en mode frappe
    } else {
       // Sinon s'assurer que tout est visible
        readChars.forEach(char => char.style.visibility = 'visible');
        readTranslationChars.forEach(char => char.style.visibility = 'visible');
    }
  }
}

function superZenPrev() {
  if (readCurrentSentence > 0) {
    stopTypeAnimation();
    readCurrentSentence--;
    renderReadText();
    if (readSuperZenType) {
      startTypeAnimation();
    } else {
       readChars.forEach(char => char.style.visibility = 'visible');
       readTranslationChars.forEach(char => char.style.visibility = 'visible');
    }
  }
}

function superZenTogglePlay() {
  // Fonctionne seulement si on est en mode frappe Super Zen
  if(readSuperZenType) {
      togglePlayPause();
  }
}

function adjustFontSize(delta) {
  readFontSize = Math.max(16, Math.min(72, readFontSize + delta));
  document.getElementById('readFontSize').textContent = readFontSize + 'px';

  // Sélectionne les bons éléments même en mode flip ou super zen
  const readText = document.querySelector('#readText');
  const readTranslation = document.querySelector('#readTranslation');

  if (readText) readText.style.fontSize = readFontSize + 'px';
  if (readTranslation) readTranslation.style.fontSize = (readFontSize * 0.8) + 'px';
}

function toggleFlip() {
  const flipContainer = document.getElementById('flipContainer');
  if (flipContainer) {
    isFlipped = !isFlipped;
    flipContainer.classList.toggle('flipped');

    // Ajuste la hauteur après le début de l'animation (300ms est la moitié de 0.6s)
    // pour lire la hauteur de la face qui devient visible.
    setTimeout(adjustFlipHeight, 300); 
  }
}

function adjustFlipHeight() {
    const flipContainer = document.getElementById('flipContainer');
    // Vérifie si on est en mode flip mobile
    if (flipContainer && flipContainer.closest('.has-flip') && window.matchMedia('(max-width: 900px)').matches) {
        const flipInner = flipContainer.querySelector('.flip-inner');
        const activeFace = flipContainer.querySelector(isFlipped ? '.flip-back' : '.flip-front');

        if (flipInner && activeFace) {
            // S'assure que la face est visible pour calculer scrollHeight
            const wasHidden = activeFace.style.visibility === 'hidden';
            if (wasHidden) activeFace.style.visibility = 'visible'; // Rend temporairement visible si besoin

            const contentHeight = activeFace.scrollHeight;
            flipInner.style.height = `${contentHeight}px`; // Applique la hauteur au conteneur interne

            if (wasHidden) activeFace.style.visibility = 'hidden'; // Cache à nouveau si c'était le cas

            // Optionnel: Log pour débogage
            // console.log(`AdjustFlipHeight: Flipped=${isFlipped}, Face=${activeFace.classList.contains('flip-back') ? 'Back' : 'Front'}, Height=${contentHeight}px`);
        }
    }
}

function toggleFocusMode() {
  readFocusMode = !readFocusMode;
  const btn = document.getElementById('readFocusToggle');
  if(btn) btn.classList.toggle('active');

  applyReadColors(); // Applique le filtrage/masquage

  if (readFocusMode) {
    showCopyNotification();
  }
}

function showCopyNotification() {
  let notif = document.getElementById('copyNotification');
  if (!notif) {
    notif = document.createElement('div');
    notif.id = 'copyNotification';
    notif.style.cssText = `
      position: fixed; top: 80px; right: 24px; background: var(--accent);
      color: white; padding: 12px 20px; border-radius: 8px; font-size: 14px;
      font-weight: 600; box-shadow: var(--shadow); z-index: 10000;
      opacity: 0; transform: translateY(-10px); transition: all 0.3s ease;
      pointer-events: none;
    `;
    notif.textContent = '📋 Mots copiés !';
    document.body.appendChild(notif);
  }

  setTimeout(() => {
    notif.style.opacity = '1';
    notif.style.transform = 'translateY(0)';
  }, 10);

  setTimeout(() => {
    notif.style.opacity = '0';
    notif.style.transform = 'translateY(-10px)';
  }, 2000);
}

function closeReadMode() {
  stopTypeAnimation();
  document.getElementById('readPage').classList.remove('active');
  document.getElementById('homePage').style.display = 'block';

  const flipBtn = document.getElementById('readFlipBtn');
  if (flipBtn) flipBtn.style.display = 'none';

  // Réinitialiser les états spécifiques au mode lecture
  readSuperZen = false;
  readSuperZenType = false;
  isFlipped = false;
  readFocusMode = false;
  readIsPlaying = false;
}

// =====================================================
// MODAL FUNCTIONS (Génériques)
// =====================================================
function showSentencesPreviewModal(zhSentences, trSentences) {
    const modal = document.getElementById('sentencesPreviewModal');
    const body = document.getElementById('sentencesPreviewModalBody');
     if(!modal || !body) return;

    body.innerHTML = '';

    const count = Math.max(zhSentences.length, trSentences.length);
    if (count === 0) {
        body.textContent = "Aucune phrase à afficher.";
    } else {
        for (let i = 0; i < count; i++) {
            const item = document.createElement('div');
            item.className = 'sentence-preview-item';
            const num = document.createElement('div');
            num.className = 'sentence-preview-number'; num.textContent = i + 1;
            const texts = document.createElement('div');
            texts.className = 'sentence-preview-texts';
            const zhDiv = document.createElement('div');
            zhDiv.className = 'sentence-preview-zh'; zhDiv.textContent = zhSentences[i] || '(Pas de texte chinois)';
            const trDiv = document.createElement('div');
            trDiv.className = 'sentence-preview-tr'; trDiv.textContent = trSentences[i] || '(Pas de traduction)';
            texts.appendChild(zhDiv); texts.appendChild(trDiv);
            item.appendChild(num); item.appendChild(texts);
            body.appendChild(item);
        }
    }
    modal.classList.add('active');
}


// =====================================================
// EVENT LISTENERS (DOM LOADED)
// =====================================================
document.addEventListener('DOMContentLoaded', () => {
  console.log('=== APP FUSIONNÉE CHARGÉE (v2 - Read Fixes) ===');

  // --- Éléments ---
  const modeGameBtn = document.getElementById('modeGameBtn');
  const modeReadBtn = document.getElementById('modeReadBtn');
  const tab1Btn = document.getElementById('tab1Btn');
  const tab2Btn = document.getElementById('tab2Btn');
  const themeBtns = document.querySelectorAll('.theme-btn');
  const gameCategoryBtns = document.querySelectorAll('#gameCategorySelector .category-btn');
  const gameHskBtns = document.querySelectorAll('#gameHskSelector .hsk-selector-btn');
  const gameFreqBtns = document.querySelectorAll('#gameFreqSelector .hsk-selector-btn');
  const readCategoryBtns = document.querySelectorAll('#readCategorySelector .category-btn');
  const readHskBtns = document.querySelectorAll('#hskSelector .hsk-selector-btn');
  const readFreqBtns = document.querySelectorAll('#freqSelector .hsk-selector-btn');
  const cpmAttackSlider = document.getElementById('cpmAttackTarget');
  const cpmReadSlider = document.getElementById('cpm');
  const inputZh = document.getElementById('inputZh');
  const inputTr = document.getElementById('inputTr');
  const dictFileInput = document.getElementById('dictFile');
  const hskFileInput = document.getElementById('hskFile');
  const launchBtn = document.getElementById('launchBtn');
  const quitGameBtn = document.getElementById('quitGameBtn');
  const hintBtn = document.getElementById('hintBtn');
  const validateBtn = document.getElementById('validateBtn');
  const prevSentenceBtn = document.getElementById('prevSentenceBtn');
  const nextSentenceBtn = document.getElementById('nextSentenceBtn');
  const restartBtn = document.getElementById('restartBtn');
  const gameModeSelect = document.getElementById('gameMode');

  const readCloseBtn = document.getElementById('readCloseBtn');
  const readPlayPauseBtn = document.getElementById('readPlayPause');
  const readModeToggleBtn = document.getElementById('readModeToggle');
  const readZenToggleBtn = document.getElementById('readZenToggle');
  const readFocusToggleBtn = document.getElementById('readFocusToggle');
  const readFontUpBtn = document.getElementById('readFontUp');
  const readFontDownBtn = document.getElementById('readFontDown');
  const readFlipBtn = document.getElementById('readFlipBtn');
  const readProgress = document.getElementById('readProgress');

  const szBtnQuit = document.getElementById('szBtnQuit');
  const szBtnType = document.getElementById('szBtnType');
  const szBtnPrev = document.getElementById('szBtnPrev');
  const szBtnPlay = document.getElementById('szBtnPlay');
  const szBtnNext = document.getElementById('szBtnNext');

  const closeDictModalBtn = document.getElementById('closeDictModal');
  const closeSentencesPreviewModalBtn = document.getElementById('closeSentencesPreviewModal');
  const dictModalEl = document.getElementById('dictModal');
  const sentencesPreviewModalEl = document.getElementById('sentencesPreviewModal');

  // --- Attachement des listeners ---
  if(modeGameBtn) modeGameBtn.addEventListener('click', () => switchMode('game'));
  if(modeReadBtn) modeReadBtn.addEventListener('click', () => switchMode('read'));
  if(tab1Btn) tab1Btn.addEventListener('click', () => switchTab('1'));
  if(tab2Btn) tab2Btn.addEventListener('click', () => switchTab('2'));

  themeBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const theme = this.dataset.theme;
      document.body.setAttribute('data-theme', theme);
      themeBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
    });
  });

  gameCategoryBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const category = this.dataset.category;
      gameCategoryBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      const gameHskSel = document.getElementById('gameHskSelector');
      const gameFreqSel = document.getElementById('gameFreqSelector');
      if(gameHskSel && gameFreqSel) {
          gameHskSel.style.display = category === 'hsk' ? 'grid' : 'none';
          gameFreqSel.style.display = category === 'hsk' ? 'none' : 'grid';
      }
    });
  });
  gameHskBtns.forEach(btn => btn.addEventListener('click', function() { this.classList.toggle('active'); }));
  gameFreqBtns.forEach(btn => btn.addEventListener('click', function() { this.classList.toggle('active'); }));

  readCategoryBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const category = this.dataset.category;
      readCategory = category; // Mettre à jour la variable globale
      readCategoryBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      const hskSel = document.getElementById('hskSelector');
      const freqSel = document.getElementById('freqSelector');
      const label = document.getElementById('levelSelectorLabel');
      if(hskSel && freqSel && label) {
          hskSel.style.display = category === 'hsk' ? 'grid' : 'none';
          freqSel.style.display = category === 'hsk' ? 'none' : 'grid';
          label.textContent = category === 'hsk' ? 'Niveaux HSK à surligner' : 'Tranches de fréquence à surligner';
      }
      // Mettre à jour les filtres affichés si on est en mode lecture
      if (document.getElementById('readPage').classList.contains('active')) {
          createReadFilters();
          applyReadColors();
          updateReadDifficulty();
      }
    });
  });
  readHskBtns.forEach(btn => btn.addEventListener('click', function() { this.classList.toggle('active'); }));
  readFreqBtns.forEach(btn => btn.addEventListener('click', function() { this.classList.toggle('active'); }));

  if(cpmAttackSlider) cpmAttackSlider.addEventListener('input', (e) => {
    const valueEl = document.getElementById('cpmAttackTargetValue');
    if(valueEl) valueEl.textContent = e.target.value + ' car/min';
  });
  if(cpmReadSlider) cpmReadSlider.addEventListener('input', (e) => {
    const valueEl = document.getElementById('cpmValue');
    readCPM = parseInt(e.target.value, 10); // Mettre à jour la variable globale
    if(valueEl) valueEl.textContent = readCPM + ' car/min';
  });

  if(inputZh) inputZh.addEventListener('input', updateSentencesPreview);
  if(inputTr) inputTr.addEventListener('input', updateSentencesPreview);

  if(dictFileInput) dictFileInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = () => { dict = parseCedict(reader.result); document.getElementById('dictStatus').textContent = `✅ (${dict.wordSet.size} mots)`; };
    reader.readAsText(file, 'utf-8');
  });
  if(hskFileInput) hskFileInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = () => { levelMap = csvToLevelMap(reader.result); document.getElementById('hskStatus').textContent = `✅ (${levelMap.size} mots)`; };
    reader.readAsText(file, 'utf-8');
  });

  if (launchBtn) {
    launchBtn.addEventListener('click', () => {
      if (appMode === 'game') {
        startGame();
      } else {
        // Mode Lecture
        const readModeSetting = document.getElementById('readDisplayModeSetting').value;
        const oldDisplayModeSelect = document.getElementById('displayMode');

        // S'assurer que l'ancien <select> masqué a la bonne valeur
        if (readModeSetting === 'instant' || readModeSetting === 'superzen') {
          oldDisplayModeSelect.value = 'instant';
        } else { // 'type'
          oldDisplayModeSelect.value = 'type';
        }

        // Lancer la lecture
        startReadMode();

        // Si Superzen est choisi, l'activer juste après le lancement
        if (readModeSetting === 'superzen') {
          // Petit délai pour laisser à startReadMode le temps de s'initialiser
          setTimeout(toggleSuperZen, 50); 
        }
      }
    });
  }

  // GAME BUTTONS
  if(quitGameBtn) quitGameBtn.addEventListener('click', quitGame);
  if(hintBtn) hintBtn.addEventListener('click', giveHint);
  if(validateBtn) validateBtn.addEventListener('click', validateAnswer);
  if(restartBtn) restartBtn.addEventListener('click', loadSentence);
  if(prevSentenceBtn) prevSentenceBtn.addEventListener('click', () => goToSentence(-1));
  if(nextSentenceBtn) nextSentenceBtn.addEventListener('click', () => goToSentence(1));
  
  const gameModeSelector = document.getElementById('gameModeSelector');
  const gameModeInput = document.getElementById('gameMode'); // Le hidden input

  if (gameModeSelector && gameModeInput) {
  // Gérer le clic sur la grille de boutons
  gameModeSelector.addEventListener('click', (e) => {
    const button = e.target.closest('.game-mode-btn');
    if (!button) return; // Clic en dehors d'un bouton

    const newMode = button.dataset.mode;
    
    // 1. Mettre à jour la valeur de l'input caché
    gameModeInput.value = newMode;
    
    // 2. Mettre à jour l'UI (classe 'active')
    gameModeSelector.querySelectorAll('.game-mode-btn').forEach(btn => btn.classList.remove('active'));
    button.classList.add('active');

    // 3. Appeler la fonction existante qui met à jour les options
    updateGameOptionsUI(); 
  });
}

const readDisplaySelector = document.getElementById('readDisplayModeSelector');
  const readDisplayInput = document.getElementById('readDisplayModeSetting');
  const oldDisplayModeSelect = document.getElementById('displayMode'); // L'ancien <select> masqué

  if (readDisplaySelector && readDisplayInput && oldDisplayModeSelect) {
      readDisplaySelector.addEventListener('click', (e) => {
          const button = e.target.closest('.display-mode-btn');
          if (!button) return;

          const newMode = button.dataset.mode;
          
          // 1. Mettre à jour l'input caché qui stocke notre choix
          readDisplayInput.value = newMode;

          // 2. Mettre à jour l'ancien <select> masqué pour compatibilité
          if (newMode === 'instant' || newMode === 'superzen') {
              oldDisplayModeSelect.value = 'instant';
          } else { // 'type'
              oldDisplayModeSelect.value = 'type';
          }

          // 3. Mettre à jour l'interface des boutons
          readDisplaySelector.querySelectorAll('.display-mode-btn').forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
      });
  }

const freeInputDisplaySelector = document.getElementById('freeInputDisplaySelector');
const freeInputDisplayModeInput = document.getElementById('freeInputDisplayMode');

if (freeInputDisplaySelector && freeInputDisplayModeInput) {
    freeInputDisplaySelector.addEventListener('click', (e) => {
        const button = e.target.closest('.display-mode-btn');
        if (!button) return;

        const newMode = button.dataset.mode;
        freeInputDisplayModeInput.value = newMode;

        freeInputDisplaySelector.querySelectorAll('.display-mode-btn').forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
    });
}
// FIN DE

  // READ BUTTONS
  if(readCloseBtn) readCloseBtn.addEventListener('click', closeReadMode);
  if(readPlayPauseBtn) readPlayPauseBtn.addEventListener('click', togglePlayPause);
  if(readModeToggleBtn) readModeToggleBtn.addEventListener('click', toggleReadMode);
  if(readZenToggleBtn) readZenToggleBtn.addEventListener('click', toggleSuperZen);
  if(readFocusToggleBtn) readFocusToggleBtn.addEventListener('click', toggleFocusMode);
  if(readFontUpBtn) readFontUpBtn.addEventListener('click', () => adjustFontSize(4));
  if(readFontDownBtn) readFontDownBtn.addEventListener('click', () => adjustFontSize(-4));
  if(readFlipBtn) readFlipBtn.addEventListener('click', toggleFlip);

  // --- GESTION CACHER/AFFICHER CONTROLES MOBILE ---
  const readPage = document.getElementById('readPage');
  const hideControlsBtn = document.getElementById('hideControlsBtn');
  const showControlsBtn = document.getElementById('showControlsBtn');

  if (readPage && hideControlsBtn && showControlsBtn) {
    hideControlsBtn.addEventListener('click', () => {
      readPage.classList.add('controls-hidden');
    });

    showControlsBtn.addEventListener('click', () => {
      readPage.classList.remove('controls-hidden');
    });
  }

  // SUPER ZEN BUTTONS
  if(szBtnQuit) szBtnQuit.addEventListener('click', toggleSuperZen); // Quitter revient à désactiver le mode
  if(szBtnType) szBtnType.addEventListener('click', toggleSuperZenType);
  if(szBtnPrev) szBtnPrev.addEventListener('click', superZenPrev);
  if(szBtnNext) szBtnNext.addEventListener('click', superZenNext);
  if(szBtnPlay) szBtnPlay.addEventListener('click', superZenTogglePlay);

  // --- GESTION DU SWIPER MOBILE ---
  const readControlsInner = document.getElementById('readControlsInner');
  const readControlsDots = document.getElementById('readControlsDots');

  if(readControlsInner && readControlsDots) {
    readControlsInner.addEventListener('scroll', () => {
      // Mettre à jour les dots uniquement si on est en affichage mobile
      if (window.getComputedStyle(readControlsDots).display === 'flex') {
        const panelWidth = readControlsInner.offsetWidth;
        const scrollLeft = readControlsInner.scrollLeft;
        
        // Calculer l'index du panneau le plus proche
        // + panelWidth / 2 pour centrer la détection
        const activeIndex = Math.floor((scrollLeft + panelWidth / 2) / panelWidth);

        readControlsDots.querySelectorAll('.dot').forEach(dot => {
          dot.classList.remove('active');
          if (parseInt(dot.dataset.index) === activeIndex) {
            dot.classList.add('active');
          }
        });
      }
    });
  }


  // READ PROGRESS BAR
  if(readProgress) readProgress.onclick = (e) => {
    // Ne fonctionne que si l'animation est active ou en pause
    if (readDisplayMode !== 'type' && !readSuperZenType) return;
    if (!readIsPlaying) stopTypeAnimation(); // Stop avant de sauter

    const rect = e.currentTarget.getBoundingClientRect();
    const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width)); // Clamp between 0 and 1

    // Calculer les nouveaux index
    readCurrentIndex = Math.floor(percent * readChars.length);
    const ratio = (readTranslationChars.length > 0 && readChars.length > 0) ? readTranslationChars.length / readChars.length : 1;
    readTranslationCurrentIndex = Math.floor(readCurrentIndex * ratio);


    // Mettre à jour l'affichage immédiatement
    readChars.forEach((char, idx) => {
        char.style.visibility = (idx < readCurrentIndex) ? 'visible' : 'hidden';
    });
    readTranslationChars.forEach((char, idx) => {
        char.style.visibility = (idx < readTranslationCurrentIndex) ? 'visible' : 'hidden';
    });

    // Mettre à jour la barre de progression
    const progressBar = document.getElementById('readProgressBar');
    if(progressBar) progressBar.style.width = (percent * 100) + '%';

    // Redémarrer l'animation si elle était en cours
    if (readIsPlaying) {
        // Annuler le timeout précédent pour éviter un double appel
        if (readTimer) clearTimeout(readTimer);
        // Redémarrer après un court délai pour laisser le navigateur rafraîchir
        readTimer = setTimeout(revealNextChar, 50);
    } else {
        // Si on était en pause, on met à jour l'icône car on a avancé
         const btn = document.getElementById('readPlayPause');
         if (btn) btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
         const szBtn = document.getElementById('szBtnPlay');
         if (szBtn && readSuperZen) szBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
    }
  };

  // MODAL CLOSE BUTTONS (Fusionnés)
  if(closeDictModalBtn) closeDictModalBtn.addEventListener('click', () => closeModal('dictModal'));
  if(closeSentencesPreviewModalBtn) closeSentencesPreviewModalBtn.addEventListener('click', () => closeModal('sentencesPreviewModal'));
  if(dictModalEl) dictModalEl.addEventListener('click', (e) => { if(e.target === dictModalEl) closeModal('dictModal'); });
  if(sentencesPreviewModalEl) sentencesPreviewModalEl.addEventListener('click', (e) => { if(e.target === sentencesPreviewModalEl) closeModal('sentencesPreviewModal'); });

const pinyinTypeSelector = document.querySelector('.pinyin-input-type-selector');
  const pinyinTypeInput = document.getElementById('pinyinInputType');

  if (pinyinTypeSelector && pinyinTypeInput) {
      pinyinTypeSelector.addEventListener('click', (e) => {
          const button = e.target.closest('.pinyin-input-type-btn');
          if (!button) return;

          const newType = button.dataset.type;
          pinyinTypeInput.value = newType;
          pinyinInputType = newType; // Mettre à jour la variable globale

          pinyinTypeSelector.querySelectorAll('.pinyin-input-type-btn').forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');

          // Si on est déjà en jeu Pinyin, recharger la phrase pour appliquer le changement
          if (document.getElementById('gamePage').classList.contains('active') && currentGameMode === 'fill-blanks-pinyin') {
              loadSentence();
          }
      });
  }
  
  // 1. Sécurité : on s'assure que le modal dictionnaire est bien tout en haut du DOM
  const modal = document.getElementById('dictModal');
  if (modal && modal.parentNode !== document.body) {
    document.body.appendChild(modal);
  }

  // 2. On attache UN SEUL écouteur de clic sur la zone de lecture
  const readTextRoot = document.getElementById('readText');
  if (readTextRoot && !readTextRoot.dataset.dictBound) {
    readTextRoot.addEventListener('click', (e) => {
      const span = e.target.closest('.read-char');
      if (!span) return;

      const w = span.dataset.word || span.textContent;
      if (w) {
        openDictModal(w);
      }
    });

    // petit flag pour ne pas binder deux fois si tu relances renderReadText()
    readTextRoot.dataset.dictBound = '1';
  }

  // --- Initialisation finale ---
  updateSentencesPreview();
  switchMode('read');
  updateGameOptionsUI();
  console.log('=== INITIALISATION TERMINÉE (Read Fixes Applied) ===');
});


</script>
</body>
</html>